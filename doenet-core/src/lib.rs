pub mod state_variables;
pub mod component;

pub mod state;
pub mod parse_json;
pub mod utils;
pub mod base_definitions;
pub mod math_expression;

use base_definitions::PROP_INDEX_SV;
use lazy_static::lazy_static;
use parse_json::{DoenetMLError, DoenetMLWarning};
use state::StateForStateVar;
use std::collections::HashMap;
use std::fmt::Debug;

use state::{State, EssentialStateVar};
use component::*;
use state_variables::*;

use crate::math_expression::MathExpression;
use crate::utils::{log_json, log_debug};
use serde::Serialize;


/// A static DoenetCore is created from parsed DoenetML at the beginning.
/// While `component_states` and `essential_data` can update using
/// internal mutability (the RefCell), the over-arching HashMaps are static.
#[derive(Debug)]
pub struct DoenetCore {
    /// The component tree has almost the same structute as the tree of elements
    /// typed into DoenetML, except:
    /// - macros are converted into their own components
    pub component_nodes: HashMap<ComponentName, ComponentNode>,

    /// Keyed by
    /// - `ComponentName` not ComponentRef - a ComponentRef's state variables
    ///   point to the state variables of a ComponentName
    /// - `StateVarName` rather than `StateVarReference`
    ///   so that it is static even when arrays change size
    pub component_states: HashMap<ComponentName, HashMap<StateVarName, StateForStateVar>>,

    pub root_component_name: ComponentName,

    /// **The Dependency Graph**
    /// A DAC whose vertices are the state variables and attributes
    /// of every component, and whose endpoint vertices are essential data.
    ///
    /// Used for
    /// - producing values when determining a state variable
    /// - tracking when a change affects other state variables
    pub dependencies: HashMap<DependencyKey, Vec<Dependency>>,

    pub group_dependencies: HashMap<ComponentName, Vec<GroupDependency>>,

    /// Endpoints of the dependency graph.
    /// Every update instruction will lead to these.
    pub essential_data: HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
}


/// State variables are keyed by:
/// 1. the name of the component
/// 2. the name of a state variable slice
///    which allows for two kinds of dependencies:
///      - direct dependency: when a single state var depends on something
///      - indirect dependency: when a group depends on something,
///        and members of the group inherit the dependency.
///        The motivation for indirect dependencies is that
///        the size of groups can change (e.g. an array changes size).
///        To keep the dependency graph static, we do not update
///        individual dependencies but simply apply the group dependency.
/// 3. the instruction name, given by the state variable to track where
///    dependecy values came from.
#[derive(Debug, Hash, PartialEq, Eq, Serialize)]
pub enum DependencyKey {
    StateVar(ComponentName, StateVarSlice, InstructionName),
}

impl DependencyKey {
    fn component_name(&self) -> &str {
        match self {
            DependencyKey::StateVar(name, _, _) => name,
        }
    }
}


/// A collection of edges on the dependency tree
#[derive(Debug, Clone, PartialEq, Eq, Serialize)]
pub enum Dependency {
    Essential {
        component_name: ComponentName,
        origin: EssentialDataOrigin,
    },

    // outer product of the members of the group and states in the slice
    StateVar {
        component_group: ComponentGroup,
        state_var_slice: StateVarSlice,
    },
    StateVarArrayCorrespondingElement {
        component_group: ComponentGroup,
        array_state_var_name: StateVarName,
    },

    StateVarArrayDynamicElement {
        component_name: ComponentName,
        array_state_var_name: StateVarName,
        index_state_var: StateRef, // presumably an integer from the component that carries this dependency
    },
}


#[derive(Debug, Serialize)]
pub enum GroupDependency {
    Group(ComponentName),
    Component(ComponentName),
    StateVar(ComponentRef, StateVarSlice),
}


// === POTENTIAL CODE FOR MAPS ===
// #[derive(PartialEq, Serialize, Eq, Clone, Debug, Hash)]
// struct Instance<T> {
//     original: T,
//     path: Vec<(ComponentName, usize)>,
// }
// #[derive(PartialEq, Serialize, Eq, Clone, Debug, Hash)]
// struct Multi<T> {
//     original: T,
//     path: Vec<(ComponentName, MapIndex)>,
// }
// #[derive(PartialEq, Serialize, Eq, Clone, Debug, Hash)]
// enum MapIndex {
//     All,
//     Single(usize),
// }



/// Essential data can be generated by
/// - a state variable requesting it
/// - a string child, converted into essential data
///   so that it can change when requested
/// - a string in an attribute
#[derive(Serialize, Debug, Clone, Eq, Hash, PartialEq)]
pub enum EssentialDataOrigin {
    StateVar(StateVarName),
    ComponentChild(usize),
    // AttributeString(usize),
}



pub fn create_doenet_core(
    program: &str,
    existing_essential_data: Option<HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>>,
) -> Result<(DoenetCore, Vec<DoenetMLWarning>), DoenetMLError> {

    // Create component nodes and attributes
    let (ml_components, component_attributes, root_component_name) =
        parse_json::create_components_tree_from_json(program)?;

    let mut doenet_ml_warnings = vec![];

    // Convert to MLComponents into component nodes

    let mut component_nodes: HashMap<ComponentName, ComponentNode> = HashMap::new();
    for (name, c) in ml_components.iter() {

        let copy_source: Option<CopySource> =
            if let Some(ref source_comp_name) = c.copy_source {

                let source_comp = ml_components
                    .get(source_comp_name)
                    .ok_or(DoenetMLError::ComponentDoesNotExist {
                        comp_name: source_comp_name.clone()
                    })?;

                let first_string = c.component_index.iter().find_map(|source| {
                    if let ObjectName::String(string_source) = source {
                        Some(string_source)
                    } else {
                        None
                    }
                });

                let (comp_ref, source_def);
                if c.component_index.len() == 1 && first_string.is_some() {
                    // static index
                    let string_value = first_string.unwrap().parse().unwrap_or(0.0);
                    let index: usize = convert_float_to_usize(string_value)
                        .unwrap_or(0);

                    if index <= 0 {
                        doenet_ml_warnings.push(DoenetMLWarning::PropIndexIsNotPositiveInteger {
                            comp_name: c.name.clone(),
                            invalid_index: string_value.to_string()
                        });
                    }

                    let group_def = source_comp.definition.group.unwrap();

                    comp_ref = ComponentRef::GroupMember(source_comp_name.clone(), index);
                    let source_type = (group_def.component_type)(&source_comp.static_attributes);
                    source_def = *COMPONENT_DEFINITIONS.get(source_type).unwrap();
                } else if c.component_index.len() > 0 {
                    // dynamic index
                    panic!("dynamic component index")
                    // let group_def = source_comp.definition.group.unwrap();
                    // source_type = (group_def.component_type)(&source_comp.static_attributes);
                    // source_def = *COMPONENT_DEFINITIONS.get(source_type).unwrap();
                } else {
                    // no index
                    comp_ref = ComponentRef::Basic(source_comp_name.clone());
                    source_def = source_comp.definition;
                }

                if let Some(ref copy_prop) = c.copy_prop {
                    if let Some(state_ref) = source_def.array_aliases.get(copy_prop.as_str()) {
                        Some(CopySource::StateVar(comp_ref, state_ref.clone()))
                    } else {

                        let source_sv_name: StateVarName = source_def
                            .state_var_definitions
                            .get_key_value_ignore_case(copy_prop.as_str())
                            .ok_or(DoenetMLError::StateVarDoesNotExist {
                                comp_name: source_comp.name.clone(),
                                sv_name: copy_prop.clone(),
                            })?
                            .0;

                        let source_sv_def = source_def
                            .state_var_definitions
                            .get(source_sv_name)
                            .unwrap();

                        let first_string = c.prop_index.iter().find_map(|source| {
                            if let ObjectName::String(string_source) = source {
                                Some(string_source)
                            } else {
                                None
                            }
                        });

                        if c.prop_index.len() == 1 && first_string.is_some() {
                            // static index
                            let string_value = first_string.unwrap().parse().unwrap_or(0.0);
                            let index: usize = convert_float_to_usize(string_value)
                                .unwrap_or(0);

                            if index <= 0 {
                                doenet_ml_warnings.push(DoenetMLWarning::PropIndexIsNotPositiveInteger {
                                    comp_name: c.name.clone(),
                                    invalid_index: string_value.to_string()
                                });
                            }

                            if !source_sv_def.is_array() {
                                return Err(DoenetMLError::CannotCopyIndexForStateVar {
                                    source_comp_name: comp_ref.name(),
                                    source_sv_name,
                                });
                            }

                            Some(CopySource::StateVar(comp_ref, StateRef::ArrayElement(source_sv_name, index)))
                        } else if c.prop_index.len() > 0 {
                            // dynamic index
                            let variable_components = c.prop_index.iter().filter_map(|obj| {
                                if let ObjectName::Component(comp_name) = obj {
                                    Some(comp_name.clone())
                                } else {
                                    None
                                }
                            }).collect();

                            Some(CopySource::DynamicElement(
                                comp_ref.name(),
                                source_sv_name,
                                MathExpression::new(&c.prop_index),
                                variable_components,
                            ))
                        } else {
                            // no index
                            if source_sv_def.is_array() {
                                return Err(DoenetMLError::CannotCopyArrayStateVar {
                                    source_comp_name: comp_ref.name(),
                                    source_sv_name,
                                });
                            }
                            Some(CopySource::StateVar(comp_ref, StateRef::Basic(source_sv_name)))
                        }
                    }
                } else {

                    if !std::ptr::eq(c.definition, source_def) {
                        return Err(DoenetMLError::ComponentCannotCopyOtherType {
                            component_name: c.name.clone(),
                            component_type: c.definition.component_type,
                            source_type: &source_def.component_type,
                        });
                    }

                    Some(CopySource::Component(comp_ref))
                }
            } else {
                None
            };

        let component_node = ComponentNode {
            name: name.clone(),
            parent: c.parent.clone(),
            children: c.children.clone(),
            copy_source,
            static_attributes: c.static_attributes.clone(),
            definition: c.definition,
        };

        component_nodes.insert(name.clone(), component_node);
    }

    // Check for invalid children component profiles and throw warnings
    for (_, component) in component_nodes.iter() {
        if let ValidChildTypes::ValidProfiles(ref valid_profiles) = component.definition.valid_children_profiles {

            for child in component.children.iter().filter_map(|child| child.as_component()) {
                let child_comp = component_nodes.get(child).unwrap();
                let mut has_valid_profile = false;
                let child_member_def = definition_of_members(child_comp.definition, &child_comp.static_attributes);
                for (child_profile, _) in child_member_def.component_profiles.iter() {
                    if valid_profiles.contains(child_profile) {
                        has_valid_profile = true;
                        break;
                    }
                }

                if has_valid_profile == false {
                    doenet_ml_warnings.push(DoenetMLWarning::InvalidChildType {
                        parent_comp_name: component.name.clone(),
                        child_comp_name: child_comp.name.clone(),
                        child_comp_type: child_comp.definition.component_type,
                    });
                }
            }
    
        }
    }

    // All the components that copy another component, along with the name of the component they copy
    let copy_comp_targets: Vec<(&ComponentNode, &ComponentRef)> = component_nodes.iter().filter_map(|(_, c)|
        match c.copy_source {
            Some(CopySource::Component(ref source)) => Some((c, source)),
            _ => None,
        }
    ).collect();

    // Check for cyclical dependencies due to CopySource::Component.
    // Otherwise alias and dependency generation could crash.
    for (copy_component, _) in copy_comp_targets.iter() {
        if let Some(cyclic_error) = check_cyclic_copy_source_component(&component_nodes, copy_component) {
            return Err(cyclic_error);
        }
    }

    // Check invalid component names for attributes
    for attributes_for_comp in component_attributes.values() {
        for attributes in attributes_for_comp.values() {
            for attribute_list in attributes.values() {
                for attr_object in attribute_list {

                    if let ObjectName::Component(comp_obj) = attr_object {
                        if !component_nodes.contains_key(comp_obj) {
                            // The component tried to copy a non-existent component.
                            return Err(DoenetMLError::ComponentDoesNotExist {
                                comp_name: comp_obj.to_owned()
                            });
                        }
                    }
                }
            }
        }
    }

    let mut all_state_var_defs: Vec<(&ComponentName, StateVarName, &StateVarVariant)> = Vec::new();
    for (_, comp) in component_nodes.iter() {
        for (sv_name, sv_def) in comp.definition.state_var_definitions {
            all_state_var_defs.push((&comp.name, sv_name, sv_def));
        }
    }

    // let all_state_var_defs = component_nodes.iter()
    //     .flat_map(|(comp_name, comp)| comp.definition.state_var_definitions.iter()
    //         .map(|(sv_name, sv_def)| (comp_name, sv_name, sv_def))
    //     );

    let mut element_specific_dependencies: HashMap<(ComponentRef, StateVarName), Vec<usize>> = HashMap::new();

    for (comp_name, sv_name, sv_def) in all_state_var_defs {
        if sv_def.is_array() {
            let comp = component_nodes.get(comp_name).unwrap();

            let possible_attributes = if let Some(my_own_comp_attrs) = component_attributes.get(comp_name) {
                Some(my_own_comp_attrs)
            } else if let Some(CopySource::Component(_)) = comp.copy_source {
                let final_source = get_recursive_copy_source_component_if_exists(&component_nodes, comp);
                component_attributes.get(final_source)
            } else {
                None
            };

            if let Some(attribute_for_comp) = possible_attributes {

                if let Some(attribute_for_sv) = attribute_for_comp.get(sv_name) {
                    let element_dep_flags: Vec<usize> = attribute_for_sv.iter().map(|(id, _)| *id).collect();
                    element_specific_dependencies.insert(
                        (ComponentRef::Basic(comp_name.to_string()), sv_name),
                        element_dep_flags
                    );
                }
            }
    
        }        
    }
    

    // Fill in group dependencies

    let mut group_dependencies = HashMap::new();
    for (component_name, component) in component_nodes.iter() {
        if let Some(group_def) = component.definition.group {

            let deps = (group_def.group_dependencies)(
                &component,
                &component_nodes,
            );

            group_dependencies.insert(component_name.clone(), deps);
        }
    }

    // Fill in component_states and dependencies HashMaps for every component
    // and supply any essential_data required by dependencies.

    let should_initialize_essential_data = existing_essential_data.is_none();
    let mut essential_data = existing_essential_data.unwrap_or(HashMap::new());

    let mut component_states = HashMap::new();
    let mut dependencies = HashMap::new();

    for (component_name, component_node) in component_nodes.iter() {

        let dependencies_for_this_component = create_all_dependencies_for_component(
            &component_nodes,
            component_node,
            component_attributes.get(component_name).unwrap_or(&HashMap::new()),
            // copy_index_flags.get(component_name).as_deref(),
            &mut essential_data,
            should_initialize_essential_data,
            &element_specific_dependencies,
        );

        let state_for_this_component: HashMap<StateVarName, StateForStateVar> =
            component_node.definition.state_var_definitions
            .iter()
            .map(|(&sv_name, sv_variant)| (sv_name, StateForStateVar::new(&sv_variant)))
            .collect();

        dependencies.extend(dependencies_for_this_component);

        component_states.insert(
            component_name.clone(),
            state_for_this_component,
        );
    }


    // Now that the dependency graph has been created, use it to check for cyclical dependencies
    // for all the components
    for (dep_key, _) in dependencies.iter() {
        let DependencyKey::StateVar(comp, sv_ref, _) = dep_key;
        let mut chain = vec![(comp.clone(), sv_ref.clone())];
        let possible_error = check_for_cyclical_dependencies(&dependencies, &mut chain);

        if let Some(error) = possible_error {
            return Err(error);
        }
    }


    log_json!("Components upon core creation",
        utils::json_components(&component_nodes, &component_states));

    log_json!("Dependencies upon core creation",
        utils::json_dependencies(&dependencies));

    log_json!("Essential data upon core creation",
        utils::json_essential_data(&essential_data));

    log_json!("Group dependencies upon core creation",
        &group_dependencies);

    // log_debug!("DoenetCore creation warnings, {:?}", doenet_ml_warnings);

    Ok((DoenetCore {
        component_nodes,
        component_states,
        root_component_name,
        dependencies,
        group_dependencies,
        essential_data,
    }, doenet_ml_warnings))
}


fn check_cyclic_copy_source_component(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,

) -> Option<DoenetMLError> {

    let mut current_comp = component;
    let mut chain = vec![];
    while let Some(CopySource::Component(ref source)) = current_comp.copy_source {

        if chain.contains(&current_comp.name) {
            // Cyclical dependency
            chain.push(current_comp.name.clone());

            let start_index = chain.iter().enumerate().find_map(|(index, name)| {
                if name == &current_comp.name {
                    Some(index)
                } else {
                    None
                }
            }).unwrap();

            let (_, relevant_chain) = chain.split_at(start_index);

            return Some(DoenetMLError::CyclicalDependency {
                component_chain: Vec::from(relevant_chain)
            });


        } else {

            chain.push(current_comp.name.clone());
            current_comp = components.get(&source.name()).unwrap();
        }
    }

    None
}


/// Check for cyclical dependencies, assuming that we have already traversed through the
/// given dependency chain. This function might become slow for larger documents with lots of copies
fn check_for_cyclical_dependencies(
    dependencies: &HashMap<DependencyKey, Vec<Dependency>>,
    dependency_chain: &mut Vec<(ComponentName, StateVarSlice)>,
) -> Option<DoenetMLError> {

    // log_debug!("Dependency chain {:?}", dependency_chain);
    let last_link = dependency_chain.last().unwrap().clone();

    let my_dependencies = dependencies.iter().filter(|(dep_key, _)| {
        let DependencyKey::StateVar(comp, sv_slice, _) = dep_key;
        if comp == &last_link.0 && sv_slice == &last_link.1 {
            true
        } else {
            false
        }
    });

    for (_, dep_list) in my_dependencies {
        for dep in dep_list {
            let new_link = match dep {
                Dependency::StateVar { component_group: component_ref, state_var_slice } => {
                    Some((component_ref.name().clone(), state_var_slice.clone()))
                },
                _ => None,
            };

            if let Some(new_link) = new_link {
                if dependency_chain.contains(&new_link) {
                    // Cyclical dependency!!

                    dependency_chain.push(new_link.clone());
                    log_debug!("Cyclical dependency through {:?} with duplicate {:?}", dependency_chain, new_link);

                    let start_index = dependency_chain.iter().enumerate().find_map(|(index, item)| {
                        if item == &new_link {
                            Some(index)
                        } else {
                            None
                        }
                    }).unwrap();

                    let (_, relevant_chain) = dependency_chain.split_at(start_index);
                    let mut component_chain = vec![];
                    for link in relevant_chain.into_iter() {
                        if component_chain.is_empty() || component_chain.last().unwrap() != &link.0 {
                            component_chain.push(link.0.clone());
                        }
                    }

                    return Some(DoenetMLError::CyclicalDependency {
                        component_chain
                    });

                } else {
                    dependency_chain.push(new_link);
                    let possible_error = check_for_cyclical_dependencies(dependencies, dependency_chain);
                    dependency_chain.pop();

                    if let Some(error) = possible_error {
                        return Some(error);
                    }
                }
            }
        }
    }

    None
}


fn create_all_dependencies_for_component(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
    component_attributes: &HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>,
    // copy_index_flag: Option<&(ComponentName, StateVarName, Vec<ObjectName>)>,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
    should_initialize_essential_data: bool,
    element_specific_dependencies: &HashMap<(ComponentRef, StateVarName), Vec<usize>>,
) -> HashMap<DependencyKey, Vec<Dependency>> {

    // log_debug!("Creating dependencies for {}", component.name);
    let mut dependencies: HashMap<DependencyKey, Vec<Dependency>> = HashMap::new();

    let my_definitions = component.definition.state_var_definitions;
    let mut unshadowing_definitions: HashMap<&StateVarName, &StateVarVariant>;
    unshadowing_definitions = my_definitions.iter().collect();

    if let Some(CopySource::DynamicElement(_, _, ref expression, ref variable_components)) = component.copy_source {
        // We can't immediately figure out the index, so we need to use the state
        // var propIndex

        dependencies.extend(
            create_prop_index_dependencies(component, expression, variable_components, essential_data)
        );

    }

    unshadowing_definitions.remove(&PROP_INDEX_SV);

    // log_debug!("Unshadowing definitions for {} {:?}", component.name, unshadowing_definitions);

    for (&state_var_name, state_var_variant) in unshadowing_definitions {

        if state_var_variant.is_array() {

            let size_dep_instructions = state_var_variant
                .return_size_dependency_instructions(HashMap::new());

            for (instruct_name, ref dep_instruction) in size_dep_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components,
                    component,
                    component_attributes,
                    &StateVarSlice::Single(StateRef::SizeOf(state_var_name)),
                    dep_instruction,
                    instruct_name,
                    essential_data,
                    should_initialize_essential_data,
                );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Single(StateRef::SizeOf(state_var_name)),
                        instruct_name
                    ),
                    instruct_dependencies,
                );

            }

            let array_dep_instructions = state_var_variant
                .return_array_dependency_instructions(HashMap::new());

            for (instruct_name, ref dep_instruction) in array_dep_instructions.into_iter() {
                let instruct_dependencies =
                    create_dependencies_from_instruction(
                        &components,
                        component,
                        component_attributes,
                        &StateVarSlice::Array(state_var_name),
                        dep_instruction,
                        instruct_name,
                        essential_data,
                        should_initialize_essential_data
                    );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Array(state_var_name),
                        instruct_name,
                    ),
                    instruct_dependencies,
                );
            }

            // make dependencies for elements when size has an essential value
            // let elements = {
                // let source_comp_name = get_essential_data_component_including_copy(components, component);

                // let size = essential_data
                //     .get(source_comp_name)
                //     .and_then(|c| c
                //         .get(&EssentialDataOrigin::StateVar(state_var_name))
                //         .and_then(|s| s
                //             .get_value(StateIndex::SizeOf)
                //             .and_then(|v|
                //                 usize::try_from(v).ok()
                //             )
                //         )
                //     ).unwrap_or(0);

                // indices_for_size(size)
            // };
            let empty = &Vec::new();

            let elements = element_specific_dependencies.get(&(ComponentRef::Basic(component.name.clone()), state_var_name)).unwrap_or(empty);

            log_debug!("Will make dependencies for elements {:?} of {}:{}", elements, component.name, state_var_name);

            for &index in elements {

                let element_dep_instructions = state_var_variant
                    .return_element_dependency_instructions(index, HashMap::new());

                for (instruct_name, ref dep_instruction) in element_dep_instructions.into_iter() {
                    let instruct_dependencies =
                        create_dependencies_from_instruction(
                            &components,
                            component,
                            component_attributes,
                            &StateVarSlice::Single(StateRef::ArrayElement(state_var_name, index)),
                            dep_instruction,
                            instruct_name,
                            essential_data,
                            should_initialize_essential_data
                        );

                    dependencies.insert(
                        DependencyKey::StateVar(
                            component.name.clone(),
                            StateVarSlice::Single(StateRef::ArrayElement(state_var_name, index)),
                            instruct_name,
                        ),
                        instruct_dependencies,
                    );
                }
            }


        } else {

            let dependency_instructions = return_dependency_instructions_for_state_ref(component, &StateRef::Basic(state_var_name));

            for (instruct_name, ref dep_instruction) in dependency_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components,
                    component,
                    component_attributes,
                    &StateVarSlice::Single(StateRef::Basic(state_var_name)),
                    dep_instruction,
                    instruct_name,
                    essential_data,
                    should_initialize_essential_data
                );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Single(StateRef::Basic(state_var_name)),
                        instruct_name,
                    ),
                    instruct_dependencies   
                );
            }

        }
    }

    dependencies

}


/// This function also creates essential data when a DependencyInstruction asks for it.
/// The second return is element specific dependencies.
fn create_dependencies_from_instruction(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
    component_attributes: &HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>,
    state_var_slice: &StateVarSlice,
    instruction: &DependencyInstruction,
    instruction_name: InstructionName,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
    should_initialize_essential_data: bool,
) -> Vec<Dependency> {

    log_debug!("Creating dependency {}:{}:{} from instruction {:?}", component.name, state_var_slice, instruction_name, instruction);

    let mut dependencies: Vec<Dependency> = Vec::new();

    match &instruction {

        DependencyInstruction::Essential { prefill } => {

            let source_comp_name = get_recursive_copy_source_component_if_exists(components, component);
            let essential_origin = EssentialDataOrigin::StateVar(state_var_slice.name());

            if should_initialize_essential_data && source_comp_name == &component.name {
                // Components only create their own essential data

                let sv_def = component.definition.state_var_definitions.get(state_var_slice.name()).unwrap();

                let initial_data: StateVarValue = prefill
                    .and_then(|string| component_attributes
                        .get(string)
                        .and_then(|attr| {
                            let attr_str = attr
                                .get(&1).unwrap()
                                .first().unwrap()
                                .as_string().unwrap_or(&String::new())
                                .clone();
                            package_string_as_state_var_value(attr_str, sv_def).ok()
                        }))
                    .unwrap_or(sv_def.initial_essential_value());

                let initial_data = if sv_def.is_array() {
                    InitialEssentialData::Array(Vec::new(), initial_data)
                } else {
                    InitialEssentialData::Single(initial_data)
                };
    
                create_essential_data_for(
                    &source_comp_name,
                    essential_origin.clone(),
                    initial_data,
                    essential_data
                );

            }

            dependencies.push(Dependency::Essential {
                component_name: source_comp_name.clone(),
                origin: essential_origin,
            });

        },

        DependencyInstruction::StateVar { component_ref, state_var } => {

            let component_ref = match component_ref {
                Some(name) => name.clone(),
                None => ComponentRef::Basic(component.name.clone()),
            };

            dependencies.push(
                Dependency::StateVar {
                    component_group: ComponentGroup::Single(component_ref),
                    state_var_slice: state_var.clone(),
                }
            );

        },

        DependencyInstruction::CorrespondingElements { component_ref, array_state_var_name } => {

            let component_ref = match component_ref {
                Some(name) => name.clone(),
                None => ComponentRef::Basic(component.name.clone()),
            };

            dependencies.push(
                Dependency::StateVarArrayCorrespondingElement {
                    component_group: ComponentGroup::Single(component_ref),
                    array_state_var_name,
                }
            );

        },

        DependencyInstruction::Child { desired_profiles, parse_into_expression } => {

            enum RelevantChild<'a> {
                StateVar(Dependency),
                String(&'a String, &'a ComponentName), // value, parent name
            }

            let mut relevant_children: Vec<RelevantChild> = Vec::new();
            
            let source_copy_root_name = get_recursive_copy_source_component_if_exists(components, component);
            let source = components.get(source_copy_root_name).unwrap();
            
            if let Some(CopySource::StateVar(ref source_comp_ref, ref source_sv_ref)) = source.copy_source {
                relevant_children.push(
                    RelevantChild::StateVar(Dependency::StateVar {
                        component_group: ComponentGroup::Single(source_comp_ref.clone()),
                        state_var_slice: StateVarSlice::Single(source_sv_ref.clone())
                    })
                );
            } else if let Some(CopySource::DynamicElement(ref source_comp, source_sv, _, _)) = source.copy_source {
                relevant_children.push(
                    RelevantChild::StateVar(Dependency::StateVarArrayDynamicElement {
                        component_name: source_comp.clone(),
                        array_state_var_name: source_sv,
                        index_state_var: StateRef::Basic(PROP_INDEX_SV),
                    })
                );
            }


            let children = get_children_including_copy(components, component);

            for child in children.iter() {

                match child {
                    (ComponentChild::Component(child_name), _) => {

                        let child_node = components.get(child_name).unwrap();

                        let child_group = match child_node.definition.group {
                            Some(_) => ComponentGroup::Group(child_name.clone()),
                            None => ComponentGroup::Single(ComponentRef::Basic(child_name.clone())),
                        };
                        let child_def = group_member_definition(
                            components,
                            &child_group
                        );

                        for child_profile in child_def.component_profiles.iter() {
                            if desired_profiles.contains(&child_profile.0) {

                                let profile_state_var = child_profile.1;

                                let sv_def = child_def
                                    .state_var_definitions
                                    .get(&profile_state_var)
                                    .unwrap();

                                let profile_sv_slice = if sv_def.is_array() {
                                    StateVarSlice::Array(profile_state_var)
                                } else {
                                    StateVarSlice::Single(StateRef::Basic(profile_state_var))
                                };

                                relevant_children.push(
                                    RelevantChild::StateVar(Dependency::StateVar {
                                        component_group: child_group,
                                        state_var_slice: profile_sv_slice,
                                    })
                                );
                                break;
                            }
                        }
                    },
                    (ComponentChild::String(string_value), actual_parent) => {
                        if desired_profiles.contains(&ComponentProfile::Text)
                            || desired_profiles.contains(&ComponentProfile::Number) {
                            relevant_children.push(
                                RelevantChild::String(string_value, &actual_parent.name)
                            );
                        }
                    },
                }
            }


            if *parse_into_expression {

                // Assuming for now that expression is math expression
                let expression = MathExpression::new(
                    &relevant_children.iter().map(|child| match child {
                        // The component name doesn't matter, the expression just needs to know there is
                        // an external variable at that location
                        RelevantChild::StateVar(_) => ObjectName::Component(String::new()),
                        RelevantChild::String(string_value, _) => ObjectName::String(string_value.to_string()),
                    }).collect()
                );

                // Assuming that no other child instruction exists which has already filled
                // up the child essential data
                let essential_origin = EssentialDataOrigin::ComponentChild(0);

                if should_initialize_essential_data {
                    create_essential_data_for(
                        &component.name,
                        essential_origin.clone(),
                        InitialEssentialData::Single(
                            StateVarValue::MathExpr(expression),
                        ),
                        essential_data
                    );    
                }

                dependencies.push(Dependency::Essential {
                    component_name: component.name.clone(), origin: essential_origin,
                });

                // We already dealt with the essential data, so now only retain the component children
                relevant_children.retain(|child| matches!(child, RelevantChild::StateVar(_)));
                
            }

            // Stores how many string children added per parent.
            let mut essential_data_numbering: HashMap<ComponentName, usize> = HashMap::new();

            for relevant_child in relevant_children {

                match relevant_child {

                    RelevantChild::StateVar(child_dep) => {
                        dependencies.push(child_dep);
                    },

                    RelevantChild::String(string_value, actual_parent) => {
                        let index = essential_data_numbering
                            .entry(actual_parent.clone()).or_insert(0 as usize);

                        let essential_origin = EssentialDataOrigin::ComponentChild(*index);

                        if should_initialize_essential_data && &component.name == actual_parent {
                            // Components create their own essential data

                            let value = StateVarValue::String(string_value.clone());
                            create_essential_data_for(
                                actual_parent,
                                essential_origin.clone(),
                                InitialEssentialData::Single(value),
                                essential_data
                            );
                        }

                        dependencies.push(Dependency::Essential {
                            component_name: actual_parent.clone(),
                            origin: essential_origin,
                        });

                        *index += 1;

                    },

                }
            }
            

        },
        DependencyInstruction::Parent { state_var } => {

            let desired_state_var = state_var;

            let parent_name = component.parent.clone().expect(&format!(
                "Component {} doesn't have a parent, but the dependency instruction {}:{} asks for one.",
                    component.name, state_var_slice, instruction_name
            ));

            let parent_component = components.get(&parent_name).unwrap();

            // Look up what kind of child state var it is
            // If the state var is an array, depend on the array, otherwise as normal

            let sv_def = parent_component.definition.state_var_definitions.get(desired_state_var).unwrap();

            dependencies.push(Dependency::StateVar {
                component_group: ComponentGroup::Single(ComponentRef::Basic(parent_name.to_string())),
                state_var_slice: if sv_def.is_array() {
                    StateVarSlice::Array(desired_state_var)
                } else {
                    StateVarSlice::Single(StateRef::Basic(desired_state_var))
                }
            });

        },


        DependencyInstruction::Attribute { attribute_name, index } => {

            log_debug!("Getting attribute {} for {}:{}", attribute_name, component.name, state_var_slice);
            let state_var_name = state_var_slice.name();
            let state_var_ref = StateRef::from_name_and_index(state_var_name, *index);
            let sv_def = component.definition.state_var_definitions.get(state_var_name).unwrap();
            let essential_origin = EssentialDataOrigin::StateVar(state_var_name);


            let default_value = if matches!(sv_def, 
                StateVarVariant::NumberArray(_) | StateVarVariant::Number(_) | StateVarVariant::Integer(_)
            ) {
                StateVarValue::MathExpr(MathExpression::new(
                    &vec![ObjectName::String(match sv_def.initial_essential_value() {
                        StateVarValue::Number(v) => v.to_string(),
                        StateVarValue::Integer(v) => v.to_string(),
                        _ => unreachable!(),
                    })]
                ))
            } else {
                sv_def.initial_essential_value()
            };


            let get_value_from_object_list = |obj_list: &Vec<ObjectName>| -> StateVarValue {

                if matches!(sv_def, StateVarVariant::Number(_)
                    | StateVarVariant::NumberArray(_)
                    | StateVarVariant::Integer(_)
                ) {
                    StateVarValue::MathExpr(
                        MathExpression::new(obj_list)
                    )
                } else if obj_list.len() > 0 {

                    let first_obj = obj_list.get(0).unwrap();
                    if obj_list.len() > 1 {
                        unimplemented!("Multiple objects for non number state var");
                    }
                    match first_obj {
                        ObjectName::String(str_val) => {
                            package_string_as_state_var_value(str_val.to_string(), sv_def).unwrap()
                        }
                        _ => default_value.clone()
                    }
                } else {
                    default_value.clone()
                }
            };

            if let Some(attribute) = component_attributes.get(*attribute_name) {
                // attribute specified
                log_debug!("attribute {:?}", attribute);

                // Create the essential data if it does not exist yet
                if should_initialize_essential_data && !essential_data_exists_for(&component.name, &essential_origin, essential_data) {

                    if sv_def.is_array() {

                        let mut essential_attr_objs: Vec<StateVarValue> = Vec::new();
                        
                        for (id, obj_list) in attribute {

                            let value = get_value_from_object_list(obj_list);

                            if *id > essential_attr_objs.len() {
                                essential_attr_objs.resize(*id, default_value.clone());
                            }
                            essential_attr_objs[id - 1] = value;

                        }

                        log_debug!("essential attributes {:?}", essential_attr_objs);

                        let initial_essential_data = InitialEssentialData::Array(essential_attr_objs, default_value);

                        create_essential_data_for(
                            &component.name,
                            essential_origin.clone(),
                            initial_essential_data,
                            essential_data,
                        );

                    } else {

                        assert_eq!(attribute.keys().len(), 1);
                        let obj_list = attribute.get(&1).unwrap();

                        log_debug!("Initializing non-array essential data for {}:{} from attribute data {:?}", component.name, state_var_name, obj_list);

                        let value = get_value_from_object_list(obj_list);
                        
                        create_essential_data_for(
                            &component.name,
                            essential_origin.clone(),
                            InitialEssentialData::Single(value),
                            essential_data,
                        );
                    };
                }



                if let StateIndex::SizeOf = index {

                    dependencies.push(Dependency::Essential {
                        component_name: component.name.clone(),
                        origin: essential_origin,
                    });
                
                } else {

                    let attribute_index = match index {
                        StateIndex::Element(i) => *i,
                        _ => 1,
                    };

                    let attr_objects = attribute.get(&attribute_index)
                        .expect(&format!("attribute {}:{} does not have index {}. Attribute: {:?}",
                            &component.name, attribute_name, &attribute_index, attribute));

                    let relevant_attr_objects = if matches!(sv_def,
                        StateVarVariant::Number(_) | StateVarVariant::NumberArray(_) | StateVarVariant::Integer(_)
                    ) {
                        // First add an essential dependency to the expression
                        dependencies.push(Dependency::Essential {
                            component_name: component.name.clone(),
                            origin: essential_origin.clone(),
                        });

                        attr_objects.into_iter().filter_map(
                            |obj| if matches!(obj, ObjectName::Component(_)) {
                                Some(obj.clone())
                            } else {
                                None
                            }
                        ).collect()
                    } else {
                        attr_objects.clone()
                    };

                    for attr_object in relevant_attr_objects {

                        let dependency = match attr_object {
                            ObjectName::String(_) => Dependency::Essential {
                                component_name: component.name.clone(),
                                origin: essential_origin.clone(),
                            },
                            ObjectName::Component(comp_name) => {
                                let comp = components.get(&comp_name).unwrap();
                                let primary_input_sv = comp.definition.primary_input_state_var.expect(
                                    &format!("An attribute cannot depend on a non-primitive component. Try adding '.value' to the macro.")
                                );
    
                                Dependency::StateVar {
                                    component_group: ComponentGroup::Single(ComponentRef::Basic(comp_name.clone())),
                                    state_var_slice: StateVarSlice::Single(StateRef::Basic(primary_input_sv)),
                                }
                            },
                        };

                        dependencies.push(dependency);
                    }
                    
                }
            } else if let Some(CopySource::Component(c)) = &component.copy_source {

                // inherit attribute from copy source
                dependencies.push(Dependency::StateVar {
                    component_group: ComponentGroup::Single(ComponentRef::Basic(c.name())),
                    state_var_slice: StateVarSlice::Single(state_var_ref),
                });
            } else {

                // let value = get_value_from_object_list(&vec![]);

                if should_initialize_essential_data {
                    create_essential_data_for(
                        &component.name,
                        EssentialDataOrigin::StateVar(state_var_name),
                        InitialEssentialData::Single(default_value),
                        essential_data
                    );    
                }

                dependencies.push(Dependency::Essential {
                    component_name: component.name.clone(),
                    origin: essential_origin,
                });

            }
        },

    }
    dependencies
}



fn create_prop_index_dependencies(
    component: &ComponentNode,
    math_expression: &MathExpression,
    variable_components: &Vec<ComponentName>,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
)
-> HashMap<DependencyKey, Vec<Dependency>> {
    use base_definitions::*;

    let mut dependencies = HashMap::new();

    // Dependencies on source components for propIndex
    dependencies.insert(
        DependencyKey::StateVar(
            component.name.clone(),
            StateVarSlice::Single(StateRef::Basic(PROP_INDEX_SV)),
            PROP_INDEX_VARS_INSTRUCTION
        ),
        variable_components.iter().map(|comp_name| {
            Dependency::StateVar {
                component_group: ComponentGroup::Single(ComponentRef::Basic(comp_name.to_string())),
                state_var_slice: StateVarSlice::Single(StateRef::Basic("value")),
            }
        }).collect()
    );

    let origin = EssentialDataOrigin::StateVar(PROP_INDEX_SV);

    create_essential_data_for(
        &component.name,
        origin.clone(),
        InitialEssentialData::Single(StateVarValue::MathExpr(math_expression.clone())),
        essential_data,
    );

    // Dependency on math expression for propIndex
    dependencies.insert(
        DependencyKey::StateVar(
            component.name.clone(),
            StateVarSlice::Single(StateRef::Basic(PROP_INDEX_SV)),
            PROP_INDEX_EXPR_INSTRUCTION
        ),
        vec![Dependency::Essential {
            component_name: component.name.clone(),
            origin,
        }]
    );

    dependencies
}


fn package_string_as_state_var_value(input_string: String, state_var_variant: &StateVarVariant) -> Result<StateVarValue, String> {

    match state_var_variant {
        StateVarVariant::StringArray(_) |
        StateVarVariant::String(_) => {
            Ok(StateVarValue::String(input_string))
        },

        StateVarVariant::Boolean(_) => {

            if input_string == "true" {
                Ok(StateVarValue::Boolean(true))
            } else if input_string == "false" {
                Ok(StateVarValue::Boolean(false))
            } else {
                Err(format!("Cannot evaluate string '{}' as boolean", input_string))
            }
        },

        StateVarVariant::Integer(_) => {
            if let Ok(val) = evalexpr::eval_int(&input_string) {
                Ok(StateVarValue::Integer(val))
            } else {
                Err(format!("Cannot package string '{}' as integer", input_string))
        }
        },

        StateVarVariant::NumberArray(_) |
        StateVarVariant::Number(_) => {
            if let Ok(val) = evalexpr::eval_number(&input_string) {
                Ok(StateVarValue::Number(val))
            } else {
                Err(format!("Cannot package string '{}' as number", input_string))
            }
        },
    }
}


enum InitialEssentialData {
    Single(StateVarValue),
    Array(Vec<StateVarValue>, StateVarValue),
}

/// Add (or update) essential data for a state variable or string child.
/// Returns the dependency.
fn create_essential_data_for(
    component_name: &ComponentName,
    origin: EssentialDataOrigin,
    initial_values: InitialEssentialData,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
) {

    if let Some(comp_essential_data) = essential_data.get(component_name) {
        assert!( !comp_essential_data.contains_key(&origin) );
    }

    let essential_state = match initial_values {
        InitialEssentialData::Single(value) => EssentialStateVar::new_single_basic_with_state_var_value(value),
        InitialEssentialData::Array(values, default_fill_value) => EssentialStateVar::new_array_with_state_var_values(values, default_fill_value),
    };

    log_debug!("New essential data for {} {:?} {:?}", component_name, origin, essential_state);

    essential_data
        .entry(component_name.clone())
        .or_insert(HashMap::new())
        .entry(origin.clone())
        .or_insert(essential_state);
}

fn essential_data_exists_for(
    component_name: &ComponentName,
    origin: &EssentialDataOrigin,
    essential_data: &HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>
) -> bool {

    if let Some(comp_essen) = essential_data.get(component_name) {
        if let Some(_) = comp_essen.get(origin) {
            true
        } else {
            false
        }
    } else {
        false
    }
}


/// Calculate all the (normal) state vars that depend on the given state var
fn get_state_variables_depending_on_me(
    core: &DoenetCore,
    sv_component: &ComponentName,
    sv_reference: &StateRef,
) -> Vec<(ComponentName, StateVarSlice)> {

    let mut depending_on_me = vec![];

    for (dependency_key, dependencies) in core.dependencies.iter() {

        for dependency in dependencies {

            match dependency {
                Dependency::StateVar { component_group, state_var_slice } => {
                    if sv_component == &component_group.name() 
                    && state_var_slice.name() == sv_reference.name() {

                        let DependencyKey::StateVar(dependent_comp, dependent_slice, _) = dependency_key;
                        depending_on_me.push((dependent_comp.clone(), dependent_slice.clone()));
                    }
                },

                Dependency::StateVarArrayCorrespondingElement { component_group, array_state_var_name } => {
                    if sv_component == &component_group.name() 
                    && *array_state_var_name == sv_reference.name() {

                        let DependencyKey::StateVar(dependent_comp, dependent_slice, _) = dependency_key;
                        let dependent_ref = match dependent_slice {
                            StateVarSlice::Array(array_name) => StateRef::from_name_and_index(array_name, sv_reference.index()),
                            StateVarSlice::Single(_) => panic!(),
                        };
                        depending_on_me.push((dependent_comp.clone(), StateVarSlice::Single(dependent_ref)));
                    }
                }

                Dependency::StateVarArrayDynamicElement {
                    component_name,
                    array_state_var_name,
                    ..
                } => {

                    let this_array_refers_to_me = 
                        component_name == sv_component
                        && *array_state_var_name == sv_reference.name();

                    let i_am_prop_index_of_this_dependency = 
                        // The key that this dependency is under is myself
                        // Aka, the index is supposed to be in my component, not another component
                        dependency_key.component_name() == sv_component
                        // I am actually a propIndex, and not some other state var
                        && sv_reference == &StateRef::Basic("propIndex");

                    if this_array_refers_to_me || i_am_prop_index_of_this_dependency {

                        let DependencyKey::StateVar(dependent_comp, dependent_slice, _) = dependency_key;
                        depending_on_me.push((dependent_comp.clone(), dependent_slice.clone()));
                    }
    

                }

                // Essential dependencies are endpoints
                Dependency::Essential { .. } => {},

            }
        }
    }

    // a state var can depend on this through a group member
    for comp_name in groups_depending_on_state_var(core, sv_component, sv_reference) {
        depending_on_me.extend(
            state_vars_depending_on_group(core, &comp_name)
        );
    }

    depending_on_me
}

fn groups_depending_on_state_var(
    core: &DoenetCore,
    sv_component: &ComponentName,
    sv_reference: &StateRef,
) -> Vec<ComponentName> {

    let mut depending_on_me = vec![];

    for (comp_name, group_deps) in core.group_dependencies.iter() {
        for group_dep in group_deps {
            let depends_on = match group_dep {
                GroupDependency::StateVar(comp, name) => {
                    &comp.name() == sv_component && name.name() == sv_reference.name()
                },
                GroupDependency::Component(comp_name) |
                GroupDependency::Group(comp_name) => {
                    comp_name == sv_component
                },
            };
            if depends_on {
                depending_on_me.extend(
                    groups_depending_on_group(core, comp_name)
                );
            }
        }
    }
    depending_on_me
}

fn groups_depending_on_group(
    core: &DoenetCore,
    group_name: &ComponentName,
) -> Vec<ComponentName> {

    let mut depending_on_me = vec![];

    for (comp_name, group_deps) in core.group_dependencies.iter() {
        for group_dep in group_deps {
            let depends_on = match group_dep {
                GroupDependency::Component(comp_name) |
                GroupDependency::Group(comp_name) => comp_name == group_name,
                _ => false,
            };
            if depends_on {
                depending_on_me.extend(
                    groups_depending_on_group(core, comp_name)
                );
            }
        }
    }
    depending_on_me
}

fn state_vars_depending_on_group(
    core: &DoenetCore,
    group_name: &ComponentName,
) -> Vec<(ComponentName, StateVarSlice)> {

    let mut depending_on_me = vec![];

    for (dependency_key, dependencies) in core.dependencies.iter() {
        for dependency in dependencies {

            match dependency {
                Dependency::StateVar { component_group, .. } => {
                    match component_group {
                        ComponentGroup::Single(c) => {
                            if c.name() == *group_name {
                                // depending on me directly
                                let DependencyKey::StateVar(dependent_comp, dependent_slice, _) = dependency_key;
                                depending_on_me.push((dependent_comp.clone(), dependent_slice.clone()));
                            }
                        }
                        ComponentGroup::Group(name) => {
                            if name == group_name {
                                // depending on me as a member of a group
                                let DependencyKey::StateVar(dependent_comp, dependent_slice, _) = dependency_key;
                                depending_on_me.push((dependent_comp.clone(), dependent_slice.clone()));
                            }
                        },
                    }
                },
                _ => ()
            };

        }
    }

    depending_on_me
}

// TODO: Use &Dependency instead of cloning
fn dependencies_of_state_var(
    dependencies: &HashMap<DependencyKey, Vec<Dependency>>,
    component_name: &ComponentName,
    state_ref: &StateRef,
) -> HashMap<InstructionName, Vec<Dependency>> {

    let deps = dependencies.iter().filter_map(| (key, deps) |

        match key {
            DependencyKey::StateVar(comp_name, sv_slice, instruct_name) => {

                // Check if the key is me
                if comp_name == component_name {
                    if sv_slice.as_single() == Some(state_ref) {
                        Some((*instruct_name, deps))

                    } else if let StateRef::ArrayElement(..) = state_ref {

                        // The key might also be an array who feeds into me
                        if let StateVarSlice::Array(array_name) = sv_slice {
                            if state_ref.name() == *array_name {
                                Some((*instruct_name, deps))
                            } else {
                                None
                            }
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                } else {
                    None
                }
            },
        }
    );

    // log_debug!("Deps for {}:{} with possible duplicates {:?}", component_name, state_var_slice, deps.clone().collect::<HashMap<InstructionName, &Vec<Dependency>>>());

    let mut combined: HashMap<InstructionName, Vec<Dependency>> = HashMap::new();
    for (k, v) in deps {
        if let Some(accum) = combined.get_mut(k) {
            let dedup: Vec<Dependency> = v.clone().into_iter().filter(|x| !accum.contains(x)).collect();
            accum.extend(dedup);
        } else {
            combined.insert(k, v.clone());
        }
    }
    
    // log_debug!("Dependencies for {}:{} {:?}", component_name, state_var_slice, combined);

    combined
}


fn get_source_for_dependency(
    core: &DoenetCore,
    dependency: &Dependency,
    essential_data: &HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>
) -> DependencySource {

    match dependency {
        Dependency::Essential { component_name, origin } => {
            match origin {

                EssentialDataOrigin::StateVar(_) => {
                    let data = essential_data.get(component_name).unwrap().get(origin).unwrap();
                    // let variant = components
                    //     .get(component_name).unwrap()
                    //     .definition
                    //     .state_var_definitions
                    //     .get(sv_name).unwrap();

                    DependencySource::Essential {
                        value_type: data.get_type_as_str()
                    }
                },
                _ => {
                    DependencySource::Essential{ value_type: "string", }
                },
            
            }
        },

        Dependency::StateVarArrayCorrespondingElement { component_group, array_state_var_name } => {
            let component_type = group_member_definition(
                &core.component_nodes,
                component_group,
            ).component_type;

            DependencySource::StateVar {
                component_type,
                state_var_name: array_state_var_name,
            }
        }
        Dependency::StateVar { component_group, state_var_slice } => {
            let component_type = group_member_definition(
                &core.component_nodes,
                component_group,
            ).component_type;

            DependencySource::StateVar {
                component_type,
                state_var_name: state_var_slice.name()
            }
        },

        Dependency::StateVarArrayDynamicElement { component_name, array_state_var_name, .. } => {
            let component_type = core.component_nodes
                .get(component_name).unwrap()
                .definition
                .component_type;
            DependencySource::StateVar {
                component_type,
                state_var_name: &array_state_var_name
            }
        }

    }
}

/// Also includes the values of essential data
fn get_dependency_sources_for_state_var(
    core: &DoenetCore,
    component_name: &ComponentName,
    state_ref: &StateRef,
) -> HashMap<InstructionName, Vec<(DependencySource, Option<StateVarValue>)>> {
    
    let my_dependencies = dependencies_of_state_var(&core.dependencies, component_name, state_ref);
    let mut dependency_sources: HashMap<InstructionName, Vec<(DependencySource, Option<StateVarValue>)>> = HashMap::new();

    for (instruction_name, dependencies) in my_dependencies {
        let instruction_sources: Vec<(DependencySource, Option<StateVarValue>)> = dependencies.iter().map(|dependency| {
            let source = get_source_for_dependency(core, &dependency, &core.essential_data);

            let essential_value = if let Dependency::Essential { origin, .. } = dependency {
                let data = core.essential_data
                    .get(component_name).unwrap()
                    .get(origin).unwrap();
                let value = data.get_value(state_ref.index()).unwrap();
                Some(value)

            } else {
                None
            };

            (source, essential_value)
        }).collect();

        dependency_sources.insert(instruction_name, instruction_sources);
    }

    dependency_sources
}

fn resolve_state_variable(
    core: &DoenetCore,
    component: &ComponentName,
    state_var_ref: &StateRef,
) -> Option<StateVarValue> {

    let state_vars = core.component_states.get(component).unwrap();

    // No need to continue if the state var is already resolved or if the element does not exist
    let current_state = state_vars.get(state_var_ref.name())
        .expect(&format!("Component {} has no state var '{:?}'", component, state_var_ref))
        .get_single_state(&state_var_ref.index())
        .expect(&format!("Error accessing state of {}:{:?}", component, state_var_ref));

    if let Some(State::Resolved(current_value)) = current_state {
        return Some(current_value);

    } else if current_state.is_none() {
        // There is nothing to resolve
        log_debug!("{}:{} does not exist", component, state_var_ref);
        return None
    }

    log_debug!("Resolving {}:{}", component, state_var_ref);

    let my_dependencies = dependencies_of_state_var(&core.dependencies, component, state_var_ref);

    log_debug!("Dependencies of {}:{} {:?}", component, state_var_ref, my_dependencies);

    let mut dependency_values: HashMap<InstructionName, Vec<DependencyValue>> = HashMap::new();

    for (dep_name, deps) in my_dependencies {

        let mut values_for_this_dep: Vec<DependencyValue> = Vec::new();

        for dep in deps {

            let dependency_source = get_source_for_dependency(core, &dep, &core.essential_data);

            match dep {

                Dependency::StateVar { component_group , state_var_slice } => {

                    for component_ref in component_group_members(core, &component_group) {

                        log_debug!("Component ref {:?}", component_ref);
                        let (sv_comp, sv_slice) = convert_component_ref_state_var(core, &component_ref, state_var_slice.clone()).unwrap();

                        log_debug!("Converted to sv_comp {} and sv_slice {}", sv_comp, sv_slice);

                        match sv_slice {
                            StateVarSlice::Single(ref sv_ref) => {

                                let depends_on_value = resolve_state_variable(core, &sv_comp, sv_ref);

                                if let Some(depends_on_value) = depends_on_value {
                                    values_for_this_dep.push(DependencyValue {
                                        source: dependency_source.clone(),
                                        value: depends_on_value,
                                    });    
                                }
                            }
                            StateVarSlice::Array(array_state_var_name) => {

                                // important to resolve the size before the elements
                                let size_value: usize = resolve_state_variable(
                                    core, &sv_comp, &StateRef::SizeOf(array_state_var_name))
                                .expect("Array size should always resolve to a StateVarValue")
                                .try_into()
                                .unwrap();
                                
                                for id in indices_for_size(size_value) {

                                    let element_value = resolve_state_variable(
                                        core,
                                        &sv_comp,
                                        &StateRef::ArrayElement(array_state_var_name, id)
                                    );

                                    if let Some(element_value) = element_value {
                                        values_for_this_dep.push(DependencyValue {
                                            source: dependency_source.clone(),
                                            value: element_value,
                                        });
                
                                    }
                
                                }
                            }
                        }
                    }

                },

                Dependency::StateVarArrayCorrespondingElement { component_group , array_state_var_name } => {

                    for component_ref in component_group_members(core, &component_group) {
                        let sv_ref = StateRef::from_name_and_index(array_state_var_name, state_var_ref.index());
                        let sv_slice = StateVarSlice::Single(sv_ref);
                        let (sv_comp, sv_slice) = convert_component_ref_state_var(core, &component_ref, sv_slice).unwrap();

                        match sv_slice {
                            StateVarSlice::Single(ref sv_ref) => {

                                let depends_on_value = resolve_state_variable(core, &sv_comp, sv_ref);

                                if let Some(depends_on_value) = depends_on_value {
                                    values_for_this_dep.push(DependencyValue {
                                        source: dependency_source.clone(),
                                        value: depends_on_value,
                                    });    
                                }
                            },
                            _ => (),
                        }
                    }

                },

                Dependency::Essential { component_name, origin } => {

                    let index = match origin {
                        EssentialDataOrigin::StateVar(_) => state_var_ref.index(),
                        _ => StateIndex::Basic,
                    };

                    let value = core.essential_data
                        .get(&component_name).unwrap()
                        .get(&origin).unwrap()
                        .clone()
                        .get_value(index);
    
                    if let Some(value) = value {
                        values_for_this_dep.push(DependencyValue {
                            source: dependency_source,
                            value,
                        })
                    }
                },

                Dependency::StateVarArrayDynamicElement { component_name, array_state_var_name, index_state_var } => {

                    let index_value = resolve_state_variable(
                        core,
                        component, // myself
                        &index_state_var,
                    );

                    let index: Option<usize> = if let Some(index_value) = index_value {

                        let index_num: f64 = index_value.try_into().unwrap();
                        convert_float_to_usize(index_num)

                    } else {
                        None
                    };

                    if let Some(index) = index {

                        log_debug!("got prop index which is {}", index);

                        let element_value = resolve_state_variable(
                            core,
                            &component_name,
                            &StateRef::ArrayElement(array_state_var_name, index)
                        );

                        log_debug!("element value is {:?}", element_value);

                        if let Some(element_value) = element_value {
                            values_for_this_dep.push(DependencyValue {
                                source: dependency_source,
                                value: element_value,
                            });
                        }
                    }





                }
            }
        }

        dependency_values.insert(dep_name, values_for_this_dep);
    }


    log_debug!("Dependency values for {}:{}: {:#?}", &component, state_var_ref, dependency_values);

    let node = core.component_nodes.get(component).unwrap();

    let update_instruction = generate_update_instruction_for_state_ref(
        node,
        state_var_ref,
        dependency_values
    ).expect(&format!("Can't resolve {}:{} (a {} component type)",
        component, state_var_ref, node.definition.component_type)
    );

    let new_value = handle_update_instruction(component,  state_var_ref, state_vars, update_instruction);

    return new_value;
}

/// This must resolve the size
fn elements_of_array(
    core: &DoenetCore,
    component: &ComponentName,
    array_name: &StateVarName,
) -> Vec<StateRef> {
    let size_ref = StateRef::SizeOf(array_name);
    let size: usize = resolve_state_variable(core, component, &size_ref)
        .unwrap()
        .try_into()
        .unwrap();

    indices_for_size(size).map(|i| StateRef::ArrayElement(array_name, i)).collect()
}


fn mark_stale_state_var_and_dependencies(
    core: &DoenetCore,
    component: &ComponentName,
    state_var_ref: &StateRef,
) {
    let component_state = core.component_states.get(component).unwrap();
    let state_var = component_state.get(state_var_ref.name()).unwrap();

    // No need to continue if the state var is already stale
    let state = state_var.get_single_state(&state_var_ref.index())
        .expect(&format!("Error accessing state of {}:{:?}", component, state_var_ref));

    if state == Some(State::Stale) {
        return;
    }

    log_debug!("Marking stale {}:{}", component, state_var_ref);

    state_var.mark_single_stale(&state_var_ref.index());

    let depending_on_me = get_state_variables_depending_on_me(core, component, state_var_ref);
    
    for (ref depending_comp, depending_slice) in depending_on_me {

        match depending_slice {
            StateVarSlice::Single(sv_ref) => {
                mark_stale_state_var_and_dependencies(core, depending_comp, &sv_ref);
            },
            StateVarSlice::Array(sv_name) => {
                let members = elements_of_array(core, component, &sv_name);
                for member in members {
                    mark_stale_state_var_and_dependencies(core, depending_comp, &member);
                }
            }
        }
    }
}




fn mark_stale_essential_datum_dependencies(
    core: &DoenetCore,
    component_name: ComponentName,
    state_index: &StateIndex,
    origin: EssentialDataOrigin,
) {

    // log_debug!("Marking stale essential {}:{}", component_name, state_var);

    let search_dep = Dependency::Essential {
        component_name,
        origin,
    };

    let my_dependencies = core.dependencies.iter().filter_map( |(key, deps) | {
        if deps.contains(&search_dep) {

            match key {
                DependencyKey::StateVar(comp_name, StateVarSlice::Single(s), _) => Some((comp_name, s.clone())),
                DependencyKey::StateVar(comp_name, StateVarSlice::Array(array), _) => {

                    match state_index {
                        StateIndex::Element(i) =>
                            Some((comp_name, StateRef::ArrayElement(array, *i))),
                        StateIndex::SizeOf =>
                            Some((comp_name, StateRef::SizeOf(array))),
                        StateIndex::Basic =>
                            // Arrays cannot use essential data
                            // associated with a basic state var.
                            None,
                    }
                }
            }

        } else {
            None
        }
    });

    for (component_name, state_var_ref) in my_dependencies {
        mark_stale_state_var_and_dependencies(core, &component_name, &state_var_ref);
    }
}



/// Sets the state var and returns the new value
fn handle_update_instruction(
    component_name: &ComponentName,
    state_var_ref: &StateRef,
    component_state_vars: &HashMap<StateVarName, StateForStateVar>,
    instruction: StateVarUpdateInstruction<StateVarValue>
) -> Option<StateVarValue> {

    // log_debug!("handling update instruction {:?}", &instruction);

    let state_var = component_state_vars.get(state_var_ref.name()).unwrap();

    let updated_value: Option<StateVarValue>;

    match instruction {
        StateVarUpdateInstruction::NoChange => {
            let current_value = component_state_vars.get(state_var_ref.name()).unwrap()
                .get_single_state(&state_var_ref.index())
                .expect(&format!("Error accessing state of {}:{:?}", component_name, state_var_ref));

            if let Some(State::Stale) = current_value {
                panic!("Cannot use NoChange update instruction on a stale value");

            } else if let Some(State::Resolved(current_resolved_value)) = current_value {
                // Do nothing. It's resolved, so we can use it as is
                updated_value = Some(current_resolved_value);

            } else {
                updated_value = None;
            };

        },
        StateVarUpdateInstruction::SetValue(new_value) => {

            updated_value = state_var.set_single_state(&state_var_ref.index(), new_value).unwrap();
            // .expect(&format!("Failed to set {}:{} while handling SetValue update instruction", component.name, state_var_ref)
            // );
        }

    };

    log_debug!("Updated {}:{} to {:?}", component_name, state_var_ref, updated_value);

    return updated_value;
}


/// Converts component group to a vector of component references.
fn component_group_members<'a>(
    core: &DoenetCore,
    component_group: &ComponentGroup,
) -> Vec<ComponentRef> {
    match component_group {
        ComponentGroup::Single(comp_ref) => vec![comp_ref.clone()],
        ComponentGroup::Group(name) => {
            let group_def = core.component_nodes.get(name).unwrap().definition.group.unwrap();
            let size: usize =
                if let Some((group_size_ref, _)) = group_def.generator() {
                    resolve_state_variable(core, name, &group_size_ref).unwrap()
                        .try_into().unwrap()
                } else {
                    // use group dependencies
                    core.group_dependencies.get(name).unwrap()
                        .iter()
                        .map(|dep|
                            match dep {
                                GroupDependency::Group(n) => component_group_members(
                                        core,
                                        &ComponentGroup::Group(n.clone())
                                    ).len(),
                                GroupDependency::Component(_) => 1,
                                GroupDependency::StateVar(_, _) => 0,
                            }
                        ).sum()
                };
            indices_for_size(size)
                .map(|i| ComponentRef::GroupMember(name.clone(), i))
                .collect()
        },
    }
}

/// Convert (ComponentRef, StateVarSlice) -> (ComponentName, StateVarSlice).
/// If the component reference is a group member, these are not the same.
fn convert_component_ref_state_var(
    core: &DoenetCore,
    name: &ComponentRef,
    state_var: StateVarSlice,
) -> Option<(ComponentName, StateVarSlice)> {
    match name {
        ComponentRef::Basic(n) => Some((n.clone(), state_var)),
        ComponentRef::GroupMember(n, i) => group_member_state_var(core, &n, state_var, *i)
    }
}

/// Find the state variable for the nth member of a group
fn group_member_state_var(
    core: &DoenetCore,
    name: &ComponentName,
    state_var: StateVarSlice,
    index: usize,
) -> Option<(ComponentName, StateVarSlice)> {
    let group_def = core.component_nodes.get(name).unwrap().definition.group.unwrap();

    if let Some((_, member_state_var)) = group_def.generator() {
        let state_var_resolver = | state_var_ref | {
            resolve_state_variable(core, name, state_var_ref)
        };
        member_state_var(index, &state_var, &state_var_resolver)
            .map(|sv| (name.clone(), sv))
    } else {
        // if the component does not specify a member_state_var function,
        // use the group_dependencies to find the ComponentRef
        nth_group_dependence(core, name, index)
            .map(|c| (c, state_var))
    }
}

fn nth_group_dependence(
    core: &DoenetCore,
    group_name: &ComponentName,
    index: usize,
) -> Option<ComponentName> {
    let mut index = index;
    log_debug!("callin it {index}");
    nth_group_dependence_internal(&mut index, group_name, &core.group_dependencies)
}

fn nth_group_dependence_internal(
    index: &mut usize,
    group_name: &ComponentName,
    group_dependencies: &HashMap<ComponentName, Vec<GroupDependency>>,
) -> Option<ComponentName> {
    for group_dep in group_dependencies.get(group_name).unwrap() {
        log_debug!("gd {:?} {}", &group_dep, index);
        match group_dep {
            GroupDependency::Group(n) => {
                match nth_group_dependence_internal(index, n, group_dependencies) {
                    Some(c) => return Some(c),
                    None => (),
                }
            },
            GroupDependency::Component(n) => {
                if *index > 1 {
                    *index -= 1;
                } else {
                    return Some(n.clone());
                }
            },
            _ => (),
        }
    }
    None
}


#[derive(Debug)]
pub struct Action {
    pub component_name: ComponentName,
    pub action_name: String,

    /// The keys are not state variable names.
    /// They are whatever name the renderer calls the new value.
    pub args: HashMap<String, StateVarValue>,
}


/// Internal structure used to track changes
#[derive(Debug, Clone)]
enum UpdateRequest {
    SetEssentialValue(ComponentName, EssentialDataOrigin, StateIndex, StateVarValue),
    SetStateVar(ComponentName, StateRef, StateVarValue),
}


/// Convert the results of `request_dependencies_to_update_value`
/// into UpdateRequest struct.
fn convert_dependency_values_to_update_request(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var: &StateRef,
    requests: HashMap<InstructionName, Result<Vec<DependencyValue>, String>>,
) -> Vec<UpdateRequest> {

    let my_dependencies = dependencies_of_state_var(
        &core.dependencies,
        &component.name,
        state_var
    );

    let mut update_requests = Vec::new();

    for (instruction_name, instruction_requests) in requests {

        let valid_requests = match instruction_requests {
            Err(_e) => {
                log_debug!("Inverse definition for {}:{} failed with: {}", component.name, state_var, _e);
                break;
            },
            Ok(result) => result,
        };

        // stores (group name, index)
        let mut group_index = (None, 0);


        let instruct_dependencies = my_dependencies.get(instruction_name).expect(
            &format!("{}:{} has the wrong instruction name to determine dependencies",
                component.definition.component_type, state_var)
        );

        assert_eq!(valid_requests.len(), instruct_dependencies.len());

        for (request, dependency) in valid_requests.into_iter().zip(instruct_dependencies.iter()) {

            match dependency {
                Dependency::Essential { component_name, origin } => {
                    update_requests.push(UpdateRequest::SetEssentialValue(
                        component_name.clone(),
                        origin.clone(),
                        state_var.index(),
                        request.value.clone(),
                    ))
                },
                Dependency::StateVar { component_group, state_var_slice } => {
                    let component_ref = match component_group {
                        ComponentGroup::Group(n) => {

                            // determine the group member this DependencyValue corresponds to
                            if group_index.0 == Some(n) {
                                group_index.1 += 1;
                            } else {
                                group_index.0 = Some(n);
                                group_index.1 = 1;
                            }
                            ComponentRef::GroupMember(n.clone(), group_index.1 - 1)
                        },
                        ComponentGroup::Single(comp_ref) => {
                            comp_ref.clone()
                        },
                    };

                    if let Some((sv_comp, _)) = convert_component_ref_state_var(core, &component_ref, state_var_slice.clone()) {
                        if let StateVarSlice::Single(state_var_ref) = state_var_slice {
                            update_requests.push(UpdateRequest::SetStateVar(
                                sv_comp,
                                state_var_ref.clone(),
                                request.value.clone(),
                            ))
                        }
                    }
                },
                _ => (),
            }
        }

    }

    update_requests

}


pub fn handle_action_from_json(core: &DoenetCore, action: &str) -> String {

    let (action, action_id) = parse_json::parse_action_from_json(action)
        .expect(&format!("Error parsing json action: {}", action));

    handle_action(core, action);

    action_id
}

pub fn handle_action(core: &DoenetCore, action: Action) {

    log_debug!("Handling action {:#?}", action);

    let component_name = &action.component_name;

    let component = core.component_nodes.get(component_name)
        .expect(&format!("{} doesn't exist, but action {} uses it", action.component_name, action.action_name));

    let state_var_resolver = | state_var_ref | {
        resolve_state_variable(core, component_name, state_var_ref)
    };

    let state_vars_to_update = (component.definition.on_action)(
        &action.action_name,
        action.args,
        &state_var_resolver,
    );

    for (state_var_ref, requested_value) in state_vars_to_update {

        let request = UpdateRequest::SetStateVar(component_name.clone(), state_var_ref.clone(), requested_value);
        process_update_request(core, &request);
    }

    // log_json!("Component tree after action", utils::json_components(&core.component_nodes, &core.component_states));
}


fn process_update_request(
    core: &DoenetCore,
    update_request: &UpdateRequest
) {

    log_debug!("Processing update request {:?}", update_request);

    match update_request {
        UpdateRequest::SetEssentialValue(component_ref, origin, state_index, requested_value) => {

            let essential_var = core.essential_data
                .get(component_ref).unwrap()
                .get(origin).unwrap();

            essential_var.set_value(
                    state_index.clone(),
                    requested_value.clone()
                ).expect(
                    &format!("Failed to set essential value for {}, {:?}, {:?}", component_ref, origin, state_index)
                );

            // log_debug!("Updated essential data {:?}", core.essential_data);

            mark_stale_essential_datum_dependencies(core, component_ref.clone(), state_index, origin.clone());
        },

        UpdateRequest::SetStateVar(component_name, state_var_ref, requested_value) => {

            let dep_comp = core.component_nodes.get(component_name).unwrap();

            let dep_update_requests = request_dependencies_to_update_value_including_shadow(
                core,
                dep_comp,
                state_var_ref,
                requested_value.clone(),
            );

            for dep_update_request in dep_update_requests {
                process_update_request(core, &dep_update_request);
            }

            mark_stale_state_var_and_dependencies(core, component_name, &state_var_ref);
        }
    }
}





pub fn update_renderers(core: &DoenetCore) -> String {
    let json_obj = generate_render_tree(core);

    log_json!("Component tree after renderer update", utils::json_components(&core.component_nodes, &core.component_states));

    log_json!("Essential data after renderer update",
    utils::json_essential_data(&core.essential_data));

    serde_json::to_string(&json_obj).unwrap()
}


fn generate_render_tree(core: &DoenetCore) -> serde_json::Value {

    let root_node = core.component_nodes.get(&core.root_component_name).unwrap();
    let root_comp_rendered = RenderedComponent {
        component_ref: ComponentRef::Basic(root_node.name.clone()),
        child_of_copy: None
    };
    let mut json_obj: Vec<serde_json::Value> = vec![];

    generate_render_tree_internal(core, root_comp_rendered, &mut json_obj);

    serde_json::Value::Array(json_obj)
}

#[derive(Debug)]
struct RenderedComponent {
    component_ref: ComponentRef,
    child_of_copy: Option<ComponentName>,
}


fn name_child_of_copy(child: &str, copy: &str) -> String {
    format!("__cp:{}({})", child, copy)
}

fn name_member_of_group(name: &str, group: &str, index: usize) -> String {
    format!("{}_from_({}[{}])", name, group, index)
}


fn generate_render_tree_internal(
    core: &DoenetCore,
    component: RenderedComponent,
    json_obj: &mut Vec<serde_json::Value>,
) {
    use serde_json::{Map, Value, json};

    let component_name = component.component_ref.name().clone();

    // log_debug!("generating render tree for {:?}", component);

    let component_definition = component_ref_definition(
        &core.component_nodes,
        &component.component_ref,
    );

    let renderered_state_vars = component_definition
        .state_var_definitions
        .into_iter()
        .filter_map(|(k, v)| {
            if v.for_renderer() {
                match v.is_array() {
                    true => Some(StateVarSlice::Array(k)),
                    false => Some(StateVarSlice::Single(StateRef::Basic(k))),
                }
            } else {
                None
            }
        });

    let state_var_aliases = match &component_definition.renderer_type {
        RendererType::Special { state_var_aliases, .. } => state_var_aliases.clone(),
        RendererType::Myself => HashMap::new(),
    };

    let mut state_values = serde_json::Map::new();
    for state_var_slice in renderered_state_vars {
        let (sv_comp, sv_slice) = convert_component_ref_state_var(
            core,
            &component.component_ref,
            state_var_slice
        ).unwrap();

        match sv_slice {
            StateVarSlice::Array(sv_name) => {

                // TODO: not the best way to do this?
                let sv_refs = elements_of_array(core, &component_name, &sv_name);

                let mut values: Vec<f64> = Vec::new();
                for sv_ref in sv_refs {
                    values.push(
                        resolve_state_variable(core, &sv_comp, &sv_ref)
                        .unwrap()
                        .try_into()
                        .unwrap()
                    );
                }

                let sv_renderer_name = state_var_aliases
                    .get(&sv_slice.name())
                    .map(|x| *x)
                    .unwrap_or(sv_slice.name());
                state_values.insert(sv_renderer_name.to_string(), json!(values));
            },

            StateVarSlice::Single(state_ref) => {
                let state_var_value = resolve_state_variable(core, &sv_comp, &state_ref)
                    .expect(&format!("state var {}:{} cannot be resolved", &sv_comp, &state_ref));

                let sv_renderer_name = state_var_aliases
                    .get(&state_ref.name())
                    .map(|x| *x)
                    .unwrap_or(state_ref.name());
                if sv_renderer_name == "selectedStyle" || sv_renderer_name == "graphicalDescendants" {
                    if let StateVarValue::String(v) = state_var_value {
                        // log_debug!("deserializing for renderer: {}", v);
                        let value = serde_json::from_str(&v).unwrap();
                        state_values.insert(sv_renderer_name.to_string(), value);
                    }
                } else {
                    state_values.insert(sv_renderer_name.to_string(), state_var_value.into());
                }
            },
        }
    }

    let name_to_render = match &component.component_ref {
        ComponentRef::GroupMember(n, i) => name_member_of_group(component_definition.component_type, n, *i),
        _ => component_name.clone(),
    };
    let name_to_render = match &component.child_of_copy {
        Some(copy_name) => name_child_of_copy(&name_to_render, &copy_name),
        None => name_to_render,
    };

    let mut children_instructions = Vec::new();
    let node = core.component_nodes.get(&component_name).unwrap();
    if node.definition.should_render_children {

        for (child, actual_parent) in get_children_and_members(core, &component.component_ref) {
            match child {
                ObjectRefName::Component(comp_ref) => {
                    // recurse for children

                    let child_component = RenderedComponent {
                        component_ref: comp_ref,
                        child_of_copy: component.child_of_copy.clone().or(
                            if std::ptr::eq(actual_parent, node) {
                                None
                            } else {
                                Some(component_name.clone())
                            }
                        ),
                    };

                    let child_definition =
                        component_ref_definition(&core.component_nodes, &child_component.component_ref);

                    let child_name = match &child_component.component_ref {
                        ComponentRef::GroupMember(n, i) => name_member_of_group(&child_definition.component_type, n, *i),
                        ComponentRef::Basic(n) => n.clone(),
                    };

                    let exact_copy_of_component: Option<ComponentName> =
                        match &child_component.component_ref {
                            ComponentRef::Basic(n) => Some(n.clone()),
                            ComponentRef::GroupMember(n, i) => {
                                let group_node = core.component_nodes.get(n).unwrap();
                                if group_node.definition.group.unwrap().generator().is_none() {
                                    Some(nth_group_dependence(core, n, *i).unwrap())
                                } else {
                                    None
                                }
                            },
                        };

                    let action_component_name = exact_copy_of_component
                        .unwrap_or(child_name.clone());

                    let child_actions: Map<String, Value> =
                        (child_definition.action_names)()
                        .iter()
                        .map(|action_name| 
                            (action_name.to_string(), json!({
                                "actionName": action_name,
                                "componentName": action_component_name,
                            }))
                        ).collect();

                    let renderer_type = match &child_definition.renderer_type {
                        RendererType::Special{ component_type, .. } => *component_type,
                        RendererType::Myself => child_definition.component_type,
                    };

                    children_instructions.push(json!({
                        "actions": child_actions,
                        "componentName": child_name,
                        "componentType": child_definition.component_type,
                        "effectiveName": child_name,
                        "rendererType": renderer_type,
                    }));

                    generate_render_tree_internal(core, child_component, json_obj); 
                },
                ObjectRefName::String(string) => {
                    children_instructions.push(json!(string));
                },
            }
        }
    }

    json_obj.push(json!({
        "componentName": name_to_render,
        "stateValues": serde_json::Value::Object(state_values),
        "childrenInstructions": json!(children_instructions),
    }));

}


/// Returns component definition and component type.
fn group_member_definition(
    component_nodes: &HashMap<ComponentName, ComponentNode>,
    component_group: &ComponentGroup,
) -> &'static ComponentDefinition {

    match component_group {
        ComponentGroup::Group(group_name) => {
            let component_ref = &ComponentRef::GroupMember(group_name.clone(), 0);
            component_ref_definition(component_nodes, component_ref)
        },
        ComponentGroup::Single(component_ref) => {
            component_ref_definition(component_nodes, component_ref)
        }
    }
}

/// Returns component definition and component type.
fn component_ref_definition(
    component_nodes: &HashMap<ComponentName, ComponentNode>,
    component_ref: &ComponentRef,
) -> &'static ComponentDefinition {

    // log_debug!("Getting component ref definition for {:?}", component_ref);

    let name = component_ref.name();
    let child_type = match &component_ref {
        ComponentRef::GroupMember(n, _) => {
            let group_def =
                component_nodes.get(n).unwrap()
                .definition.group.expect(
                    &format!("Component {} does not have a group definition", n)
                );

            (group_def.component_type)(&component_nodes.get(&name).unwrap().static_attributes)
        },
        _ => component_nodes.get(&name).expect(
                &format!("no component named {}", name)
            ).definition.component_type,
    };

    COMPONENT_DEFINITIONS.get(child_type).unwrap()
}

/// Returns component definition and component type.
fn definition_of_members<'a>(
    definition: &'a ComponentDefinition,
    static_attributes: &HashMap<AttributeName, String>,
) -> &'a ComponentDefinition {

    if let Some(group_def) = definition.group {
        COMPONENT_DEFINITIONS.get(
            (group_def.component_type)(static_attributes)
        ).unwrap()
    } else {
        definition
    }
}


enum ObjectRefName {
    Component(ComponentRef),
    String(String),
}

fn get_children_and_members<'a>(
    core: &'a DoenetCore,
    component: &ComponentRef,
) -> impl Iterator<Item=(ObjectRefName, &'a ComponentNode)> {

    get_children_including_copy(
        &core.component_nodes,
        core.component_nodes.get(&component.name()).unwrap()
    )
    .into_iter()
    .flat_map(|(child, actual_parent)| match child {
        ComponentChild::String(s) => vec![(ObjectRefName::String(s.clone()), actual_parent)],
        ComponentChild::Component(comp_name) => {

            if core.component_nodes.get(&comp_name).unwrap().definition.group.is_some() {
                let group = ComponentGroup::Group(comp_name.clone());

                component_group_members(core, &group).iter().map(|comp_ref|
                    (ObjectRefName::Component(comp_ref.clone()),
                    actual_parent)
                ).collect::<Vec<(ObjectRefName, &ComponentNode)>>()
            } else {
                vec![(ObjectRefName::Component(ComponentRef::Basic(comp_name.clone())),
                actual_parent)]
            }
        },
    })
}



////////////// Wrappers providing for CopySource and sequence component //////////////


/// This includes the copy source's children.
fn get_children_including_copy<'a>(
    components: &'a HashMap<ComponentName, ComponentNode>,
    component: &'a ComponentNode,
) -> Vec<(ComponentChild, &'a ComponentNode)> {

    // log_debug!("Getting children for {}", component.name);

    let mut children_vec: Vec<(ComponentChild, &ComponentNode)> = Vec::new();
    if let Some(CopySource::Component(ComponentRef::Basic(ref source))) = component.copy_source {

        let source_comp = components.get(source).unwrap();

        children_vec = get_children_including_copy(components, source_comp);

    // } else if let Some(CopySource::StateVar(_, _)) = component.copy_source {
    //     // If this is a copy prop, add whatever it is copying as a child
    //     children_vec.push((ComponentChild::Component(component.name.clone()), component));
    }

    children_vec.extend(
        component.children
        .iter()
        .map(|c| (c.clone(), component))
    );

    children_vec
}


/// Recurse until the name of the original source is found.
/// This allows copies to share essential data.
fn get_recursive_copy_source_component_if_exists<'a>(
    components: &'a HashMap<ComponentName, ComponentNode>,
    component: &'a ComponentNode,
) -> &'a ComponentName {
    match &component.copy_source {
        Some(CopySource::Component(ComponentRef::Basic(ref source))) =>
            get_recursive_copy_source_component_if_exists(components, components.get(source).unwrap()),
        _ => &component.name,
    }
}


fn return_dependency_instructions_for_state_ref(
    component: &ComponentNode,
    state_var: &StateRef,
) -> HashMap<InstructionName, DependencyInstruction> {

    let state_var_def = component.definition.state_var_definitions.get(state_var.name()).unwrap();

    match state_var {
        StateRef::Basic(_) => {
            state_var_def.return_dependency_instructions(HashMap::new())
        },
        StateRef::SizeOf(_) => {
            state_var_def.return_size_dependency_instructions(HashMap::new())
        },
        StateRef::ArrayElement(_, id) => {
            state_var_def.return_element_dependency_instructions(*id, HashMap::new())
        }
    }
}



/// This determines the state var given its dependency values.
fn generate_update_instruction_for_state_ref(
    component: &ComponentNode,
    state_var: &StateRef,
    dependency_values: HashMap<InstructionName, Vec<DependencyValue>>

) -> Result<StateVarUpdateInstruction<StateVarValue>, String> {

    let state_var_def = component.definition.state_var_definitions.get(state_var.name()).unwrap();

    match state_var {
        StateRef::Basic(_) => {
            state_var_def.determine_state_var_from_dependencies(dependency_values)
        },
        StateRef::SizeOf(_) => {
            state_var_def.determine_size_from_dependencies(dependency_values)
        },
        StateRef::ArrayElement(_, id) => {
            let internal_id = id - 1;
            state_var_def.determine_element_from_dependencies(internal_id, dependency_values)
        }
    }

}



fn request_dependencies_to_update_value_including_shadow(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var_ref: &StateRef,
    new_value: StateVarValue,
) -> Vec<UpdateRequest> {

    if let Some((source_ref, source_sv_ref)) = state_var_is_shadowing(component, state_var_ref) {

        let (source_comp, source_state_var) =
            convert_component_ref_state_var(core, &source_ref, source_sv_ref)
            .unwrap();

        let source_state_var = match source_state_var {
            StateVarSlice::Single(sv_ref) => sv_ref,
            StateVarSlice::Array(_) => panic!()
        };
        vec![UpdateRequest::SetStateVar(source_comp, source_state_var, new_value)]

    } else {

        let dependency_sources = get_dependency_sources_for_state_var(core, &component.name, &state_var_ref.clone());

        log_debug!("Dependency sources for {}{}, {:?}", component.name, state_var_ref, dependency_sources);

        let requests = component.definition.state_var_definitions.get(state_var_ref.name()).unwrap()
            .request_dependencies_to_update_value(state_var_ref, new_value, dependency_sources)
            .expect(&format!("Failed requesting dependencies for {}:{}", component.name, state_var_ref));

        log_debug!("{}:{} wants its dependency to update to: {:?}", component.name, state_var_ref, requests);

        let update_requests = convert_dependency_values_to_update_request(core, component, state_var_ref, requests);

        log_debug!("{}:{} generated update requests: {:#?}", component.name, state_var_ref, update_requests);

        update_requests
    }
}

/// Detect if a state var is shadowing because of a CopySource
/// and has a primary input state variable, which is needed.
fn state_var_is_shadowing(component: &ComponentNode, state_var: &StateRef)
    -> Option<(ComponentRef, StateVarSlice)> {

    if let Some(CopySource::StateVar(ref source_comp, ref source_state_var)) = component.copy_source {
        if let Some(primary_input_state_var) = component.definition.primary_input_state_var {

            if state_var == &StateRef::Basic(primary_input_state_var) {
                Some((source_comp.clone(), StateVarSlice::Single(source_state_var.clone())))
            } else {
                None
            }
        } else {
            panic!("{} component type doesn't have a primary input state var", component.definition.component_type);
        }

    } else if let Some(CopySource::DynamicElement(ref source_comp, ref source_state_var, ..)) = component.copy_source {
        if let Some(primary_input_state_var) = component.definition.primary_input_state_var {

            if state_var == &StateRef::Basic(primary_input_state_var) {

                Some((ComponentRef::Basic(source_comp.to_string()), StateVarSlice::Array(source_state_var)))
            } else {
                None
            }
        } else {
            panic!("{} component type doesn't have a primary input state var", component.definition.component_type);
        }


    } else {
        None
    }
}


fn convert_float_to_usize(f: f64) -> Option<usize> {
    let my_int = f as i64;
    if my_int as f64 == f {
        // no loss of precision
        usize::try_from(my_int).ok()
    } else {
        None
    }
}


fn indices_for_size(size: usize) -> std::ops::Range<usize> {
    1..size+1
}
