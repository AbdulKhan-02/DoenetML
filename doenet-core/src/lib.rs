pub mod state_variables;
pub mod component;

pub mod state;
pub mod parse_json;
pub mod utils;
pub mod base_definitions;
pub mod math_expression;

use base_definitions::PROP_INDEX_SV;
use lazy_static::lazy_static;
use parse_json::DoenetMLError;
use state::StateForStateVar;
use std::{collections::HashMap};
use std::fmt::Debug;
use regex::Regex;

use state::{State, EssentialStateVar};
use component::*;
use state_variables::*;

use crate::math_expression::MathExpression;
use crate::utils::{log_json, log_debug};
use serde::Serialize;


/// A static DoenetCore is created from parsed DoenetML at the beginning.
/// While `component_states` and `essential_data` can update using
/// internal mutability (the RefCell), the over-arching HashMaps are static.
#[derive(Debug)]
pub struct DoenetCore {
    /// The component tree has almost the same structute as the tree of elements
    /// typed into DoenetML. The exceptions are that attributes and macros
    /// are converted into their own components.
    pub component_nodes: HashMap<ComponentName, ComponentNode>,

    /// This is keyed by `StateVarName` rather than `StateVarReference`
    /// so that it is static even when arrays change size.
    pub component_states: HashMap<ComponentName, HashMap<StateVarName, StateForStateVar>>,

    pub root_component_name: ComponentName,

    /// The Dependency Graph
    /// A DAC whose vertices are the state variables and attributes
    /// of every component, and whose endpoint vertices are essential data.
    pub dependencies: HashMap<DependencyKey, Vec<Dependency>>,

    /// Endpoints of the dependency graph.
    /// Every update instruction will lead to these.
    pub essential_data: HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,

    /// We send components to the renderer that do not exists:
    /// - the inherited children of a copy
    ///
    /// The renderer needs to recognize these as a different component so we alias its name.
    /// This maps the name the renderer is given to the actual name.
    pub aliases: HashMap<String, ComponentName>,
}


/// State variables are keyed by:
/// 1. the name of the component
/// 2. the name of a state variable slice
///    which allows for two kinds of dependencies:
///      - direct dependency: when a single state var depends on something
///      - indirect dependency: when a group depends on something,
///        and members of the group inherit the dependency.
///        The motivation for indirect dependencies is that
///        the size of groups can change (e.g. an array changes size).
///        To keep the dependency graph static, we do not update
///        individual dependencies but simply apply the group dependency.
/// 3. the instruction name, given by the state variable to track where
///    dependecy values came from.
#[derive(Debug, Hash, PartialEq, Eq, Serialize)]
pub enum DependencyKey {
    StateVar(ComponentName, StateVarSlice, InstructionName),
}

impl DependencyKey {
    fn component_name(&self) -> &str {
        match self {
            DependencyKey::StateVar(name, _, _) => name,
        }
    }
}


/// A collection of edges on the dependency tree
#[derive(Debug, Clone, PartialEq, Eq, Serialize)]
pub enum Dependency {
    StateVar {
        component_name: ComponentName,
        state_var_ref: StateRef,
    },
    Essential {
        component_name: ComponentName,
        origin: EssentialDataOrigin,
    },

    /// This represents multiple edges on the dependency graph,
    /// since it references multiple state variables.
    StateVarArray {
        component_name: String,
        array_state_var_name: StateVarName,
    },

    StateVarArrayDynamicElement {
        component_name: ComponentName,
        array_state_var_name: StateVarName,
        index_state_var: StateRef, // presumably an integer from the component that carries this dependency
    }
}


/// Essential data can be generated by
/// - a state variable requesting it
/// - a string child, converted into essential data
///   so that it can change when requested
/// - a string in an attribute
#[derive(Serialize, Debug, Clone, Eq, Hash, PartialEq)]
pub enum EssentialDataOrigin {
    StateVar(StateVarName),
    ComponentChild(usize),
    AttributeString(usize),
}



pub fn create_doenet_core(program: &str) -> Result<DoenetCore, DoenetMLError> {

    // Create component nodes and attributes
    let (
        mut component_nodes,
        component_attributes,
        copy_prop_index_instances,
        root_component_name
    ) = parse_json::create_components_tree_from_json(program)?;

    log_debug!("Copy prop index instances {:#?}", copy_prop_index_instances);

    // Parse attribute strings and generate components from strings
    // in attributes and string children macros.
    let (component_attributes, copy_index_flags) =
        parse_attributes_and_macros(&mut component_nodes, component_attributes, copy_prop_index_instances);


    // Check invalid component names for copy index
    for (_, (source_name, _, _)) in copy_index_flags.iter() {
        if !component_nodes.contains_key(source_name) {
            // The component tried to copy a non-existent component.
            return Err(DoenetMLError::ComponentDoesNotExist {
                comp_name: source_name.to_owned()
            });
        }
    }

    // let mut dynamic_copy_index_flags: HashMap<ComponentName, (ComponentName, StateVarName, Vec<ObjectName>)>;
    
    for (component_name, copy_index_flag) in copy_index_flags {

        let (copy_index_comp, copy_index_array_sv, copy_index_sources) = copy_index_flag;
        let component = component_nodes.get_mut(&component_name).unwrap();

        let first_string_source = copy_index_sources.iter().find_map(|source| {
            if let ObjectName::String(string_source) = source {
                Some(string_source)
            } else {
                None
            }
        });

        if copy_index_sources.len() == 1 && first_string_source.is_some() {

            let source = first_string_source.unwrap();

            let index_number: Option<usize> = if let Ok(valid_result) = evalexpr::eval(&source) {

                if let Ok(valid_num) = valid_result.as_number() {
                    convert_float_to_usize(valid_num)
                } else {
                    None
                }
            } else {
                // return Err(DoenetMLError::NonNumericalPropIndex {
                //     comp_name: component_name,
                //     invalid_index: source.to_owned()
                // });

                None
            };

            let index_number: usize = match index_number {
                Some(valid_index) =>  valid_index,
                None => {
                    // return Err(DoenetMLError::PropIndexIsNotPositiveInteger {
                    //     comp_name: component_name,
                    //     invalid_index: source.to_string()
                    // })
                    0
                },
            };
            
            component.copy_source = Some(CopySource::StateVar(
                copy_index_comp.to_string(),
                StateRef::ArrayElement(copy_index_array_sv, index_number)
            ));

        } else {

            // let all_index_sources_concatted = copy_index_sources.iter()
            //     .fold(String::new(), |concatted, new_obj| {
            //         format!("{}{}", concatted, match new_obj {
            //             ObjectName::String(v) => v,
            //             ObjectName::Component(v) => v,
            //         })
            //     });

            let variable_components = copy_index_sources.iter().filter_map(|obj| {
                if let ObjectName::Component(comp_name) = obj {
                    Some(comp_name.clone())
                } else {
                    None
                }
            }).collect();

            let expression = MathExpression::new(&copy_index_sources);

            if !expression.can_evaluate_to_number() {
                // return Err(DoenetMLError::NonNumericalPropIndex {
                //     comp_name: component_name,
                //     invalid_index: all_index_sources_concatted
                // });
            }

            component.copy_source = Some(CopySource::DynamicElement(
                copy_index_comp.to_string(),
                copy_index_array_sv,
                expression,
                variable_components,
            ));
        }
    
    }






    // Check for invalid names in both CopySource::Components and CopySource::StateVar
    // Also check that all state var array copies are valid
    let copy_sources = component_nodes.iter().filter_map(|(_, comp)| comp.copy_source.as_ref());
    for copy_source in copy_sources {

        let source_name = match copy_source {
            CopySource::Component(comp_name) => comp_name,
            CopySource::StateVar(comp_name, _) => comp_name,
            CopySource::DynamicElement(comp_name, ..) => comp_name,
        };

        if !component_nodes.contains_key(source_name) {
            // The component tried to copy a non-existent component.
            return Err(DoenetMLError::ComponentDoesNotExist {
                comp_name: source_name.to_owned()
            });
        }


        if let CopySource::StateVar(source_comp_name, source_state_ref) = copy_source {
            let source_comp = component_nodes.get(source_comp_name).unwrap();
            let source_sv_def = source_comp.definition.state_var_definitions.get(source_state_ref.name()).unwrap();

            if source_sv_def.is_array() {
                match source_state_ref {
                    StateRef::Basic(_) => {
                        return Err(DoenetMLError::CannotCopyArrayStateVar {
                            source_comp_name: source_comp_name.to_owned(),
                            source_sv_name: source_state_ref.name(),
                        });
    
                    },
                    StateRef::ArrayElement(_, _) => {}, //no error
                    StateRef::SizeOf(_) => unreachable!(),
                }

            } else {
                match source_state_ref {
                    StateRef::Basic(_) => {}, //no error
                    StateRef::ArrayElement(_, _) => {
                        return Err(DoenetMLError::CannotCopyIndexForStateVar {
                            source_comp_name: source_comp_name.to_owned(),
                            source_sv_name: source_state_ref.name(),
                        });
                    },
                    StateRef::SizeOf(_) => unreachable!(),
                }
            }
        }

    }


    // All the components that copy another component, along with the name of the component they copy
    let copy_comp_targets: Vec<(&ComponentNode, &ComponentName)> = component_nodes.iter().filter_map(|(_, c)|
        match c.copy_source {
            Some(CopySource::Component(ref source)) => Some((c, source)),
            _ => None,
        }
    ).collect();

    // Make sure that the source and target components are the same type
    for (comp, source_comp_name) in copy_comp_targets.iter() {
        let source_comp = component_nodes.get(*source_comp_name).unwrap();
        if comp.component_type != source_comp.component_type {
            return Err(DoenetMLError::ComponentCannotCopyOtherType {
                component_name: comp.name.clone(),
                component_type: comp.component_type,
                source_type: source_comp.component_type,
            });
        }
    }

    // Check for cyclical dependencies due to CopySource::Component.
    // Otherwise alias and dependency generation could crash.
    for (copy_component, _) in copy_comp_targets.iter() {
        if let Some(cyclic_error) = check_cyclic_copy_source_component(&component_nodes, copy_component) {
            return Err(cyclic_error);
        }
    }

    // For every copy, add the necessary aliases for the renderers to use
    let mut aliases: HashMap<String, ComponentName> = HashMap::new();
    for (copy, _) in copy_comp_targets {
        add_alias_for_children(&mut aliases, copy, &component_nodes, &copy.name);
    }



    // Check invalid component names for attributes
    for attributes_for_comp in component_attributes.values() {
        for attributes in attributes_for_comp.values() {
            for attribute_list in attributes.values() {
                for attr_object in attribute_list {

                    if let ObjectName::Component(comp_obj) = attr_object {
                        if !component_nodes.contains_key(comp_obj) {
                            // The component tried to copy a non-existent component.
                            return Err(DoenetMLError::ComponentDoesNotExist {
                                comp_name: comp_obj.to_owned()
                            });
                        }
                    }
                }
            }
        }
    }

    // This variable is used during core creation to remember the essential addresses of all the
    // attribute data that is stored in essential data. Note that the StateIndex in the HashMap's
    // value refers to the essential data's index, which is not the same as the StateRef's index
    // let mut essential_attribute_lookup:
        // HashMap<(ComponentName, StateRef), (EssentialDataOrigin, Vec<StateIndex>)> = HashMap::new();

    let mut essential_data = HashMap::new();

    for (target_comp_name, attributes_for_comp) in component_attributes.iter() {
        for (target_sv_name, attributes) in attributes_for_comp {

            let mut string_essential: Vec<(usize, usize, String)> = attributes.iter()
                .flat_map(|(sv_array_id, attribute_list)| {
                    attribute_list.iter().enumerate().filter_map(|(element_id, obj)| {
                        if let ObjectName::String(str_value) = obj {
                            Some((*sv_array_id, element_id, str_value.to_string()))
                        } else {
                            None
                        }
                    })
                }).collect();
            
            

            for (attribute_index, attribute) in attributes {
                for attribute_object in attribute {

                    if let ObjectName::Component(comp_obj) = attribute_object {
                        if !component_nodes.contains_key(comp_obj) {
                            // The component tried to copy a non-existent component.
                            return Err(DoenetMLError::ComponentDoesNotExist {
                                comp_name: comp_obj.to_owned()
                            });
                        }
                    }
                }
            }

        }
    }




    // Fill in component_states and dependencies HashMaps for every component
    // and supply any essential_data required by dependencies.

    let mut component_states = HashMap::new();
    let mut dependencies = HashMap::new();

    for (component_name, component_node) in component_nodes.iter() {

        let dependencies_for_this_component = create_all_dependencies_for_component(
            &component_nodes,
            component_node,
            component_attributes.get(component_name).unwrap_or(&HashMap::new()),
            // copy_index_flags.get(component_name).as_deref(),
            &mut essential_data,
        );

        let state_for_this_component: HashMap<StateVarName, StateForStateVar> =
            component_node.definition.state_var_definitions
            .iter()
            .map(|(&sv_name, sv_variant)| (sv_name, StateForStateVar::new(&sv_variant)))
            .collect();

        dependencies.extend(dependencies_for_this_component);

        component_states.insert(
            component_name.clone(),
            state_for_this_component,
        );
    }


    // Now that the dependency graph has been created, use it to check for cyclical dependencies
    // for all the components
    for (dep_key, _) in dependencies.iter() {
        let DependencyKey::StateVar(comp, sv_ref, _) = dep_key;
        let mut chain = vec![(comp.clone(), sv_ref.clone())];
        let possible_error = check_for_cyclical_dependencies(&dependencies, &mut chain);

        if let Some(error) = possible_error {
            return Err(error);
        }
    }


    log_json!("Components upon core creation",
        utils::json_components(&component_nodes, &component_states));

    log_json!("Dependencies upon core creation",
        utils::json_dependencies(&dependencies));

    log_json!("Essential data upon core creation",
        utils::json_essential_data(&essential_data));


    Ok(DoenetCore {
        component_nodes,
        component_states,
        root_component_name,
        dependencies,
        essential_data,
        aliases,
    })
}


// fn generate_unused_variable_names(expression_string: &str, quantity_to_generate: usize) -> Vec<String> {

//     let mut names = Vec::new();
//     let mut counter = 0;
//     while names.len() < quantity_to_generate {
//         let possible_name = format!("_var{}", counter);
//         if !expression_string.contains(&possible_name) {
//             names.push(possible_name);
//         }
//         counter += 1;
//     }

//     names
// }


fn check_cyclic_copy_source_component(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,

) -> Option<DoenetMLError> {

    let mut current_comp = component;
    let mut chain = vec![];
    while let Some(CopySource::Component(ref source)) = current_comp.copy_source {

        if chain.contains(&current_comp.name) {
            // Cyclical dependency
            chain.push(current_comp.name.clone());

            let start_index = chain.iter().enumerate().find_map(|(index, name)| {
                if name == &current_comp.name {
                    Some(index)
                } else {
                    None
                }
            }).unwrap();

            let (_, relevant_chain) = chain.split_at(start_index);

            return Some(DoenetMLError::CyclicalDependency {
                component_chain: Vec::from(relevant_chain)
            });


        } else {

            chain.push(current_comp.name.clone());
            current_comp = components.get(source).unwrap();
        }
    }

    None
}

fn name_child_of_copy(child: &str, copy: &str) -> ComponentName {
    format!("__cp:{}({})", child, copy)
}

fn name_macro_component(
    source_name: &str,
    component_name: &String,
    copy_counter: &mut HashMap<ComponentName, usize>,
) -> String {
    let copy_num = copy_counter.entry(source_name.to_string()).or_insert(0);
    *copy_num += 1;

    format!("__mcr:{}({})_{}", source_name, component_name, copy_num)
}

fn add_alias_for_children(
    aliases: &mut HashMap<String, ComponentName>,
    component: &ComponentNode,
    component_nodes: &HashMap<ComponentName, ComponentNode>,
    copy: &String,
) {
    // log_debug!("Adding alias for children of {}", component.name);

    let children = get_children_including_copy(component_nodes, component);

    for (child, _) in children.iter() {
        if let ComponentChild::Component(child_comp) = child {
            aliases.insert(name_child_of_copy(child_comp, copy), child_comp.to_string());
        }
    }
}


/// Check for cyclical dependencies, assuming that we have already traversed through the
/// given dependency chain. This function might become slow for larger documents with lots of copies
fn check_for_cyclical_dependencies(
    dependencies: &HashMap<DependencyKey, Vec<Dependency>>,
    dependency_chain: &mut Vec<(ComponentName, StateVarSlice)>,
) -> Option<DoenetMLError> {

    // log_debug!("Dependency chain {:?}", dependency_chain);
    let last_link = dependency_chain.last().unwrap().clone();

    let my_dependencies = dependencies.iter().filter(|(dep_key, _)| {
        let DependencyKey::StateVar(comp, sv_slice, _) = dep_key;
        if comp == &last_link.0 && sv_slice == &last_link.1 {
            true
        } else {
            false
        }
    });

    for (_, dep_list) in my_dependencies {
        for dep in dep_list {
            let new_link = match dep {
                Dependency::StateVar { component_name, state_var_ref } => {
                    Some((component_name.clone(), StateVarSlice::Single(state_var_ref.clone())))
                },
                Dependency::StateVarArray { component_name, array_state_var_name } => {
                    Some((component_name.clone(), StateVarSlice::Array(array_state_var_name)))
                }
                _ => None,
            };

            if let Some(new_link) = new_link {
                if dependency_chain.contains(&new_link) {
                    // Cyclical dependency!!

                    dependency_chain.push(new_link.clone());
                    log_debug!("Cyclical dependency through {:?} with duplicate {:?}", dependency_chain, new_link);

                    let start_index = dependency_chain.iter().enumerate().find_map(|(index, item)| {
                        if item == &new_link {
                            Some(index)
                        } else {
                            None
                        }
                    }).unwrap();

                    let (_, relevant_chain) = dependency_chain.split_at(start_index);
                    let mut component_chain = vec![];
                    for link in relevant_chain.into_iter() {
                        if component_chain.is_empty() || component_chain.last().unwrap() != &link.0 {
                            component_chain.push(link.0.clone());
                        }
                    }

                    return Some(DoenetMLError::CyclicalDependency {
                        component_chain
                    });

                } else {
                    dependency_chain.push(new_link);
                    let possible_error = check_for_cyclical_dependencies(dependencies, dependency_chain);
                    dependency_chain.pop();

                    if let Some(error) = possible_error {
                        return Some(error);
                    }
                }
            }
        }
    }

    None
}




// One or two $ followed by either
//   - the following combination without parenthesis:
//     - a word (starting with a letter or underscore), capturing word as fourth group, 
//     - optionally followed by anything in square brackets (6th group)
//     - optionally followed by:
//       - a period
//       - followed by a word (9th group)
//       - optionally followed by anything in square brackets (11th group)
//   or
//   - the following combination in parenthesis
//     where the closing parenthesis could be replaced by an open brace,
//     (capturing the open brace or closing parens as 21st group):
//     - an identifier (containing word characters, slash, hyphen, or "../") (12th group)
//     - optionally followed by anything in square brackets (15th group)
//     - optionally followed by:
//       - a period
//       - followed by a word (including hyphens) (18th group)
//       - optionally followed by anything in square brackets (20th group)
lazy_static! {

    // NOTE: It took around ~100ms on a fast computer to create this regex (not including searching with it)
    static ref MACRO_SEARCH: Regex = Regex::new(r"(?x) #flag that ignores whitespace and comments

    (\$) # for now, just one $
    (
        (([a-zA-Z_]\w*)(\[([^\[^\]]+)\])?((\.([a-zA-Z]\w*))(\[([^\[^\]]+)\])?)?)
        |
        \(
            (([\w/-]|\.\./)+)(\[([^\[^\]]+)\])?((\.([\w\-]+))(\[([^\[^\]]+)\])?)?\s*
        ( \) | \{ )
    )

    ").unwrap();

}

lazy_static! {
    static ref POSSIBLE_MACRO: Regex = Regex::new("$").unwrap();
}

fn apply_macro_to_string(
    string: String,
    // component: &ComponentNode,
    component_name: &ComponentName,
    components: &HashMap<ComponentName, ComponentNode>,
    macro_copy_counter: &mut HashMap<ComponentName, usize>,
    components_to_add: &mut Vec<ComponentNode>,
) -> Vec<ObjectName> {

    let mut objects = Vec::new();
    let mut previous_end = 0;

    for capture in MACRO_SEARCH.captures_iter(&string) {

        log_debug!("capture {:#?}", capture);

        let start = capture.get(0).unwrap().start();
        let end = capture.get(0).unwrap().end();

        if start == 0 || string.chars().nth(start-1).unwrap_or_default() != '$' {

            // Append the regular string from last endpoint up until start of macro
            let before = &string[previous_end..start];
            if !before.trim().is_empty() {
                objects.push(ObjectName::String(before.to_string()));
            }


            let (macro_comp, macro_prop_option) =
                match capture.get(12) {
                    Some(comp) => (comp, capture.get(18)),
                    None => (capture.get(4).unwrap(), capture.get(9)),
                };

            if let Some(ending_delim) = capture.get(21) {
                if ending_delim.as_str() == "{" {
                    panic!("Haven't implemented macros with curly braces");
                }
            }

            let source_name = macro_comp.as_str();


            let source_comp = components.get(source_name).expect(
                &format!("Macro for {}, but this component does not exist", source_name));


            let macro_copy: ComponentNode = if let Some(macro_prop) = macro_prop_option {

                let (prop_name, _) = source_comp.definition.state_var_definitions
                    .get_key_value(macro_prop.as_str())
                    .expect(&format!("Macro asks for {} property, which does not exist", macro_prop.as_str()));

                let source_comp_sv_name = format!("{}:{}", source_name, prop_name);

                let copy_comp_type = default_component_type_for_state_var(source_comp, prop_name)
                    .expect(&format!("could not create component for state var copy macro"));
                let copy_def = COMPONENT_DEFINITIONS.get(copy_comp_type).unwrap().clone();

                let copy_name = name_macro_component(
                    &source_comp_sv_name,
                    component_name,
                    macro_copy_counter,
                );

                ComponentNode {
                    name: copy_name,
                    parent: Some(component_name.clone()),
                    children: vec![],

                    copy_source: Some(CopySource::StateVar(
                        // TODO: non-basic copies
                        source_comp.name.clone(), StateRef::Basic(prop_name))),

                    component_type: copy_comp_type,
                    definition: copy_def,
                }

            } else {

                let copy_name = name_macro_component(
                    source_name,
                    component_name,
                    macro_copy_counter,
                );

                ComponentNode {
                    name: copy_name,
                    parent: Some(component_name.clone()),
                    children: vec![],

                    copy_source: Some(CopySource::Component(source_comp.name.clone())),

                    .. source_comp.clone()
                }
            };

            objects.push(ObjectName::Component(macro_copy.name.clone()));
            components_to_add.push(macro_copy);

            previous_end = end;
        }

    }
    if previous_end > 0 {
        // There was at least one macro
        let last = &string[previous_end..];
        if !last.trim().is_empty() {
            objects.push(ComponentChild::String(last.to_string()));
        }

    } else {
        // No macros, just return the given string
        assert_eq!(objects.len(), 0);
        objects.push(ObjectName::String(string));
    }

    objects
}

fn parse_attributes_and_macros(
    components: &mut HashMap<ComponentName, ComponentNode>,
    attributes: HashMap<ComponentName, HashMap<AttributeName, String>>,
    copy_prop_index_instances: HashMap<ComponentName, (ComponentName, StateVarName, String)>,
) -> (
    HashMap<ComponentName, HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>>,
    HashMap<ComponentName, (ComponentName, StateVarName, Vec<ObjectName>)>,
    )
{

    use std::iter::repeat;

    // Keyed by the component name and by the original position of the child we are replacing
    let mut replacement_children: HashMap<ComponentName, HashMap<usize, Vec<ObjectName>>> = HashMap::new();
    let mut attributes_parsed = HashMap::new();
    let mut copy_index_flags_parsed = HashMap::new();

    let mut components_to_add: Vec<ComponentNode> = vec![];

    let mut macro_copy_counter: HashMap<ComponentName, usize> = HashMap::new();
    

    // This iterator gives info for every string child
    // (original index of child, string value, component)
    let all_string_children = components.iter()
        .flat_map(|(_, comp)|
            comp.children
            .iter()
            .enumerate()
            .filter_map(|(id, child)| {
                match child {
                    ObjectName::String(string_val) => Some((id, string_val)),
                    _ => None,
                }
            })
            .zip(repeat(comp))
            .map(|((id, val), comp)| (id, val, comp))
        );

    let all_attributes = attributes.iter()
        .flat_map(|(name, attrs)|
            attrs
            .iter()
            .map(|(attr_name, val)| (*attr_name, val, components.get(name).unwrap()))
            .collect::<Vec<(AttributeName, &String, &ComponentNode)>>()
        );

    // Component string children
    for (child_id, string_val, component) in all_string_children {

        let objects = apply_macro_to_string(
            string_val.clone(),
            &component.name,
            components,
            &mut macro_copy_counter,
            &mut components_to_add
        );

        // For now, replace everything in the children field
        replacement_children
            .entry(component.name.clone()).or_insert(HashMap::new())
            .entry(child_id).or_insert(objects);
    }

    // Attributes
    for (attribute_name, string_val, component) in all_attributes {

        // The reason this uses a HashMap of usizes instead of another Vec is because
        // later we might want to specify arrays of arrays in the attribute, so the key
        // might be more complicated than an integer.
        let objects: HashMap<usize, Vec<ObjectName>> = string_val.split(' ')
            .enumerate()
            .map(|(index, string_element)|

                // DoenetML is 1-indexed
                (index + 1,

                    apply_macro_to_string(
                        string_element.trim().to_string(),
                        &component.name,
                        components,
                        &mut macro_copy_counter,
                        &mut components_to_add,
                    )
                )
            ).collect();

        attributes_parsed
            .entry(component.name.clone()).or_insert(HashMap::new())
            .entry(attribute_name.clone()).or_insert(objects);
    }


    // Copy index flags
    for (target_name, (source_comp_name, source_sv_name, source_index_str)) in copy_prop_index_instances {
        
        let index_objects = apply_macro_to_string(
            source_index_str,
            &target_name,
            components,
            &mut macro_copy_counter,
            &mut components_to_add
        );

        copy_index_flags_parsed.insert(target_name, (source_comp_name, source_sv_name, index_objects));
    }




    log_debug!("Components to add from macros: {:#?}", components_to_add);

    for new_component in components_to_add {

        debug_assert!( !components.contains_key(&new_component.name) );
        components.insert(new_component.name.clone(), new_component);
    }


    log_debug!("Replacement children {:#?}", replacement_children);

    for (component_name, new_children_hashmap) in replacement_children {
        
        let component = components.get_mut(&component_name).unwrap();

        for (original_child_id, new_children) in new_children_hashmap {

            // Remove the original element, and add the new children (in order) in its place
            component.children.splice(
                original_child_id..original_child_id + 1,
                new_children
            );
        }
    }

    log_debug!("Replacement attributes {:#?}", attributes_parsed);

    (attributes_parsed, copy_index_flags_parsed)
}


fn default_component_type_for_state_var(component: &ComponentNode, state_var: StateVarName)
    -> Result<ComponentType, String> {

    let state_var_def = component.definition.state_var_definitions.get(state_var).unwrap();
    match state_var_def {
        StateVarVariant::Boolean(_) => Ok("boolean"),
        StateVarVariant::Integer(_) => Ok("number"),
        StateVarVariant::Number(_) => Ok("number"),
        StateVarVariant::String(_) => Ok("text"),
        StateVarVariant::NumberArray(_) => Err(
            format!("no component for NumberArray state variable")
        ),
    }
}


fn create_all_dependencies_for_component(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
    component_attributes: &HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>,
    // copy_index_flag: Option<&(ComponentName, StateVarName, Vec<ObjectName>)>,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
) -> HashMap<DependencyKey, Vec<Dependency>> {

    // log_debug!("Creating dependencies for {}", component.name);
    let mut dependencies: HashMap<DependencyKey, Vec<Dependency>> = HashMap::new();

    let my_definitions = component.definition.state_var_definitions;
    let mut unshadowing_definitions: HashMap<&StateVarName, &StateVarVariant>;

    if let Some(CopySource::DynamicElement(ref source_comp_name, source_sv_array_name, ref expression, ref variable_components)) = component.copy_source {
        // We can't immediately figure out the index, so we need to use the state
        // var propIndex

        let state_var_name = component.definition.primary_input_state_var.unwrap();

        dependencies.extend(
            create_prop_index_dependencies(component, state_var_name, source_comp_name, source_sv_array_name, expression, variable_components, essential_data)
        );

        unshadowing_definitions = my_definitions.iter().filter(|(key, _)| **key != state_var_name).collect();
    } else {
        unshadowing_definitions = my_definitions.iter().collect();
    }

    unshadowing_definitions.remove(&PROP_INDEX_SV);

    // log_debug!("Unshadowing definitions for {} {:?}", component.name, unshadowing_definitions);

    for (&state_var_name, state_var_variant) in unshadowing_definitions {

        if state_var_variant.is_array() {

            let size_dep_instructions = state_var_variant
                .return_size_dependency_instructions(HashMap::new());

            for (instruct_name, ref dep_instruction) in size_dep_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components,
                    component,
                    component_attributes,
                    &StateVarSlice::Single(StateRef::SizeOf(state_var_name)),
                    dep_instruction,
                    instruct_name,
                    essential_data,
                );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Single(StateRef::SizeOf(state_var_name)),
                        instruct_name
                    ),
                    instruct_dependencies,
                );

            }

            let array_dep_instructions = state_var_variant
                .return_array_dependency_instructions(HashMap::new());

            for (instruct_name, ref dep_instruction) in array_dep_instructions.into_iter() {
                let instruct_dependencies =
                    create_dependencies_from_instruction(
                        &components,
                        component,
                        component_attributes,
                        &StateVarSlice::Array(state_var_name),
                        dep_instruction,
                        instruct_name,
                        essential_data,
                    );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Array(state_var_name),
                        instruct_name,
                    ),
                    instruct_dependencies,
                );
            }

            // make dependencies for elements when size has an essential value
            let elements = {
                let size = essential_data
                    .get(&component.name)
                    .and_then(|c| c
                        .get(&EssentialDataOrigin::StateVar(state_var_name))
                        .and_then(|s| s
                            .get_value(StateIndex::SizeOf)
                            .and_then(|v|
                                usize::try_from(v).ok()
                            )
                        )
                    ).unwrap_or(0);

                indices_for_size(size)
            };


            for index in elements {

                let element_dep_instructions = state_var_variant
                    .return_element_dependency_instructions(index, HashMap::new());

                for (instruct_name, ref dep_instruction) in element_dep_instructions.into_iter() {
                    let instruct_dependencies =
                        create_dependencies_from_instruction(
                            &components,
                            component,
                            component_attributes,
                            &StateVarSlice::Array(state_var_name),
                            dep_instruction,
                            instruct_name,
                            essential_data,
                        );

                    dependencies.insert(
                        DependencyKey::StateVar(
                            component.name.clone(),
                            StateVarSlice::Single(StateRef::ArrayElement(state_var_name, index)),
                            instruct_name,
                        ),
                        instruct_dependencies,
                    );
                }
            }


        } else {

            let dependency_instructions = return_dependency_instructions_including_shadowing(component, &StateRef::Basic(state_var_name));

            for (instruct_name, ref dep_instruction) in dependency_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components,
                    component,
                    component_attributes,
                    &StateVarSlice::Single(StateRef::Basic(state_var_name)),
                    dep_instruction,
                    instruct_name,
                    essential_data
                );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Single(StateRef::Basic(state_var_name)),
                        instruct_name,
                    ),
                    instruct_dependencies   
                );
            }

        }
    }

    dependencies

}


/// This function also creates essential data when a DependencyInstruction asks for it.
/// The second return is element specific dependencies.
fn create_dependencies_from_instruction(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
    component_attributes: &HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>,
    state_var_slice: &StateVarSlice,
    instruction: &DependencyInstruction,
    instruction_name: InstructionName,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
) -> Vec<Dependency> {

    // log_debug!("Creating dependency {}:{}:{}", component.name, state_var_reference, instruction_name);

    let mut dependencies: Vec<Dependency> = Vec::new();

    match &instruction {

        DependencyInstruction::Essential => {

            let source_comp_name = get_essential_data_component_including_copy(components, component);
            let essential_origin = EssentialDataOrigin::StateVar(state_var_slice.name());

            if source_comp_name == component.name {
                // Components only create their own essential data

                let sv_def = component.definition.state_var_definitions.get(state_var_slice.name()).unwrap();

                let initial_data = if sv_def.is_array() {
                    InitialEssentialData::Array(Vec::new(), sv_def.initial_essential_value())
                } else {
                    InitialEssentialData::Single(sv_def.initial_essential_value())
                };
    
                create_essential_data_for(
                    &source_comp_name,
                    essential_origin.clone(),
                    initial_data,
                    essential_data
                );

            }

            dependencies.push(Dependency::Essential {
                component_name: source_comp_name,
                origin: essential_origin,
            });

        },

        DependencyInstruction::StateVar { component_name, state_var } => {

            let component_name = match component_name {
                Some(ref name) => name.to_string(),
                None => component.name.clone(),
            };

            dependencies.push(match state_var {

                StateVarSlice::Single(state_var_ref) => {
                    Dependency::StateVar {
                        component_name,
                        state_var_ref: state_var_ref.clone()
                    }
                },
                StateVarSlice::Array(array_state_var_name) => {
                    Dependency::StateVarArray {
                        component_name,
                        array_state_var_name,
                    }
                },
            });

        },

        DependencyInstruction::Child { desired_profiles } => {

            let children = get_children_including_copy(components, component);

            // if children.is_empty() {

            //     // With no children, this mirrors an essential data instruction.
            //     // Right now the essential data type is set to the variant type.
            //     // TODO: use profiles?
            //     let essential_origin = EssentialDataOrigin::StateVar(state_var_slice.name());

            //     create_essential_data_for(
            //         &component.name,
            //         essential_data
            //     );

            //     dependencies.push(Dependency::Essential {
            //         component_name: (), origin: ()
            //     });
            // }

            // Stores how many string children added per parent.
            let mut essential_data_numbering: HashMap<ComponentName, usize> = HashMap::new();

            for (child, actual_parent) in children.iter() {

                match child {
                    ComponentChild::Component(child_component_name) => {
                        let child_component = components.get(child_component_name).unwrap();

                        let mut selected_child_state_var = None;

                        for child_profile in child_component.definition.component_profiles.iter() {
                            if desired_profiles.contains(&child_profile.0) {
                                selected_child_state_var = Some(child_profile.1);
                                break;
                            }
                        }


                        if let Some(profile_state_var) = selected_child_state_var {

                            let sv_def = child_component.definition
                                .state_var_definitions
                                .get(profile_state_var)
                                .unwrap();

                            if sv_def.is_array() {
                                dependencies.push(Dependency::StateVarArray {
                                    component_name: child_component_name.to_string(),
                                    array_state_var_name: profile_state_var,
                                });

                            } else {
                                dependencies.push(Dependency::StateVar {
                                    component_name: child_component_name.to_string(),
                                    state_var_ref: StateRef::Basic(profile_state_var),
                                });

                            }

                        }

                    },

                    ComponentChild::String(string_value) => {
                        if desired_profiles.contains(&ComponentProfile::Text) {

                            let index = essential_data_numbering
                                .entry(actual_parent.name.clone()).or_insert(0 as usize);

                            let essential_origin = EssentialDataOrigin::ComponentChild(*index);

                            if component.name == actual_parent.name {
                                // Components create their own essential data
                                create_essential_data_for(
                                    &actual_parent.name,
                                    essential_origin.clone(),
                                    InitialEssentialData::Single(
                                        StateVarValue::String(string_value.clone()),
                                    ),
                                    essential_data
                                );
                            }

                            dependencies.push(Dependency::Essential {
                                component_name: actual_parent.name.clone(),
                                origin: essential_origin,
                            });

                            *index += 1;

                        }
                    },

                }
            }
            

        },
        DependencyInstruction::Parent { state_var } => {

            let desired_state_var = state_var;

            let parent_name = component.parent.clone().expect(&format!(
                "Component {} doesn't have a parent, but the dependency instruction {}:{} asks for one.",
                    component.name, state_var_slice, instruction_name
            ));

            let parent_component = components.get(&parent_name).unwrap();

            // Look up what kind of child state var it is
            // If the state var is an array, depend on the array, otherwise as normal

            let sv_def = parent_component.definition.state_var_definitions.get(desired_state_var).unwrap();

            if sv_def.is_array() {
                dependencies.push(Dependency::StateVarArray {
                    component_name: parent_name.to_string(),
                    array_state_var_name: desired_state_var,
                });

            } else {
                dependencies.push(Dependency::StateVar {
                    component_name: parent_name.to_string(),
                    state_var_ref: StateRef::Basic(desired_state_var),
                });

            }

        },


        DependencyInstruction::Attribute { attribute_name, index } => {

            log_debug!("Getting attribute {} for {}:{}", attribute_name, component.name, state_var_slice);

            let state_var_name = state_var_slice.name();
            let state_var_ref = StateRef::from_name_and_index(state_var_name, *index);
            let sv_def = component.definition.state_var_definitions.get(state_var_name).unwrap();
            let essential_origin = EssentialDataOrigin::StateVar(state_var_name);

            if let Some(attribute) = component_attributes.get(*attribute_name) {
                // attribute specified
                log_debug!("attribute {:?}", attribute);

                // Create the essential data if it does not exist yet
                if !essential_data_exists_for(&component.name, &essential_origin, essential_data) {

                    if sv_def.is_array() {

                        let mut essential_attr_objs: Vec<StateVarValue> = Vec::new();
                        
                        for (id, obj_list) in attribute {
                            let first_obj = obj_list.get(0).unwrap();
                            // ignore the other objects for now

                            let value = match first_obj {
                                ObjectName::String(str_val) => {
                                    package_string_as_state_var_value(str_val.to_string(), sv_def).unwrap()
                                }
                                _ => sv_def.initial_essential_value(),
                            };

                            if *id > essential_attr_objs.len() {
                                essential_attr_objs.resize(*id, sv_def.initial_essential_value());
                            }
                            essential_attr_objs[id - 1] = value;

                        }

                        log_debug!("essential attributes {:?}", essential_attr_objs);

                        let initial_essential_data = InitialEssentialData::Array(essential_attr_objs, sv_def.initial_essential_value());

                        create_essential_data_for(
                            &component.name,
                            essential_origin.clone(),
                            initial_essential_data,
                            essential_data,
                        );

                    } else {

                        assert_eq!(attribute.keys().len(), 1);

                        let initial_data = attribute.get(&1).unwrap().get(0).unwrap();

                        if let ObjectName::String(str) = initial_data {

                            create_essential_data_for(
                                &component.name,
                                essential_origin.clone(),
                                InitialEssentialData::Single(StateVarValue::String(str.to_string())),
                                essential_data,
                            );
                        };

                    };


                }


                if let StateIndex::SizeOf = index {

                    dependencies.push(Dependency::Essential {
                        component_name: component.name.clone(),
                        origin: essential_origin,
                    });
                
                } else {

                    let attribute_index = match index {
                        StateIndex::Element(i) => *i,
                        _ => 1,
                    };

                    // dependencies.push(Dependency::Essential {
                    //     component_name: component.name.clone(),
                    //     origin: essential_origin,
                    // });

                    let attr_objects = attribute.get(&attribute_index)
                        .expect(&format!("attribute {}:{} does not have index {}. Attribute: {:?}",
                            &component.name, attribute_name, &attribute_index, attribute));

                    let first_attr_object = attr_objects.get(0).unwrap();

                    let dependency = match first_attr_object {
                        ObjectName::String(_) => Dependency::Essential {
                            component_name: component.name.clone(),
                            origin: essential_origin,
                        },
                        ObjectName::Component(comp_name) => {
                            let comp = components.get(comp_name).unwrap();
                            let primary_input_sv = comp.definition.primary_input_state_var.expect(
                                &format!("An attribute cannot depend on a non-primitive component. Try adding '.value' to the macro.")
                            );

                            Dependency::StateVar {
                                component_name: comp_name.clone(),
                                state_var_ref: StateRef::Basic(primary_input_sv),
                            }
                        }
                    };

                    dependencies.push(dependency);

                    // let attr_string =
                    //     match attr_objects.first() {
                    //         Some(ObjectName::String(s)) => Some(s),
                    //         _ => None,
                    //     };

                    // log_debug!("attribute objects {:?} \nfirst attribute string {:?}", attr_objects, attr_string);

                    // if attr_objects.len() > 1 || attr_string.is_none() {
                    //     // depends on other state vars

                    //     for (piece, object_name) in attr_objects.into_iter().enumerate() {
                    //         match object_name {
                    //             ObjectName::String(s) => {
                                    
                    //                 let sv_def = component
                    //                     .definition
                    //                     .state_var_definitions
                    //                     .get(state_var_name).unwrap();

                    //                 let value = package_string_as_state_var_value(s.clone(), sv_def, index).unwrap();

                    //                 let dep = create_essential_data_for(
                    //                     component,
                    //                     EssentialDataOrigin::AttributeString(piece),
                    //                     &StateVarSlice::Single(state_var_ref.clone()),
                    //                     Some(value),
                    //                     essential_data,
                    //                 );

                    //                 dependencies.push(dep);
                    //             },
                    //             ObjectName::Component(s) => {
                    //                 let comp_def = components.get(s).unwrap().definition;
                    //                 let state_var_ref = StateRef::Basic(
                    //                     comp_def.primary_input_state_var.expect(
                    //                         &format!("An attribute cannot depend on a non-primitive component. Try adding '.value' to the macro.")
                    //                     ));

                    //                 dependencies.push(Dependency::StateVar {
                    //                     component_name: s.clone(),
                    //                     state_var_ref,
                    //                 })
                    //             },
                    //         }
                    //     }
                    // } else {
                    //     // This attribute does not depend on components

                    //     let state_var_def = component
                    //         .definition
                    //         .state_var_definitions
                    //         .get(state_var_name).unwrap();

                    //     let val = package_string_as_state_var_value(attr_string.unwrap().to_string(), state_var_def, &state_var_ref.index()).unwrap();

                    //     // let dep = create_essential_data_for(
                    //     //     component,
                    //     //     EssentialDataOrigin::StateVar(state_var_name),
                    //     //     &StateVarSlice::Single(state_var_ref),
                    //     //     Some(val),
                    //     //     essential_data
                    //     // );

                    //     dependencies.push(dep);
                    // }
                }
            } else if let Some(CopySource::Component(c)) = &component.copy_source {

                // inherit attribute from copy source
                dependencies.push(Dependency::StateVar {
                    component_name: c.clone(),
                    state_var_ref,
                });
            } else {

                create_essential_data_for(
                    &component.name,
                    EssentialDataOrigin::StateVar(state_var_name),
                    InitialEssentialData::Single(sv_def.initial_essential_value()),
                    essential_data
                );

                dependencies.push(Dependency::Essential {
                    component_name: component.name.clone(),
                    origin: essential_origin,
                });

            }
        },

    }
    dependencies
}



fn create_prop_index_dependencies(
    component: &ComponentNode,
    state_var_name: StateVarName,
    source_comp_name: &ComponentName,
    source_sv_array_name: StateVarName,
    math_expression: &MathExpression,
    variable_components: &Vec<ComponentName>,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
)
-> HashMap<DependencyKey, Vec<Dependency>> {
    use base_definitions::*;

    let mut dependencies = HashMap::new();

    // Dependency on propIndex for target component state var
    dependencies.insert(
        DependencyKey::StateVar(
            component.name.clone(),
            StateVarSlice::Single(StateRef::Basic(state_var_name)),
            SHADOW_INSTRUCTION_NAME
        ),
        vec![Dependency::StateVarArrayDynamicElement {
            component_name: source_comp_name.to_string(),
            array_state_var_name: source_sv_array_name,
            index_state_var: StateRef::Basic(PROP_INDEX_SV),
        }]
    );

    // Dependencies on source components for propIndex
    dependencies.insert(
        DependencyKey::StateVar(
            component.name.clone(),
            StateVarSlice::Single(StateRef::Basic(PROP_INDEX_SV)),
            PROP_INDEX_VARS_INSTRUCTION
        ),
        variable_components.iter().map(|comp_name| {
            Dependency::StateVar {
                component_name: comp_name.to_string(),
                state_var_ref: StateRef::Basic("value"),
            }
        }).collect()
    );

    // Dependency on math expression for propIndex
    dependencies.insert(
        DependencyKey::StateVar(
            component.name.clone(),
            StateVarSlice::Single(StateRef::Basic(PROP_INDEX_SV)),
            PROP_INDEX_EXPR_INSTRUCTION
        ),
        vec![create_essential_data_for(
            &component.name,
            EssentialDataOrigin::StateVar(PROP_INDEX_SV),
            InitialEssentialData::Single(StateVarValue::MathExpr(math_expression.clone())),
            essential_data,
        )]
    );

    dependencies
}


fn package_string_as_state_var_value(input_string: String, state_var_variant: &StateVarVariant) -> Result<StateVarValue, String> {


    let package_into_number_sv_value = |input_str| {
        if let Ok(val) = evalexpr::eval_number(input_str) {
            Ok(StateVarValue::Number(val))
        } else {
            Err(format!("Cannot package string {} as number", input_str))
        }
    };

    let package_into_integer_sv_value = |input_str| {
        if let Ok(val) = evalexpr::eval_int(input_str) {
            Ok(StateVarValue::Integer(val))
        } else {
            Err(format!("Cannot package string {} as integer", input_str))
        }
    };

    match state_var_variant {
        StateVarVariant::String(_) => {
            Ok(StateVarValue::String(input_string))
        },

        StateVarVariant::Boolean(_) => {

            if input_string == "true" {
                Ok(StateVarValue::Boolean(true))
            } else if input_string == "false" {
                Ok(StateVarValue::Boolean(false))
            } else {
                Err(format!("Cannot evaluate string {} as boolean", input_string))
            }
        },

        StateVarVariant::Integer(_) => {
            package_into_integer_sv_value(&input_string)
        },

        StateVarVariant::Number(_) => {
            package_into_number_sv_value(&input_string)
        },

        StateVarVariant::NumberArray(_) => {
            package_into_number_sv_value(&input_string)
        },
    }
}


enum InitialEssentialData {
    Single(StateVarValue),
    Array(Vec<StateVarValue>, StateVarValue),
}

/// Add (or update) essential data for a state variable or string child.
/// Returns the dependency.
fn create_essential_data_for(
    // component: &ComponentNode,
    component_name: &ComponentName,
    origin: EssentialDataOrigin,
    // state_var_slice: &StateVarSlice,
    // initialize_slice: Option<StateVarValue>,
    initial_values: InitialEssentialData,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
) -> Dependency {

    // log_debug!("adding essential data for {}:{}, setting to {:?}", component.name, state_var_slice, &initialize_slice);

    // let variant = match origin {
    //     EssentialDataOrigin::StateVar(name) => Some(component
    //         .definition.state_var_definitions
    //         .get(name).expect(
    //             &format!("{}:{} did not have a state var definition", component.name, name)
    //         )),
    //     _ => None,
    // };

    // let essential_state = match (state_var_slice, initialize_slice, variant) {

    //     (StateVarSlice::Single(StateRef::Basic(_)), Some(initial_val), _) => {
    //         EssentialStateVar::new_single_basic_with_state_var_value(initial_val)
    //     },

    //     (StateVarSlice::Single(state_ref), Some(val), Some(variant)) => {
    //         let essential = EssentialStateVar::new(Some(variant));
    //         essential.set_value(state_ref.index(), val).unwrap();
    //         essential
    //     },

    //     (StateVarSlice::Array(_), Some(initial_val), _) => {
    //         let essential = EssentialStateVar::new(variant);
    //         essential.set_value(StateIndex::Basic, initial_val).unwrap();
    //         essential
    //     },
    //     (_, _, _) => {
    //         let essential = EssentialStateVar::new(variant);
    //         essential
    //     },
    // };

    let essential_state = match initial_values {
        InitialEssentialData::Single(value) => EssentialStateVar::new_single_basic_with_state_var_value(value),
        InitialEssentialData::Array(values, default_fill_value) => EssentialStateVar::new_array_with_state_var_values(values, default_fill_value),
    };

    log_debug!("New essential data for {} {:?} {:?}", component_name, origin, essential_state);

    essential_data
        .entry(component_name.clone())
        .or_insert(HashMap::new())
        .entry(origin.clone())
        .or_insert(essential_state);

    Dependency::Essential {
        component_name: component_name.clone(),
        origin,
    }
}

fn essential_data_exists_for(
    component_name: &ComponentName,
    origin: &EssentialDataOrigin,
    essential_data: &HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>
) -> bool {

    if let Some(comp_essen) = essential_data.get(component_name) {
        if let Some(_) = comp_essen.get(origin) {
            true
        } else {
            false
        }
    } else {
        false
    }
}


/// Calculate all the (normal) state vars that depend on the given state var
fn get_state_variables_depending_on_me<'a>(
    core: &'a DoenetCore,
    sv_component_name: &ComponentName,
    sv_reference: &StateRef,
) -> Vec<(&'a ComponentName, &'a StateVarSlice)> {

    let mut depending_on_me = vec![];

    for (dependency_key, dependencies) in core.dependencies.iter() {

        for dependency in dependencies {

            match dependency {
                Dependency::StateVar { component_name, state_var_ref } => {
                    if component_name == sv_component_name
                    && state_var_ref == sv_reference {

                        let DependencyKey::StateVar(dependent_comp, dependent_group, _) = dependency_key;
                        depending_on_me.push((dependent_comp, dependent_group));
                    }
                },

                Dependency::StateVarArray { component_name, array_state_var_name } => {
                    // check if the state variables is in this group
                    if component_name == sv_component_name
                    && *array_state_var_name == sv_reference.name() {

                        let DependencyKey::StateVar(dependent_comp, dependent_group, _) = dependency_key;
                        depending_on_me.push((dependent_comp, dependent_group));
                    }
                },

                Dependency::StateVarArrayDynamicElement {
                    component_name,
                    array_state_var_name,
                    ..
                } => {

                    let this_array_refers_to_me = 
                        component_name == sv_component_name
                        && *array_state_var_name == sv_reference.name();

                    let i_am_prop_index_of_this_dependency = 
                        // The key that this dependency is under is myself
                        // Aka, the index is supposed to be in my component, not another component
                        dependency_key.component_name() == sv_component_name
                        // I am actually a propIndex, and not some other state var
                        && sv_reference == &StateRef::Basic("propIndex");

                    if this_array_refers_to_me || i_am_prop_index_of_this_dependency {

                        let DependencyKey::StateVar(dependent_comp, dependent_group, _) = dependency_key;
                        depending_on_me.push((dependent_comp, dependent_group));
                    }
    

                }

                // Essential and String dependencies are endpoints
                _ => {},

            }
        }
    }

    depending_on_me
}


// TODO: Use &Dependency instead of cloning
fn dependencies_of_state_var(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var_slice: &StateVarSlice,
) -> HashMap<InstructionName, Vec<Dependency>> {

    let deps = core.dependencies.iter().filter_map(| (key, deps) |

        match key {
            DependencyKey::StateVar(comp_name, sv_slice, instruct_name) => {

                // Check if the key is me
                if comp_name == &component.name {
                    if sv_slice == state_var_slice {
                        Some((*instruct_name, deps))

                    // The key might also be an array who feeds into me
                    } else if let StateVarSlice::Array(array_name) = sv_slice {
                        if state_var_slice.name() == *array_name {
                            Some((*instruct_name, deps))
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                } else {
                    None
                }
            },
        }
    );

    log_debug!("Deps for {}:{} with possible duplicates {:?}", component.name, state_var_slice, deps.clone().collect::<HashMap<InstructionName, &Vec<Dependency>>>());

    let mut combined: HashMap<InstructionName, Vec<Dependency>> = HashMap::new();
    for (k, v) in deps {
        if let Some(accum) = combined.get_mut(k) {
            let dedup: Vec<Dependency> = v.clone().into_iter().filter(|x| !accum.contains(x)).collect();
            accum.extend(dedup);
        } else {
            combined.insert(k, v.clone());
        }
    }
    
    log_debug!("Dependencies for {}:{} {:?}", component.name, state_var_slice, combined);

    combined
}


fn get_source_for_dependency(components: &HashMap<ComponentName, ComponentNode>, dependency: &Dependency) -> DependencySource {

    match dependency {
        Dependency::Essential { component_name, origin } => {
            // We don't really need these fields in this case (?)
            match origin {
                EssentialDataOrigin::StateVar(sv_name) => {
                    let variant = components
                        .get(component_name).unwrap()
                        .definition
                        .state_var_definitions
                        .get(sv_name).unwrap();
                    DependencySource::Essential {
                        value_type: match variant {
                            StateVarVariant::String(_) => "string",
                            StateVarVariant::Boolean(_) => "boolean",
                            StateVarVariant::Integer(_) => "integer",
                            StateVarVariant::NumberArray(_) |
                            StateVarVariant::Number(_) => "number",
                        }
                    }
                }
                _ => DependencySource::Essential{
                    value_type: "string",
                },
            
            }
        },

        Dependency::StateVar { component_name, state_var_ref } => {
            let component_type = components.get(component_name).unwrap().component_type;
            DependencySource::StateVar {
                component_type,
                state_var_name: state_var_ref.name()
            }
        },

        Dependency::StateVarArray { component_name, array_state_var_name } => {
            let component_type = components.get(component_name).unwrap().component_type;
            DependencySource::StateVar {
                component_type,
                state_var_name: &array_state_var_name,
            }
        },


        Dependency::StateVarArrayDynamicElement { component_name, array_state_var_name, .. } => {
            let component_type = components.get(component_name).unwrap().component_type;
            DependencySource::StateVar {
                component_type,
                state_var_name: &array_state_var_name
            }
            
        }

    }
}


fn get_dependency_sources_for_state_var(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var_slice: &StateVarSlice,
) -> HashMap<InstructionName, Vec<DependencySource>> {
    
    let my_dependencies = dependencies_of_state_var(core, component, state_var_slice);
    let mut dependency_sources: HashMap<InstructionName, Vec<DependencySource>> = HashMap::new();

    for (instruction_name, dependencies) in my_dependencies {
        let instruction_sources: Vec<DependencySource> = dependencies.iter().map(|dependency| {
            get_source_for_dependency(&core.component_nodes, &dependency)
        }).collect();

        dependency_sources.insert(instruction_name, instruction_sources);
    }

    dependency_sources
}

fn resolve_state_variable(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var_ref: &StateRef,
) -> Option<StateVarValue> {

    let state_vars = core.component_states.get(&component.name).unwrap();

    // No need to continue if the state var is already resolved or if the element does not exist
    let current_state = state_vars.get(state_var_ref.name()).unwrap().get_single_state(&state_var_ref.index())
        .expect(&format!("Error accessing state of {}:{:?}", component.name, state_var_ref));

    if let Some(State::Resolved(current_value)) = current_state {
        return Some(current_value);

    } else if current_state.is_none() {
        // There is nothing to resolve
        log_debug!("{}:{} does not exist", component.name, state_var_ref);
        return None
    }

    log_debug!("Resolving {}:{}", component.name, state_var_ref);

    let my_dependencies = dependencies_of_state_var(core, component, &StateVarSlice::Single(state_var_ref.clone()));

    log_debug!("Dependencies of {}:{} {:?}", component.name, state_var_ref, my_dependencies);

    let mut dependency_values: HashMap<InstructionName, Vec<DependencyValue>> = HashMap::new();

    for (dep_name, deps) in my_dependencies {

        let mut values_for_this_dep: Vec<DependencyValue> = Vec::new();

        for dep in deps {

            let dependency_source = get_source_for_dependency(&core.component_nodes, &dep);

            match dep {

                Dependency::StateVar { component_name, state_var_ref } => {

                    let depends_on_component = core.component_nodes.get(&component_name).unwrap();
                    let depends_on_value = resolve_state_variable(core, depends_on_component, &state_var_ref);

                    if let Some(depends_on_value) = depends_on_value {
                        values_for_this_dep.push(DependencyValue {
                            source: dependency_source,
                            value: depends_on_value.clone(),
                        });    
                    }

                },

                Dependency::Essential { component_name, origin } => {

                    let index = match origin {
                        EssentialDataOrigin::StateVar(_) => state_var_ref.index(),
                        _ => StateIndex::Basic,
                    };

                    let value = core.essential_data
                        .get(&component_name).unwrap()
                        .get(&origin).unwrap()
                        .clone()
                        .get_value(index);
    
                    if let Some(value) = value {
                        values_for_this_dep.push(DependencyValue {
                            source: dependency_source,
                            value,
                        })
                    }
                },

                Dependency::StateVarArray { component_name, array_state_var_name } => {

                    let depends_on_component = core.component_nodes.get(&component_name).unwrap();

                    // important to resolve the size before the elements
                    let size_value = resolve_state_variable(
                        core,
                        depends_on_component,
                        &StateRef::SizeOf(array_state_var_name)
                    ).expect("Array size should always resolve to a StateVarValue");

                    let size = usize::try_from(size_value).unwrap();
                    
                    for id in indices_for_size(size) {

                        let element_value = resolve_state_variable(
                            core,
                            depends_on_component,
                            &StateRef::ArrayElement(array_state_var_name, id)
                        );

                        if let Some(element_value) = element_value {
                            values_for_this_dep.push(DependencyValue {
                                source: dependency_source.clone(),
                                value: element_value.clone(),
                            });
    
                        }
    
                    }
                },


                Dependency::StateVarArrayDynamicElement { component_name, array_state_var_name, index_state_var } => {

                    let index_value = resolve_state_variable(
                        core,
                        component, // myself
                        &index_state_var,
                    );

                    let index: Option<usize> = if let Some(index_value) = index_value {

                        let index_num: f64 = index_value.try_into().unwrap();
                        convert_float_to_usize(index_num)

                    } else {
                        None
                    };

                    if let Some(index) = index {

                        log_debug!("got prop index which is {}", index);

                        let depends_on_component = core.component_nodes.get(&component_name).unwrap();

                        let element_value = resolve_state_variable(
                            core,
                            depends_on_component,
                            &StateRef::ArrayElement(array_state_var_name, index)
                        );

                        log_debug!("element value is {:?}", element_value);

                        if let Some(element_value) = element_value {
                            values_for_this_dep.push(DependencyValue {
                                source: dependency_source,
                                value: element_value.clone(),
                            });
                        }
                    }





                }
            }
        }

        dependency_values.insert(dep_name, values_for_this_dep);
    }


    log_debug!("Dependency values for {}:{}: {:#?}", component.name, state_var_ref, dependency_values);

    let update_instruction = generate_update_instruction_including_shadowing(
        component, state_var_ref, dependency_values
    ).expect(&format!("Can't resolve {}:{} (a {} component type)",
        component.name, state_var_ref, component.component_type)
    );

    let new_value = handle_update_instruction(component, state_vars, state_var_ref, update_instruction);

    return new_value;
}

/// This must resolve the size
fn elements_of_array(
    core: &DoenetCore,
    component: &ComponentNode,
    sv_name: &StateVarName,
) -> Vec<StateRef> {
    let size_ref = StateRef::SizeOf(sv_name);
    let size: usize = resolve_state_variable(core, component, &size_ref)
        .unwrap()
        .try_into()
        .unwrap();

    indices_for_size(size).map(|i| StateRef::ArrayElement(sv_name, i)).collect()
}

fn references_from_group(
    core: &DoenetCore,
    sv_component: &ComponentNode,
    sv_name: &StateVarName,
) -> Vec<StateRef> {

    let state_var = core.component_states.get(&sv_component.name).unwrap().get(sv_name).unwrap();

    let existing_elements = indices_for_size(state_var.elements_len())
        .map(|i|
            StateRef::ArrayElement(sv_name, i)
        );

    let specific_deps = core.dependencies.iter().filter_map(| (key, _) | {
        match key {
            DependencyKey::StateVar(_, StateVarSlice::Single(StateRef::SizeOf(s)), _) => {
                Some(StateRef::SizeOf(s))
            },
            DependencyKey::StateVar(_, StateVarSlice::Single(StateRef::ArrayElement(s, i)), _) => {    
                Some(StateRef::ArrayElement(s, *i))
            }
            _ => None,
        }
    });

    // combine vectors without redundancy
    let mut all_elements = Vec::new();
    for elem in existing_elements.chain(specific_deps) {
        if !all_elements.contains(&elem) {
            all_elements.push(elem);
        }
    }
    all_elements
}


fn mark_stale_state_var_and_dependencies(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var_ref: &StateRef,
) {
    let component_state = core.component_states.get(&component.name).unwrap();
    let state_var = component_state.get(state_var_ref.name()).unwrap();

    // No need to continue if the state var is already stale
    let state = state_var.get_single_state(&state_var_ref.index())
        .expect(&format!("Error accessing state of {}:{:?}", component.name, state_var_ref));

    if state == Some(State::Stale) {
        return;
    }

    log_debug!("Marking stale {}:{}", component.name, state_var_ref);

    state_var.mark_single_stale(&state_var_ref.index());

    let depending_on_me = get_state_variables_depending_on_me(core, &component.name, state_var_ref);
    
    for (depending_comp_name, depending_group) in depending_on_me {
        let depending_comp = core.component_nodes.get(depending_comp_name).unwrap();

        match depending_group {
            StateVarSlice::Single(sv_ref) => {
                mark_stale_state_var_and_dependencies(core, depending_comp, &sv_ref);
            },
            StateVarSlice::Array(sv_name) => {
                let members = references_from_group(core, component, &sv_name);
                for member in members {
                    mark_stale_state_var_and_dependencies(core, depending_comp, &member);
                }
            }
        }
    }
}




fn mark_stale_essential_datum_dependencies(
    core: &DoenetCore,
    component_name: ComponentName,
    state_index: &StateIndex,
    origin: EssentialDataOrigin,
) {

    // log_debug!("Marking stale essential {}:{}", component_name, state_var);

    let search_dep = Dependency::Essential {
        component_name,
        origin,
    };

    let my_dependencies = core.dependencies.iter().filter_map( |(key, deps) | {
        if deps.contains(&search_dep) {

            match key {
                DependencyKey::StateVar(comp_name, StateVarSlice::Single(s), _) => Some((comp_name, s.clone())),
                DependencyKey::StateVar(comp_name, StateVarSlice::Array(array), _) => {

                    match state_index {
                        StateIndex::Element(i) =>
                            Some((comp_name, StateRef::ArrayElement(array, *i))),
                        StateIndex::SizeOf =>
                            Some((comp_name, StateRef::SizeOf(array))),
                        StateIndex::Basic =>
                            // Arrays cannot use essential data
                            // associated with a basic state var.
                            None,
                    }
                }
            }

        } else {
            None
        }
    });

    for (component_name, state_var_ref) in my_dependencies {
        let component = core.component_nodes.get(component_name).unwrap();
        mark_stale_state_var_and_dependencies(core, &component, &state_var_ref);
    }
}



/// Sets the state var and returns the new value
fn handle_update_instruction<'a>(
    component: &'a ComponentNode,
    component_state_vars: &HashMap<StateVarName, StateForStateVar>,
    state_var_ref: &StateRef,
    instruction: StateVarUpdateInstruction<StateVarValue>
) -> Option<StateVarValue> {

    let state_var = component_state_vars.get(state_var_ref.name()).unwrap();

    let updated_value: Option<StateVarValue>;

    match instruction {
        StateVarUpdateInstruction::NoChange => {
            let current_value = component_state_vars.get(state_var_ref.name()).unwrap()
                .get_single_state(&state_var_ref.index())
                .expect(&format!("Error accessing state of {}:{:?}", component.name, state_var_ref));

            if let Some(State::Stale) = current_value {
                panic!("Cannot use NoChange update instruction on a stale value");

            } else if let Some(State::Resolved(current_resolved_value)) = current_value {
                // Do nothing. It's resolved, so we can use it as is
                updated_value = Some(current_resolved_value);

            } else {
                updated_value = None;
            };

        },
        StateVarUpdateInstruction::SetValue(new_value) => {

            updated_value = state_var.set_single_state(&state_var_ref.index(), new_value.clone()).unwrap();
            // .expect(&format!("Failed to set {}:{} while handling SetValue update instruction", component.name, state_var_ref)
            // );

        }

    };

    log_debug!("Updated {}:{} to {:?}", component.name, state_var_ref, updated_value);

    return updated_value;
}





#[derive(Debug)]
pub struct Action {
    pub component_name: ComponentName,
    pub action_name: String,

    /// The keys are not state variable names.
    /// They are whatever name the renderer calls the new value.
    pub args: HashMap<String, StateVarValue>,
}


/// Internal structure used to track changes
#[derive(Debug, Clone)]
enum UpdateRequest {
    SetEssentialValue(ComponentName, EssentialDataOrigin, StateIndex, StateVarValue),
    SetStateVar(ComponentName, StateRef, StateVarValue),
}


/// Among other things, this produces info about the component name based on
/// the dependency instruction.
fn convert_dependency_values_to_update_request(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var: &StateRef,
    requests: HashMap<InstructionName, Result<Vec<DependencyValue>, String>>,
) -> Vec<UpdateRequest> {

    let my_dependencies = dependencies_of_state_var(core, component, &StateVarSlice::Single(state_var.clone()));


    requests.iter()
        .flat_map(|(instruction_name, values)|
            match values {
                Ok(values) => {

                    values.iter()
                    .flat_map(|value|
                        my_dependencies.get(instruction_name).expect(
                            &format!("{}:{} has the wrong instruction name to determine dependencies",
                                component.component_type, state_var)
                        )
                        .iter()
                        .filter_map(|instruction|
                            match instruction {
                                Dependency::Essential { component_name, origin } => {
                                    Some(UpdateRequest::SetEssentialValue(
                                        component_name.clone(),
                                        origin.clone(),
                                        state_var.index(),
                                        value.value.clone(),
                                    ))
                                },
                                Dependency::StateVar { component_name, state_var_ref } => {
                                    Some(UpdateRequest::SetStateVar(
                                        component_name.clone(),
                                        state_var_ref.clone(),
                                        value.value.clone(),
                                    ))
                                },
                                _ => None,
                            }
                        ).collect::<Vec<UpdateRequest>>()
                    ).collect::<Vec<UpdateRequest>>()
                },
                Err(e) => {
                    log_debug!("Inverse definition for {}:{} failed with: {}", component.name, state_var, e);
                    vec![]
                },
            }
        ).collect()
}


pub fn handle_action_from_json(core: &DoenetCore, action: &str) -> String {

    let (action, action_id) = parse_json::parse_action_from_json(action)
        .expect(&format!("Error parsing json action: {}", action));

    handle_action(core, action);

    action_id
}

pub fn handle_action(core: &DoenetCore, action: Action) {

    log_debug!("Handling action {:#?}", action);

    // Apply alias to get the original component name
    let component_name = core.aliases.get(&action.component_name).unwrap_or(&action.component_name);

    let component = core.component_nodes.get(component_name)
        .expect(&format!("{} doesn't exist, but action {} uses it", action.component_name, action.action_name));

    let state_var_resolver = | state_var_ref | {
        resolve_state_variable(core, component, state_var_ref)
    };

    let state_vars_to_update = (component.definition.on_action)(
        &action.action_name,
        action.args,
        &state_var_resolver,
    );

    for (state_var_ref, requested_value) in state_vars_to_update {

        let request = UpdateRequest::SetStateVar(component_name.clone(), state_var_ref.clone(), requested_value);
        process_update_request(core, &request);
    }

    // log_json!("Component tree after action", utils::json_components(&core.component_nodes, &core.component_states));
}


fn process_update_request(
    core: &DoenetCore,
    update_request: &UpdateRequest
) {

    // log_debug!("Processing update request {:?}", update_request);

    match update_request {
        UpdateRequest::SetEssentialValue(component_name, origin, state_index, requested_value) => {

            let essential_var = core.essential_data
                .get(component_name).unwrap()
                .get(origin).unwrap();

            essential_var.set_value(
                    state_index.clone(),
                    requested_value.clone()
                ).expect(
                    &format!("Failed to set essential value for {}, {:?}", component_name, origin)
                );

            // log_debug!("Updated essential data {:?}", core.essential_data);

            mark_stale_essential_datum_dependencies(core, component_name.clone(), state_index, origin.clone());
        },

        UpdateRequest::SetStateVar(component_name, state_var_ref, requested_value) => {

            let dep_comp = core.component_nodes.get(component_name).unwrap();

            let dep_update_requests = request_dependencies_to_update_value_including_shadow(
                core,
                dep_comp,
                state_var_ref,
                requested_value.clone(),
            );

            for dep_update_request in dep_update_requests {
                process_update_request(core, &dep_update_request);
            }

            let component = core.component_nodes.get(component_name).unwrap();
            mark_stale_state_var_and_dependencies(core, component, &state_var_ref);
        }
    }
}





pub fn update_renderers(core: &DoenetCore) -> String {
    let json_obj = generate_render_tree(core);

    log_json!("Component tree after renderer update", utils::json_components(&core.component_nodes, &core.component_states));

    serde_json::to_string(&json_obj).unwrap()
}


fn generate_render_tree(core: &DoenetCore) -> serde_json::Value {

    let root_node = core.component_nodes.get(&core.root_component_name).unwrap();
    let mut json_obj: Vec<serde_json::Value> = vec![];

    generate_render_tree_internal(core, root_node, &mut json_obj, None);

    serde_json::Value::Array(json_obj)
}

fn generate_render_tree_internal(
    core: &DoenetCore,
    component: &ComponentNode,
    json_obj: &mut Vec<serde_json::Value>,
    came_from_copy: Option<&ComponentName>,
) {
    use serde_json::json;

    let state_vars = component.definition.state_var_definitions;

    let renderered_state_vars = state_vars.into_iter().filter(|kv| kv.1.for_renderer());

    let mut state_values = serde_json::Map::new();
    for (name, variant) in renderered_state_vars {

        if variant.is_array() {

            // TODO: not the best way to do this?
            let sv_refs = elements_of_array(core, component, name);

            let mut values: Vec<f64> = Vec::new();
            for sv_ref in sv_refs {
                values.push(
                    resolve_state_variable(core, component, &sv_ref)
                    .unwrap()
                    .try_into()
                    .unwrap()
                );
            }

            state_values.insert(name.to_string(), json!(values));

        } else {
            let state_var_value = resolve_state_variable(core, component, &StateRef::Basic(name)).unwrap();

            if *name == "selectedStyle" || *name == "graphicalDescendants" {
                if let StateVarValue::String(v) = state_var_value {
                    // log_debug!("deserializing for renderer: {}", v);
                    let value = serde_json::from_str(&v).unwrap();
                    state_values.insert(name.to_string(), value);
                }
            } else {
                state_values.insert(name.to_string(), state_var_value.into());
            }
        }
    }

    let name_to_render = match &came_from_copy {
        Some(copy_name) => name_child_of_copy(&component.name, &copy_name),
        None => component.name.clone(),
    };

    let mut children_instructions = Vec::new();
    if component.definition.should_render_children {

        let children = get_children_including_copy(&core.component_nodes, component);

        for (child, actual_parent) in children {
            match child {
                ComponentChild::Component(comp_name) => {
                    // recurse for children
                    let comp = core.component_nodes.get(&comp_name).unwrap();
                    
                    let child_came_from_copy =
                        came_from_copy.or(
                            if std::ptr::eq(actual_parent, component) {
                                None
                            } else {
                                Some(&component.name)
                            });

                    generate_render_tree_internal(core, comp, json_obj, child_came_from_copy); 

                    let mut child_actions = serde_json::Map::new();

                    for action_name in (comp.definition.action_names)() {
                        child_actions.insert(action_name.to_string(), json!({
                            "actionName": action_name,
                            "componentName": comp.name,
                        }));
                    }

                    let renderer_type = match comp.definition.renderer_type {
                        RendererType::Special(name) => name,
                        RendererType::Myself => comp.component_type,
                    };

                    children_instructions.push(json!({
                        "actions": child_actions,
                        "componentName": comp.name,
                        "componentType": comp.component_type,
                        "effectiveName": comp.name,
                        "rendererType": renderer_type,
                    }));
                },
                ComponentChild::String(string) => {
                    children_instructions.push(json!(string));
                },
            }
        }
    }

    json_obj.push(json!({
        "componentName": name_to_render,
        "stateValues": serde_json::Value::Object(state_values),
        "childrenInstructions": json!(children_instructions),
    }));

}




////////////// Wrappers providing for CopySource and sequence component //////////////


/// This includes the copy source's children.
fn get_children_including_copy<'a>(
    components: &'a HashMap<ComponentName, ComponentNode>,
    component: &'a ComponentNode,
) -> Vec<(ComponentChild, &'a ComponentNode)> {

    // log_debug!("Getting children for {}", component.name);

    let mut children_vec: Vec<(ComponentChild, &ComponentNode)> = Vec::new();
    if let Some(CopySource::Component(ref source)) = component.copy_source {

        let source_comp = components.get(source).unwrap();
        children_vec = get_children_including_copy(components, source_comp)
    }

    children_vec.extend(
        component.children
        .iter()
        .map(|c| (c.clone(), component))
    );

    children_vec
}


/// Recurse until the name of the original source is found.
/// This allows copies to share essential data.
fn get_essential_data_component_including_copy(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
) -> ComponentName {
    match &component.copy_source {
        Some(CopySource::Component(source)) =>
            get_essential_data_component_including_copy(components, components.get(source).unwrap()),
        _ => component.name.clone(),
    }
}


const SHADOW_INSTRUCTION_NAME: &'static str = "shadow_instruction";


fn return_dependency_instructions_including_shadowing(
    // copy_index_flag: &Option<(ComponentName, StateVarName, String)>,
    component: &ComponentNode,
    state_var: &StateRef,
) -> HashMap<InstructionName, DependencyInstruction> {

    if false {
    // if let Some((source_comp_name, source_sv_name, source_index_str)) = copy_index_flag {

        // HashMap::from([
        //     (SHADOW_INSTRUCTION_NAME, DependencyInstruction::StateVarArrayDynamicElement {
        //         component_name: source_comp_name.to_string(),
        //         state_var: &source_sv_name,
        //         index_state_var: source_index_str.to_string(),
        //     })
        // ])

        HashMap::new()

    } else if let Some((source_comp, source_state_var)) = state_var_is_shadowing(component, state_var) {

        HashMap::from([
            (SHADOW_INSTRUCTION_NAME, DependencyInstruction::StateVar {
                component_name: Some(source_comp), //.clone(),
                state_var: source_state_var,
            })
        ])

    } else {
        let state_var_def = component.definition.state_var_definitions.get(state_var.name()).unwrap();

        match state_var {
            StateRef::Basic(_) => {
                state_var_def.return_dependency_instructions(HashMap::new())
            },
            StateRef::SizeOf(_) => {
                state_var_def.return_size_dependency_instructions(HashMap::new())
            },
            StateRef::ArrayElement(_, id) => {
                state_var_def.return_element_dependency_instructions(*id, HashMap::new())
            }
        }
    }
}



/// This determines the state var given its dependency values.
fn generate_update_instruction_including_shadowing(
    component: &ComponentNode,
    state_var: &StateRef,
    dependency_values: HashMap<InstructionName, Vec<DependencyValue>>

) -> Result<StateVarUpdateInstruction<StateVarValue>, String> {

    if state_var_is_shadowing(component, state_var).is_some() {

        // Assuming that source state var is same type as this state var
        let source_value = dependency_values.dep_value(SHADOW_INSTRUCTION_NAME)?
            .has_zero_or_one_elements()?
            .value();
        
        let new_value = source_value.unwrap_or(
            match component.definition.state_var_definitions.get(state_var.name()).unwrap() {
                StateVarVariant::Integer(_) => StateVarValue::Integer(i64::default()),
                StateVarVariant::Number(_) => StateVarValue::Number(f64::default()),
                StateVarVariant::NumberArray(_) => StateVarValue::Number(f64::default()),
                StateVarVariant::String(_) => StateVarValue::String(String::default()),
                StateVarVariant::Boolean(_) => StateVarValue::Boolean(bool::default()),
            }
        );

        Ok(StateVarUpdateInstruction::SetValue(new_value))

    } else {
        // Otherwise, this state var is not shadowing, so proceed normally
        let state_var_def = component.definition.state_var_definitions.get(state_var.name()).unwrap();

        match state_var {
            StateRef::Basic(_) => {
                state_var_def.determine_state_var_from_dependencies(dependency_values)
            },
            StateRef::SizeOf(_) => {
                state_var_def.determine_size_from_dependencies(dependency_values)
            },
            StateRef::ArrayElement(_, id) => {
                let internal_id = id - 1;
                state_var_def.determine_element_from_dependencies(internal_id, dependency_values)
            }
        }

    }
}



fn request_dependencies_to_update_value_including_shadow(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var_ref: &StateRef,
    new_value: StateVarValue,
) -> Vec<UpdateRequest> {

    if let Some((source_comp, source_state_var)) = state_var_is_shadowing(component, state_var_ref) {

        let source_ref = match source_state_var {
            StateVarSlice::Single(sv_ref) => sv_ref,
            StateVarSlice::Array(_) => panic!()
        };

        vec![UpdateRequest::SetStateVar(source_comp, source_ref, new_value)]

    } else {
        let dependency_sources = get_dependency_sources_for_state_var(core, component, &StateVarSlice::Single(state_var_ref.clone()));

        log_debug!("Dependency sources for {}{}, {:?}", component.name, state_var_ref, dependency_sources);

        let requests = component.definition.state_var_definitions.get(state_var_ref.name()).unwrap()
            .request_dependencies_to_update_value(state_var_ref, new_value, dependency_sources);

        convert_dependency_values_to_update_request(core, component, state_var_ref, requests)
    }
}

/// Detect if a state var is shadowing because of a CopySource
/// and has a primary input state variable, which is needed.
fn state_var_is_shadowing(component: &ComponentNode, state_var: &StateRef)
    -> Option<(ComponentName, StateVarSlice)> {

    if let Some(CopySource::StateVar(ref source_comp, ref source_state_var)) = component.copy_source {
        if let Some(primary_input_state_var) = component.definition.primary_input_state_var {

            if state_var == &StateRef::Basic(primary_input_state_var) {
                Some((source_comp.to_string(), StateVarSlice::Single(source_state_var.clone())))
            } else {
                None
            }
        } else {
            panic!("{} component type doesn't have a primary input state var", component.component_type);
        }

    } else if let Some(CopySource::DynamicElement(ref source_comp, ref source_state_var, ..)) = component.copy_source {
        if let Some(primary_input_state_var) = component.definition.primary_input_state_var {

            if state_var == &StateRef::Basic(primary_input_state_var) {

                Some((source_comp.to_string(), StateVarSlice::Array(source_state_var)))
            } else {
                None
            }
        } else {
            panic!("{} component type doesn't have a primary input state var", component.component_type);
        }


    } else {
        None
    }
}


fn convert_float_to_usize(f: f64) -> Option<usize> {
    let my_int = f as i64;
    if my_int as f64 == f {
        // no loss of precision
        usize::try_from(my_int).ok()
    } else {
        None
    }
}


fn indices_for_size(size: usize) -> std::ops::Range<usize> {
    1..size+1
}