
pub mod state_variables;
pub mod component;

pub mod state;
pub mod parse_json;
pub mod utils;
pub mod base_definitions;

use lazy_static::lazy_static;
use parse_json::DoenetMLError;
use state::StateForStateVar;
use std::collections::HashMap;
use std::fmt::Debug;
use regex::Regex;

use state::{State, EssentialStateVar};
use component::*;
use state_variables::*;

use crate::utils::{log_json, log_debug};


/// A static DoenetCore is created from parsed DoenetML at the beginning.
/// While `component_states` and `essential_data` can update using
/// internal mutability (the RefCell), the over-arching HashMaps are static.
#[derive(Debug)]
pub struct DoenetCore {
    /// The component tree has almost the same structute as the tree of elements
    /// typed into DoenetML. The exceptions are that attributes and macros
    /// are converted into their own components.
    pub component_nodes: HashMap<ComponentName, ComponentNode>,

    /// This is keyed by `StateVarName` rather than `StateVarReference`
    /// so that it is static even when arrays change size.
    pub component_states: HashMap<ComponentName, HashMap<StateVarName, StateForStateVar>>,

    pub root_component_name: ComponentName,

    /// The Dependency Graph
    /// A DAC whose vertices are the state variables and attributes
    /// of every component, and whose endpoint vertices are:
    /// - strings (typed into the DoenetML)
    /// - essential data (generated by dependency instructions)
    pub dependencies: HashMap<DependencyKey, Vec<Dependency>>,

    /// States that the user can change (e.g. the contents of an input dialogue).
    /// Each datum is associated with the state variable of a particular component.
    pub essential_data: HashMap<ComponentName, HashMap<StateVarName, EssentialStateVar>>,

    /// We send components to the renderer that do not exists:
    /// - the inherited children of a copy
    ///
    /// The renderer needs to recognize these as a different component so we alias its name.
    /// This maps the name the renderer is given to the actual name.
    pub aliases: HashMap<String, ComponentName>,
}


/// State variables are keyed by:
/// 1. the name of the component
/// 2. the name of a state variable group
///    which allows for two kinds of dependencies:
///      - direct dependency: when a single state var depends on something
///      - indirect dependency: when a group depends on something,
///        and members of the group inherit the dependency.
///        The motivation for indirect dependencies is that
///        the size of groups can change (e.g. an array changes size).
///        To keep the dependency graph static, we do not update
///        individual dependencies but simply apply the group dependency.
/// 3. the instruction name, given by the state variable to track where
///    dependecy values came from.
#[derive(Debug, Hash, PartialEq, Eq, serde::Serialize)]
pub enum DependencyKey {
    StateVar(ComponentName, StateVarSlice, InstructionName),
}

impl DependencyKey {
    fn component_name(&self) -> &str {
        match self {
            DependencyKey::StateVar(name, _, _) => name,
        }
    }
}


/// A collection of edges on the dependency tree
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize)]
pub enum Dependency {
    StateVar {
        component_name: ComponentName,
        state_var_ref: StateRef,
    },
    Essential {
        component_name: ComponentName,
        state_var_name: StateVarName,
    },

    String {
        value: String,
    },

    /// This represents multiple edges on the dependency graph,
    /// since it references multiple state variables.
    StateVarArray {
        component_name: String,
        array_state_var_name: StateVarName,
    },
}



const SHADOW_INSTRUCTION_NAME: &'static str = "shadow_instruction";




pub fn create_doenet_core(program: &str) -> Result<DoenetCore, DoenetMLError> {

    // Create component nodes.
    let (mut component_nodes, root_component_name) = 
        parse_json::create_components_tree_from_json(program)?;

    // Parse macros and generate components from them
    replace_macros_with_copies(&mut component_nodes);



    let copies: Vec<(&ComponentNode, &ComponentName)> = component_nodes.iter().filter_map(|(_, c)|
        match c.copy_source {
            Some(CopySource::Component(ref source)) => Some((c, source)),
            _ => None,
        }
    ).collect();


    // Check for invalid names in CopySource::Components here
    for (_, source_comp_name) in copies.iter() {
        if !component_nodes.contains_key(*source_comp_name) {
            // The component tried to copy a non-existent component.
            return Err(DoenetMLError::ComponentDoesNotExist {
                comp_name: source_comp_name.to_string()
            });
        }
    }

    // Check for cyclical dependencies due to CopySource::Component.
    // If we don't do this, then alias and dependency generation will crash.
    for (copy_component, _) in copies.iter() {
        if let Some(cyclic_error) = check_cyclic_copy_source_component(&component_nodes, copy_component) {
            return Err(cyclic_error);
        }
    }

    // For every copy, add the necessary aliases for the renderers to use
    let mut aliases: HashMap<String, ComponentName> = HashMap::new();
    for (copy, _) in copies {
        add_alias_for_children(&mut aliases, copy, &component_nodes, &copy.name);
    }


    // Fill in component_states and dependencies HashMaps for every component
    // and supply essential_data required by any Essential Dependency.

    let mut component_states = HashMap::new();
    let mut dependencies = HashMap::new();
    let mut essential_data = HashMap::new();

    for (component_name, component_node) in component_nodes.iter() {

        let dependencies_for_this_component = create_all_dependencies_for_component(
            &component_nodes,
            component_node,
            &mut essential_data
        );

        let state_for_this_component: HashMap<StateVarName, StateForStateVar> =
            component_node.definition.state_var_definitions
            .iter()
            .map(|(&sv_name, sv_variant)| (sv_name, StateForStateVar::new(&sv_variant)))
            .collect();

        dependencies.extend(dependencies_for_this_component);

        component_states.insert(
            component_name.clone(),
            state_for_this_component,
        );
    }


    // Now that the dependency graph has been created, use it to check for cyclical dependencies
    // for all the components
    for (dep_key, _) in dependencies.iter() {
        let DependencyKey::StateVar(comp, sv_ref, _) = dep_key;
        let mut chain = vec![(comp.clone(), sv_ref.clone())];
        let possible_error = check_for_cyclical_dependencies(&dependencies, &mut chain);

        if let Some(error) = possible_error {
            return Err(error);
        }
    }


    log_json!("Components upon core creation",
        utils::json_components(&component_nodes, &component_states));

    // log_json!("Dependencies upon core creation", dependencies);

    log_json!("Dependencies upon core creation",
        utils::json_dependencies(&dependencies));

    log_debug!("Essential data upon core creation {:?}",
        essential_data);


    Ok(DoenetCore {
        component_nodes,
        component_states,
        root_component_name,
        dependencies,
        essential_data,
        aliases,
    })
}



fn check_cyclic_copy_source_component(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,

) -> Option<DoenetMLError> {

    let mut current_comp = component;
    let mut chain = vec![];
    while let Some(CopySource::Component(ref source)) = current_comp.copy_source {

        if chain.contains(&current_comp.name) {
            // Cyclical dependency
            chain.push(current_comp.name.clone());

            let start_index = chain.iter().enumerate().find_map(|(index, name)| {
                if name == &current_comp.name {
                    Some(index)
                } else {
                    None
                }
            }).unwrap();

            let (_, relevant_chain) = chain.split_at(start_index);

            return Some(DoenetMLError::CyclicalDependency {
                component_chain: Vec::from(relevant_chain)
            });


        } else {

            chain.push(current_comp.name.clone());
            current_comp = components.get(source).unwrap();
        }
    }

    None
}

fn name_child_of_copy(child: &str, copy: &str) -> ComponentName {
    format!("__cp:{}({})", child, copy)
}

fn name_macro_component(
    source_name: &str,
    component_name: &String,
    copy_counter: &mut HashMap<ComponentName, usize>,
) -> String {
    let copy_num = copy_counter.entry(source_name.to_string()).or_insert(0);
    *copy_num += 1;

    format!("__mcr:{}({})_{}", source_name, component_name, copy_num)
}

fn add_alias_for_children(
    aliases: &mut HashMap<String, ComponentName>,
    component: &ComponentNode,
    component_nodes: &HashMap<ComponentName, ComponentNode>,
    copy: &String,
) {
    // log_debug!("Adding alias for children of {}", component.name);

    let children = get_children_including_copy(component_nodes, component);

    for (child, _) in children.iter() {
        if let ComponentChild::Component(child_comp) = child {
            aliases.insert(name_child_of_copy(child_comp, copy), child_comp.to_string());
        }
    }
}


/// Check for cyclical dependencies, assuming that we have already traversed through the
/// given dependency chain. This function might become slow for larger documents with lots of copies
fn check_for_cyclical_dependencies(
    dependencies: &HashMap<DependencyKey, Vec<Dependency>>,
    dependency_chain: &mut Vec<(ComponentName, StateVarSlice)>,
) -> Option<DoenetMLError> {

    // log_debug!("Dependency chain {:?}", dependency_chain);
    let last_link = dependency_chain.last().unwrap().clone();

    let my_dependencies = dependencies.iter().filter(|(dep_key, _)| {
        let DependencyKey::StateVar(comp, sv_slice, _) = dep_key;
        if comp == &last_link.0 && sv_slice == &last_link.1 {
            true
        } else {
            false
        }
    });

    for (_, dep_list) in my_dependencies {
        for dep in dep_list {
            let new_link = match dep {
                Dependency::StateVar { component_name, state_var_ref } => {
                    Some((component_name.clone(), StateVarSlice::Single(state_var_ref.clone())))
                },
                Dependency::StateVarArray { component_name, array_state_var_name } => {
                    Some((component_name.clone(), StateVarSlice::Array(array_state_var_name)))
                }
                _ => None,
            };

            if let Some(new_link) = new_link {
                if dependency_chain.contains(&new_link) {
                    // Cyclical dependency!!

                    dependency_chain.push(new_link.clone());
                    log_debug!("Cyclical dependency through {:?} with duplicate {:?}", dependency_chain, new_link);

                    let start_index = dependency_chain.iter().enumerate().find_map(|(index, item)| {
                        if item == &new_link {
                            Some(index)
                        } else {
                            None
                        }
                    }).unwrap();

                    let (_, relevant_chain) = dependency_chain.split_at(start_index);
                    let mut component_chain = vec![];
                    for link in relevant_chain.into_iter() {
                        if component_chain.is_empty() || component_chain.last().unwrap() != &link.0 {
                            component_chain.push(link.0.clone());
                        }
                    }

                    return Some(DoenetMLError::CyclicalDependency {
                        component_chain
                    });

                } else {
                    dependency_chain.push(new_link);
                    let possible_error = check_for_cyclical_dependencies(dependencies, dependency_chain);
                    dependency_chain.pop();

                    if let Some(error) = possible_error {
                        return Some(error);
                    }
                }
            }
        }
    }

    None
}




// One or two $ followed by either
//   - the following combination without parenthesis:
//     - a word (starting with a letter or underscore), capturing word as fourth group, 
//     - optionally followed by anything in square brackets (6th group)
//     - optionally followed by:
//       - a period
//       - followed by a word (9th group)
//       - optionally followed by anything in square brackets (11th group)
//   or
//   - the following combination in parenthesis
//     where the closing parenthesis could be replaced by an open brace,
//     (capturing the open brace or closing parens as 21st group):
//     - an identifier (containing word characters, slash, hyphen, or "../") (12th group)
//     - optionally followed by anything in square brackets (15th group)
//     - optionally followed by:
//       - a period
//       - followed by a word (including hyphens) (18th group)
//       - optionally followed by anything in square brackets (20th group)
lazy_static! {

    // NOTE: It took around ~100ms on a fast computer to create this regex (not including searching with it)
    static ref MACRO_SEARCH: Regex = Regex::new(r"(?x) #flag that ignores whitespace and comments

    (\$) # for now, just one $
    (
        (([a-zA-Z_]\w*)(\[([^\[^\]]+)\])?((\.([a-zA-Z]\w*))(\[([^\[^\]]+)\])?)?)
        |
        \(
            (([\w/-]|\.\./)+)(\[([^\[^\]]+)\])?((\.([\w\-]+))(\[([^\[^\]]+)\])?)?\s*
        ( \) | \{ )
    )

    ").unwrap();

}

lazy_static! {
    static ref POSSIBLE_MACRO: Regex = Regex::new("$").unwrap();
}

fn apply_macro_to_string(
    string: String,
    component: &ComponentNode,
    components: &HashMap<ComponentName, ComponentNode>,
    macro_copy_counter: &mut HashMap<ComponentName, usize>,
    components_to_add: &mut Vec<ComponentNode>,
) -> Option<Vec<ObjectName>> {

    let mut objects = Vec::new();
    let mut previous_end = 0;

    for capture in MACRO_SEARCH.captures_iter(&string) {

        log_debug!("capture {:#?}", capture);

        let start = capture.get(0).unwrap().start();
        let end = capture.get(0).unwrap().end();

        if start == 0 || string.chars().nth(start-1).unwrap_or_default() != '$' {

            // Append the regular string from last endpoint up until start of macro
            let before = &string[previous_end..start];
            if !before.trim().is_empty() {
                objects.push(ObjectName::String(before.to_string()));
            }


            let (macro_comp, macro_prop_option) =
                match capture.get(12) {
                    Some(comp) => (comp, capture.get(18)),
                    None => (capture.get(4).unwrap(), capture.get(9)),
                };

            if let Some(ending_delim) = capture.get(21) {
                if ending_delim.as_str() == "{" {
                    panic!("Haven't implemented macros with curly braces");
                }
            }

            let source_name = macro_comp.as_str();


            let source_comp = components.get(source_name).expect(
                &format!("Macro for {}, but this component does not exist", source_name));


            let macro_copy: ComponentNode = if let Some(macro_prop) = macro_prop_option {

                let (prop_name, _) = source_comp.definition.state_var_definitions
                    .get_key_value(macro_prop.as_str())
                    .expect(&format!("Macro asks for {} property, which does not exist", macro_prop.as_str()));

                let source_comp_sv_name = format!("{}:{}", source_name, prop_name);

                let copy_comp_type = default_component_type_for_state_var(source_comp, prop_name)
                    .expect(&format!("could not create component for state var copy macro"));
                let copy_def = component::generate_component_definitions().get(copy_comp_type).unwrap().clone();

                let copy_name = name_macro_component(
                    &source_comp_sv_name,
                    &component.name,
                    macro_copy_counter,
                );

                ComponentNode {
                    name: copy_name,
                    parent: Some(component.name.clone()),
                    children: vec![],

                    copy_source: Some(CopySource::StateVar(
                        // TODO: non-basic copies
                        source_comp.name.clone(), StateRef::Basic(prop_name))),

                    attributes: HashMap::new(),
                    component_type: copy_comp_type,
                    definition: copy_def,
                }

            } else {

                let copy_name = name_macro_component(
                    source_name,
                    &component.name,
                    macro_copy_counter,
                );

                ComponentNode {
                    name: copy_name,
                    parent: Some(component.name.clone()),
                    children: vec![],

                    copy_source: Some(CopySource::Component(source_comp.name.clone())),
                    attributes: HashMap::new(),

                    .. source_comp.clone()
                }
            };

            objects.push(ObjectName::Component(macro_copy.name.clone()));
            components_to_add.push(macro_copy);

            previous_end = end;
        }

    }
    if previous_end > 0 {
        // There was at least one macro
        let last = &string[previous_end..];
        if !last.trim().is_empty() {
            objects.push(ComponentChild::String(last.to_string()));
        }

        Some(objects)
    } else {
        None
    }
}


fn replace_macros_with_copies(components: &mut HashMap<ComponentName, ComponentNode>) {

    use std::iter::repeat;

    // Keyed by the component name and by the original position of the child we are replacing
    let mut replacement_children: HashMap<ComponentName, HashMap<usize, Vec<ObjectName>>> = HashMap::new();
    let mut replacement_attributes: HashMap<ComponentName, HashMap<String, Vec<ObjectName>>> = HashMap::new();

    let mut components_to_add: Vec<ComponentNode> = vec![];

    let mut macro_copy_counter: HashMap<ComponentName, usize> = HashMap::new();
    

    // This iterator gives info for every string child
    // (original index of child, string value, component)
    let all_string_children = components.iter()
        .flat_map(|(_, comp)|
            comp.children
            .iter()
            .enumerate()
            .filter_map(|(id, child)| {
                match child {
                    ObjectName::String(string_val) => Some((id, string_val)),
                    _ => None,
                }
            })
            .zip(repeat(comp))
            .map(|((id, val), comp)| (id, val, comp))
        );

    let all_attributes = components.iter()
        .flat_map(|(_, comp)|
            comp.attributes
            .iter()
            .map(|(name, val)| (name, val.first().unwrap(), comp))
            .collect::<Vec<(&String, &ObjectName, &ComponentNode)>>()
        );

    // Component string children
    for (child_id, string_val, component) in all_string_children {

        let objects = apply_macro_to_string(
            string_val.clone(),
            component,
            components,
            &mut macro_copy_counter,
            &mut components_to_add
        );

        if let Some(objects) = objects {
            replacement_children.entry(component.name.clone()).or_insert(HashMap::new())
                .entry(child_id).or_insert(objects);
        }
    }

    // Attributes
    for (attribute_name, object_name, component) in all_attributes {
        if let ObjectName::String(string_val) = object_name {
            let objects = apply_macro_to_string(
                string_val.clone(),
                component,
                components,
                &mut macro_copy_counter,
                &mut components_to_add
            );

            if let Some(objects) = objects {
                replacement_attributes.entry(component.name.clone()).or_insert(HashMap::new())
                    .entry(attribute_name.clone()).or_insert(objects);
            }
        }
    }


    log_debug!("Components to add from macros: {:#?}", components_to_add);

    for new_component in components_to_add {

        debug_assert!( !components.contains_key(&new_component.name) );
        components.insert(new_component.name.clone(), new_component);
    }


    log_debug!("Replacement children {:#?}", replacement_children);

    for (component_name, new_children_hashmap) in replacement_children {
        
        let component = components.get_mut(&component_name).unwrap();

        for (original_child_id, new_children) in new_children_hashmap {

            // Remove the original element, and add the new children (in order) in its place
            component.children.splice(
                original_child_id..original_child_id + 1,
                new_children
            );
        }
    }

    log_debug!("Replacement attributes {:#?}", replacement_attributes);

    for (component_name, new_children_hashmap) in replacement_attributes {
        let component = components.get_mut(&component_name).unwrap();
        for (attribute_name, new_attribute) in new_children_hashmap {
            component.attributes.insert(attribute_name, new_attribute);
        }
    }

}


fn default_component_type_for_state_var(component: &ComponentNode, state_var: StateVarName)
    -> Result<ComponentType, String> {

    let state_var_def = component.definition.state_var_definitions.get(state_var).unwrap();
    match state_var_def {
        StateVarVariant::Boolean(_) => Ok("boolean"),
        StateVarVariant::Integer(_) => Ok("number"),
        StateVarVariant::Number(_) => Ok("number"),
        StateVarVariant::String(_) => Ok("text"),
        StateVarVariant::NumberArray(_) => Err(
            format!("no component for NumberArray state variable")
        ),
    }
}




fn create_all_dependencies_for_component(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
    essential_data: &mut HashMap<ComponentName, HashMap<StateVarName, EssentialStateVar>>,
) -> HashMap<DependencyKey, Vec<Dependency>> {

    // log_debug!("Creating dependencies for {}", component.name);
    let mut dependencies: HashMap<DependencyKey, Vec<Dependency>> = HashMap::new();


    let my_definitions = component.definition.state_var_definitions;
    for (&state_var_name, state_var_variant) in my_definitions.iter() {

        if state_var_variant.is_array() {

            let size_dep_instructions = state_var_variant.return_size_dependency_instructions(HashMap::new());

            for (instruct_name, ref dep_instruction) in size_dep_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components, component, &&StateRef::SizeOf(state_var_name),
                    dep_instruction, instruct_name, essential_data,
                );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Single(StateRef::SizeOf(state_var_name)),
                        instruct_name
                    ),
                    instruct_dependencies,
                );

            }

            let array_dep_instructions = state_var_variant.return_array_dependency_instructions(HashMap::new());

            for (instruct_name, ref dep_instruction) in array_dep_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components, component, &&StateRef::SizeOf(state_var_name),
                    dep_instruction, instruct_name, essential_data
                );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Array(state_var_name),
                        instruct_name,
                    ),
                    instruct_dependencies,
                );


            }


        } else {

            let dependency_instructions = return_dependency_instruction_including_shadowing(component, &StateRef::Basic(state_var_name));

            for (instruct_name, ref dep_instruction) in dependency_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components, component, &StateRef::Basic(state_var_name),
                    dep_instruction, instruct_name, essential_data
                );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Single(StateRef::Basic(state_var_name)),
                        instruct_name,
                    ),
                    instruct_dependencies   
                );
            }

        }
    }

    dependencies

}


/// This function also creates essential data when a DependencyInstruction asks for it.
fn create_dependencies_from_instruction(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
    state_var_reference: &StateRef,
    instruction: &DependencyInstruction,
    instruction_name: InstructionName,
    essential_data: &mut HashMap<ComponentName, HashMap<StateVarName, EssentialStateVar>>,
) -> Vec<Dependency> {

    // log_debug!("Creating dependency {}:{}:{}", component.name, state_var_reference, instruction_name);

    let mut dependencies: Vec<Dependency> = Vec::new();

    match &instruction {

        DependencyInstruction::Essential => {

            let component_name = get_essential_data_component_including_copy(components, component);
            let state_var_name = state_var_reference.name();

            let variant = component.definition.state_var_definitions.get(state_var_name).unwrap();

            let initial_value = (match variant.is_array() {
                false => variant.initial_essential_value(),
                true => variant.initial_essential_element_value(),
            })
            .expect(&format!(
                "essential dependency of {}:{} without initial essential value",
                component_name,
                state_var_name
            ));


            // A copy uses the same essential data, so `insert` would be called twice
            // with the same key, but that's ok.
            essential_data
                .entry(component_name.clone())
                .or_insert(HashMap::new())
                .insert(
                    state_var_name,
                    EssentialStateVar::new(initial_value),
                );

            dependencies.push(Dependency::Essential {
                component_name,
                state_var_name,
            });

        },

        DependencyInstruction::StateVar { component_name, state_var } => {

            let component_name = match component_name {
                Some(ref name) => name.to_string(),
                None => component.name.clone(),
            };

            dependencies.push(match state_var {

                StateVarSlice::Single(state_var_ref) => {
                    Dependency::StateVar {
                        component_name,
                        state_var_ref: state_var_ref.clone()
                    }
                },
                StateVarSlice::Array(array_state_var_name) => {
                    Dependency::StateVarArray {
                        component_name,
                        array_state_var_name,
                    }
                },
            });

        },

        DependencyInstruction::Child { desired_profiles } => {

            let children = get_children_including_copy(components, component);
            for (child, _) in children.iter() {

                match child {
                    ComponentChild::Component(child_component_name) => {
                        let child_component = components.get(child_component_name).unwrap();

                        let mut selected_child_state_var = None;

                        for child_profile in child_component.definition.component_profiles.iter() {
                            if desired_profiles.contains(&child_profile.0) {
                                selected_child_state_var = Some(child_profile.1);
                                break;
                            }
                        }


                        if let Some(profile_state_var) = selected_child_state_var {

                            let sv_def = child_component.definition
                                .state_var_definitions
                                .get(profile_state_var)
                                .unwrap();

                            if sv_def.is_array() {
                                dependencies.push(Dependency::StateVarArray {
                                    component_name: child_component_name.to_string(),
                                    array_state_var_name: profile_state_var,
                                });

                            } else {
                                dependencies.push(Dependency::StateVar {
                                    component_name: child_component_name.to_string(),
                                    state_var_ref: StateRef::Basic(profile_state_var),
                                });

                            }

                        }

                    },

                    ComponentChild::String(string_value) => {
                        if desired_profiles.contains(&ComponentProfile::Text) {
                            dependencies.push(Dependency::String { value: string_value.to_string() });
                        }
                    },

                }
            }
            

        },
        DependencyInstruction::Parent { state_var } => {

            let desired_state_var = state_var;

            let parent_name = component.parent.clone().expect(&format!(
                "Component {} doesn't have a parent, but the dependency instruction {}:{} asks for one.",
                    component.name, state_var_reference, instruction_name
            ));

            let parent_component = components.get(&parent_name).unwrap();

            // Look up what kind of child state var it is
            // If the state var is an array, depend on the array, otherwise as normal

            let sv_def = parent_component.definition.state_var_definitions.get(desired_state_var).unwrap();

            if sv_def.is_array() {
                dependencies.push(Dependency::StateVarArray {
                    component_name: parent_name.to_string(),
                    array_state_var_name: desired_state_var,
                });

            } else {
                dependencies.push(Dependency::StateVar {
                    component_name: parent_name.to_string(),
                    state_var_ref: StateRef::Basic(desired_state_var),
                });

            }

        },


        DependencyInstruction::Attribute { attribute_name } => {

            let state_var_name = state_var_reference.name();
            let variant = component.definition.state_var_definitions.get(state_var_name).unwrap();

            let mut initial_value = None;

            // log_debug!("attribute has copy {:?}", &component.copy_source);
            // log_debug!("attribute {:?}", component.attributes.get(*attribute_name));

            if let Some(attribute) = component.attributes.get(*attribute_name) {

                let attr_string =
                    match attribute.first() {
                        Some(ObjectName::String(s)) => Some(s),
                        _ => None,
                    };

                if attribute.len() > 1 || attr_string.is_none() {

                    // attribute depends on other state vars
                    for object_name in attribute {
                        match object_name {
                            ObjectName::String(s) => dependencies.push(Dependency::String {
                                value: s.clone(),
                            }),
                            ObjectName::Component(s) => {
                                let comp_def = components.get(s).unwrap().definition;
                                let state_var_ref = StateRef::Basic(
                                    comp_def.primary_input_state_var.unwrap());

                                dependencies.push(Dependency::StateVar {
                                    component_name: s.clone(),
                                    state_var_ref,
                                })
                            },
                        }
                    }


                } else if variant.initial_essential_value().is_some() {
                    let attr_string = attr_string.unwrap();

                    // initialize essential data with the attribute.
                    initial_value = Some(match variant {
                        StateVarVariant::String(_) => StateVarValue::String(attr_string.clone()),
                        StateVarVariant::Boolean(_) => StateVarValue::Boolean(attr_string == "true"),
                        StateVarVariant::Number(_) => match evalexpr::eval(attr_string) {
                            Ok(num) => StateVarValue::Number(num.as_number().unwrap_or(f64::NAN)),
                            Err(_) => panic!("Can't parse number in attribute"),
                        },
                        StateVarVariant::Integer(_) => match evalexpr::eval(&attr_string) {
                            Ok(num) => StateVarValue::Integer(num.as_int().unwrap()),
                            Err(_) => panic!("Can't parse integer in attribute"),
                        },
                        StateVarVariant::NumberArray(_) => todo!(),
                    });
                    log_debug!("essential value set by attribute: {}", initial_value.as_ref().unwrap());
                } else {

                    // without essential data, the dependency will not change
                    dependencies.push(Dependency::String {
                        value: attr_string.unwrap().clone()
                    });
                }
            } else if let Some(CopySource::Component(c)) = &component.copy_source {

                // inherit attribute from copy source
                dependencies.push(Dependency::StateVar {
                    component_name: c.clone(),
                    state_var_ref: state_var_reference.clone(),
                });
            } else {

                // use essential if applicable
                initial_value = variant.initial_essential_value();
            }

            if let Some(initial_value) = initial_value {
                essential_data
                    .entry(component.name.clone())
                    .or_insert(HashMap::new())
                    .insert(
                        state_var_name,
                        EssentialStateVar::new(initial_value),
                    );

                dependencies.push(Dependency::Essential {
                    component_name: component.name.clone(),
                    state_var_name,
                });
            }

        },

    }
    dependencies
}



/// Calculate all the (normal) state vars that depend on the given state var
fn get_state_variables_depending_on_me<'a>(
    core: &'a DoenetCore,
    sv_component_name: &ComponentName,
    sv_reference: &StateRef,
) -> Vec<(&'a ComponentName, &'a StateVarSlice)> {

    let mut depending_on_me = vec![];

    for (dependency_key, dependencies) in core.dependencies.iter() {

        for dependency in dependencies {

            match dependency {
                Dependency::StateVar { component_name, state_var_ref } => {
                    if component_name == sv_component_name
                    && state_var_ref == sv_reference {

                        let DependencyKey::StateVar(dependent_comp, dependent_group, _) = dependency_key;
                        depending_on_me.push((dependent_comp, dependent_group));
                    }
                },

                Dependency::StateVarArray { component_name, array_state_var_name } => {
                    // check if the state variables is in this group
                    if component_name == sv_component_name
                    && *array_state_var_name == sv_reference.name() {

                        let DependencyKey::StateVar(dependent_comp, dependent_group, _) = dependency_key;
                        depending_on_me.push((dependent_comp, dependent_group));
                    }
                },

                // Essential and String dependencies are endpoints
                _ => {},

            }
        }
    }

    depending_on_me
}


fn dependencies_of_state_var<'a>(
    core: &'a DoenetCore,
    component: &ComponentNode,
    state_var_ref: &StateRef,
) -> HashMap<InstructionName, &'a Vec<Dependency>> {

    core.dependencies.iter().filter_map(| (key, deps) |

        match key {
            DependencyKey::StateVar(comp_name, StateVarSlice::Single(sv_ref), instruct_name) => {
                if comp_name == &component.name && sv_ref == state_var_ref {
                    Some((*instruct_name, deps))
                } else {
                    None
                }
            },
            DependencyKey::StateVar(comp_name, StateVarSlice::Array(sv_array), instruct_name) => {
                if let StateRef::ArrayElement(array_name, _) = state_var_ref {
                    if comp_name == &component.name && array_name == sv_array {
                        Some((*instruct_name, deps))
                    } else {
                        None
                    }
                } else {
                    None
                }
            },
        }
    ).collect()

}

fn resolve_state_variable(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var_ref: &StateRef,
) -> StateVarValue {

    let state_vars = core.component_states.get(&component.name).unwrap();

    // No need to continue if the state var is already resolved
    let current_state = state_vars.get(state_var_ref.name()).unwrap().get_single_state(state_var_ref);
    if let State::Resolved(current_value) = current_state {
        return current_value;
    }

    log_debug!("Resolving {}:{}", component.name, state_var_ref);

    let my_dependencies = dependencies_of_state_var(core, component, state_var_ref);

    let mut dependency_values: HashMap<InstructionName, Vec<DependencyValue>> = HashMap::new();

    for (dep_name, deps) in my_dependencies {

        let mut values_for_this_dep: Vec<DependencyValue> = Vec::new();

        for dep in deps {
            match dep {

                Dependency::StateVar { component_name, state_var_ref } => {

                    let depends_on_component = core.component_nodes.get(component_name).unwrap();
                    let depends_on_value = resolve_state_variable(core, depends_on_component, &state_var_ref);

                    values_for_this_dep.push(DependencyValue {
                        component_type: depends_on_component.component_type,
                        state_var_name: state_var_ref.name(),
                        value: depends_on_value.clone(),
                    });
                },
                Dependency::String { value } => {

                    values_for_this_dep.push(DependencyValue {
                        component_type: "string",
                        state_var_name: "value",
                        value: StateVarValue::String(value.to_string()),
                    });

                },

                Dependency::Essential { component_name, state_var_name } => {

                    let value = core.essential_data
                        .get(component_name).unwrap()
                        .get(state_var_name).unwrap()
                        .clone()
                        .get_value(get_essential_datum_index(state_var_ref));
    
                    if let Some(value) = value {
                        values_for_this_dep.push(DependencyValue {

                            value,

                            // We don't really need these fields in this case (?)
                            component_type: "essential_data",
                            state_var_name: "",
                        })
                    }
                },

                Dependency::StateVarArray { component_name, array_state_var_name } => {

                    let depends_on_component = core.component_nodes.get(component_name).unwrap();

                    // important to resolve the size before the elements
                    let size_value = resolve_state_variable(
                        core,
                        depends_on_component,
                        &StateRef::SizeOf(array_state_var_name)
                    );
                    
                    for id in 0 as usize..i64::try_from(size_value).unwrap() as usize {
                        let element_value = resolve_state_variable(
                            core,
                            depends_on_component,
                            &StateRef::ArrayElement(array_state_var_name, id)
                        );

                        values_for_this_dep.push(DependencyValue {
                            component_type: depends_on_component.component_type,
                            state_var_name: &array_state_var_name,
                            value: element_value.clone(),
                        });
    
                    }
                },
            }
        }

        dependency_values.insert(dep_name, values_for_this_dep);
    }


    log_debug!("Dependency values for {}:{}: {:#?}", component.name, state_var_ref, dependency_values);


    let update_instruction = generate_update_instruction_including_shadowing(
        component, state_var_ref, dependency_values
    ).expect(&format!("Can't resolve {}:{} (a {} component type)",
        component.name, state_var_ref, component.component_type)
    );


    let new_value = handle_update_instruction(component, state_vars, state_var_ref, update_instruction);

    return new_value;

}

fn get_essential_datum_index(state_var_ref: &StateRef) -> usize {
    match state_var_ref {
        StateRef::Basic(_) => 0,
        StateRef::SizeOf(_) => 0,
        StateRef::ArrayElement(_, i) => i + 1, // reserve 0 for SizeOf
    }
}

/// This must resolve the size
fn elements_of_array(
    core: &DoenetCore,
    component: &ComponentNode,
    sv_name: &StateVarName,
) -> Vec<StateRef> {
    let size_ref = StateRef::SizeOf(sv_name);
    let size: i64 = resolve_state_variable(core, component, &size_ref)
        .try_into()
        .unwrap();

    (0..(size as usize)).map(|i| StateRef::ArrayElement(sv_name, i)).collect()
}

fn references_from_group(
    core: &DoenetCore,
    sv_component: &ComponentNode,
    sv_name: &StateVarName,
) -> Vec<StateRef> {

    let state_var = core.component_states.get(&sv_component.name).unwrap().get(sv_name).unwrap();

    let existing_elements = (0..state_var.elements_len())
        .map(|i|
            StateRef::ArrayElement(sv_name, i)
        );

    let specific_deps = core.dependencies.iter().filter_map(| (key, _) | {
        match key {
            DependencyKey::StateVar(_, StateVarSlice::Single(StateRef::SizeOf(s)), _) => {
                Some(StateRef::SizeOf(s))
            },
            DependencyKey::StateVar(_, StateVarSlice::Single(StateRef::ArrayElement(s, i)), _) => {    
                Some(StateRef::ArrayElement(s, *i))
            }
            _ => None,
        }
    });

    // combine vectors without redundancy
    let mut all_elements = Vec::new();
    for elem in existing_elements.chain(specific_deps) {
        if !all_elements.contains(&elem) {
            all_elements.push(elem);
        }
    }
    all_elements
}


fn mark_stale_state_var_and_dependencies(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var_ref: &StateRef,
) {
    let component_state = core.component_states.get(&component.name).unwrap();
    let state_var = component_state.get(state_var_ref.name()).unwrap();

    // No need to continue if the state var is already stale
    if state_var.get_single_state(state_var_ref) == State::Stale {
        return;
    }

    // log_debug!("Marking stale {}:{}", component.name, state_var_ref);

    state_var.mark_single_stale(state_var_ref);

    let depending_on_me = get_state_variables_depending_on_me(core, &component.name, state_var_ref);
    
    for (depending_comp_name, depending_group) in depending_on_me {
        let depending_comp = core.component_nodes.get(depending_comp_name).unwrap();

        match depending_group {
            StateVarSlice::Single(sv_ref) => {
                mark_stale_state_var_and_dependencies(core, depending_comp, &sv_ref);
            },
            StateVarSlice::Array(sv_name) => {
                let members = references_from_group(core, component, &sv_name);
                for member in members {
                    mark_stale_state_var_and_dependencies(core, depending_comp, &member);
                }
            }
        }
    }
}




fn mark_stale_essential_datum_dependencies(
    core: &DoenetCore,
    component_name: ComponentName,
    state_var_ref: &StateRef,
) {

    // log_debug!("Marking stale essential {}:{}", component_name, state_var);

    let search_dep = Dependency::Essential {
        component_name,
        state_var_name: state_var_ref.name(),
    };

    let my_dependencies = core.dependencies.iter().filter_map( |(key, deps) | {
        if deps.contains(&search_dep) {

            match key {
                DependencyKey::StateVar(comp_name, StateVarSlice::Single(s), _) => Some((comp_name, s.clone())),
                DependencyKey::StateVar(comp_name, StateVarSlice::Array(array), _) => {

                    match state_var_ref {
                        StateRef::ArrayElement(_, i) =>
                            Some((comp_name, StateRef::ArrayElement(array, *i))),
                        StateRef::SizeOf(_) =>
                            Some((comp_name, StateRef::SizeOf(array))),
                        StateRef::Basic(_) =>
                            // Arrays cannot use essential data
                            // associated with a basic state var.
                            None,
                    }
                }
            }

        } else {
            None
        }
    });

    for (component_name, state_var_ref) in my_dependencies {
        let component = core.component_nodes.get(component_name).unwrap();
        mark_stale_state_var_and_dependencies(core, &component, &state_var_ref);
    }
}



/// Sets the state var and returns the new value
fn handle_update_instruction<'a>(
    component: &'a ComponentNode,
    component_state_vars: &HashMap<StateVarName, StateForStateVar>,
    state_var_ref: &StateRef,
    instruction: StateVarUpdateInstruction<StateVarValue>
) -> StateVarValue {

    log_debug!("Updating state var {}:{}", component.name, state_var_ref);

    let state_var = component_state_vars.get(state_var_ref.name()).unwrap();

    let updated_value: StateVarValue;

    match instruction {
        StateVarUpdateInstruction::NoChange => {
            let current_value= component_state_vars.get(state_var_ref.name()).unwrap().get_single_state(state_var_ref);


            if let State::Resolved(current_resolved_value) = current_value {
                // Do nothing. It's resolved, so we can use it as is
                updated_value = current_resolved_value;

            } else {
                panic!("Cannot use NoChange update instruction on a stale value");
            }

        },
        StateVarUpdateInstruction::SetValue(new_value) => {

            state_var.set_single_state(state_var_ref, new_value.clone()).expect(
                &format!("Failed to set {}:{} while handling SetValue update instruction", component.name, state_var_ref)
            );

            updated_value = new_value;
        }

    };

    log_debug!("Updated to {}", updated_value);

    return updated_value;
}





#[derive(Debug)]
pub struct Action {
    pub component_name: ComponentName,
    pub action_name: String,

    /// The keys are not strictly state variable names.
    /// They are whatever name the renderer calls the new value.
    pub args: HashMap<String, StateVarValue>,
}


/// Internal struct used to track changes
#[derive(Debug, Clone)]
enum UpdateRequest {
    SetEssentialValue(ComponentName, StateRef, StateVarValue),
    SetStateVar(ComponentName, StateRef, StateVarValue),
}


/// Among other things, this produces info about the component name based on
/// the dependency instruction.
fn convert_dependency_values_to_update_request(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var: &StateRef,
    requests: HashMap<InstructionName, Vec<DependencyValue>>
) -> Vec<UpdateRequest> {

    let my_dependencies = dependencies_of_state_var(core, component, state_var);


    requests.iter()
        .flat_map(|(instruction_name, values)|
            values.iter()
            .flat_map(|value|
                my_dependencies.get(instruction_name).unwrap()
                .iter()
                .filter_map(|instruction|
                    match instruction {
                        Dependency::Essential { component_name, state_var_name: _ } => {
                            Some(UpdateRequest::SetEssentialValue(
                                component_name.clone(),
                                state_var.clone(),
                                value.value.clone(),
                            ))
                        },
                        Dependency::StateVar { component_name, state_var_ref } => {
                            Some(UpdateRequest::SetStateVar(
                                component_name.clone(),
                                state_var_ref.clone(),
                                value.value.clone(),
                            ))
                        },
                        _ => None,
                    }
                ).collect::<Vec<UpdateRequest>>()
            ).collect::<Vec<UpdateRequest>>()
        ).collect()
}

pub fn handle_action_from_json(core: &DoenetCore, action: &str) {

    let action = parse_json::parse_action_from_json(action)
        .expect(&format!("Error parsing json action: {}", action));

    // log_debug!("Handling action {:#?}", action);

    // Apply alias to get the original component name
    let component_name = core.aliases.get(&action.component_name).unwrap_or(&action.component_name);

    let component = core.component_nodes.get(component_name)
        .expect(&format!("{} doesn't exist, but action {} uses it", action.component_name, action.action_name));

    let state_var_resolver = | state_var_ref | {
        resolve_state_variable(core, component, state_var_ref)
    };

    let state_vars_to_update = (component.definition.on_action)(
        &action.action_name,
        action.args,
        &state_var_resolver,
    );

    for (state_var_ref, requested_value) in state_vars_to_update {

        let request = UpdateRequest::SetStateVar(component_name.clone(), state_var_ref.clone(), requested_value);
        process_update_request(core, &request);
    }

    log_json!("Updated component tree", utils::json_components(&core.component_nodes, &core.component_states));
}


fn process_update_request(
    core: &DoenetCore,
    update_request: &UpdateRequest
) {

    // log_debug!("Processing update request {:?}", update_request);

    match update_request {
        UpdateRequest::SetEssentialValue(component_name, state_var_ref, requested_value) => {

            let essential_var = core.essential_data
                .get(component_name).unwrap()
                .get(state_var_ref.name()).unwrap();

            essential_var.set_value(
                    get_essential_datum_index(state_var_ref),
                    requested_value.clone()
                ).expect(
                    &format!("Failed to set essential value for {}, {}", component_name, state_var_ref)
                );

            // log_debug!("Updated essential data {:?}", core.essential_data);

            mark_stale_essential_datum_dependencies(core, component_name.clone(), state_var_ref);
        },

        UpdateRequest::SetStateVar(component_name, state_var_ref, requested_value) => {

            let dep_comp = core.component_nodes.get(component_name).unwrap();

            let dep_update_requests = request_dependencies_to_update_value_including_shadow(
                core,
                dep_comp,
                state_var_ref,
                requested_value.clone(),
            );

            for dep_update_request in dep_update_requests {
                process_update_request(core, &dep_update_request);
            }

            let component = core.component_nodes.get(component_name).unwrap();
            mark_stale_state_var_and_dependencies(core, component, &state_var_ref);
        }
    }
}





pub fn update_renderers(core: &DoenetCore) -> String {
    let json_obj = generate_render_tree(core);
    serde_json::to_string(&json_obj).unwrap()
}


fn generate_render_tree(core: &DoenetCore) -> serde_json::Value {

    let root_node = core.component_nodes.get(&core.root_component_name).unwrap();
    let mut json_obj: Vec<serde_json::Value> = vec![];

    generate_render_tree_internal(core, root_node, &mut json_obj, None);

    serde_json::Value::Array(json_obj)
}

fn generate_render_tree_internal(
    core: &DoenetCore,
    component: &ComponentNode,
    json_obj: &mut Vec<serde_json::Value>,
    came_from_copy: Option<&ComponentName>,
) {
    use serde_json::json;

    let state_vars = component.definition.state_var_definitions;

    let renderered_state_vars = state_vars.into_iter().filter(|kv| kv.1.for_renderer());

    let mut state_values = serde_json::Map::new();
    for (name, variant) in renderered_state_vars {

        if variant.is_array() {

            // TODO: not the best way to do this?
            let sv_refs = elements_of_array(core, component, name);

            let mut values: Vec<f64> = Vec::new();
            for sv_ref in sv_refs {
                values.push(
                    resolve_state_variable(core, component, &sv_ref)
                    .try_into()
                    .unwrap()
                );
            }

            state_values.insert(name.to_string(), json!(values));

        } else {
            let state_var_value = resolve_state_variable(core, component, &StateRef::Basic(name));

            if *name == "selectedStyle" || *name == "graphicalDescendants" {
                if let StateVarValue::String(v) = state_var_value {
                    // log_debug!("deserializing for renderer: {}", v);
                    let value = serde_json::from_str(&v).unwrap();
                    state_values.insert(name.to_string(), value);
                }
            } else {
                state_values.insert(name.to_string(), state_var_value.into());
            }
        }
    }

    let name_to_render = match &came_from_copy {
        Some(copy_name) => name_child_of_copy(&component.name, &copy_name),
        None => component.name.clone(),
    };

    let mut children_instructions = Vec::new();
    if component.definition.should_render_children {

        let children = get_children_including_copy(&core.component_nodes, component);

        for (child, actual_child) in children.iter() {
            match child {
                ComponentChild::Component(comp_name) => {
                    // recurse for children
                    let comp = core.component_nodes.get(comp_name).unwrap();
                    
                    let child_came_from_copy =
                        came_from_copy.or(
                            if *actual_child {
                                None
                            } else {
                                Some(&component.name)
                            });

                    generate_render_tree_internal(core, comp, json_obj, child_came_from_copy); 

                    let mut child_actions = serde_json::Map::new();

                    for action_name in (comp.definition.action_names)() {
                        child_actions.insert(action_name.to_string(), json!({
                            "actionName": action_name,
                            "componentName": comp.name,
                        }));
                    }

                    let renderer_type = match comp.definition.renderer_type {
                        RendererType::Special(name) => name,
                        RendererType::Myself => comp.component_type,
                    };

                    children_instructions.push(json!({
                        "actions": child_actions,
                        "componentName": comp.name,
                        "componentType": comp.component_type,
                        "effectiveName": comp.name,
                        "rendererType": renderer_type,
                    }));
                },
                ComponentChild::String(string) => {
                    children_instructions.push(json!(string));
                },
            }
        }
    }

    json_obj.push(json!({
        "componentName": name_to_render,
        "stateValues": serde_json::Value::Object(state_values),
        "childrenInstructions": json!(children_instructions),
    }));

}




////////////// Wrappers providing for CopySource and sequence component //////////////


/// This includes the copy source's children. The flag is false when it is
/// a copy source's child. Also skips sequence components.
fn get_children_including_copy(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
) -> Vec<(ComponentChild, bool)> {

    // log_debug!("Getting children for {}", component.name);

    let mut children_vec: Vec<(ComponentChild, bool)> = Vec::new();
    if let Some(CopySource::Component(ref source)) = component.copy_source {

        let source_comp = components.get(source).unwrap();
        children_vec = get_children_including_copy(components, source_comp)
            .iter()
            .map(|(c, _)| (c.clone(), false))
            .collect();
    }

    children_vec.extend(
        component.children
        .iter()
        .map(|c| (c.clone(), true))
    );

    children_vec
}


/// Recurse until the name of the original source is found.
/// This allows copies to share essential data.
fn get_essential_data_component_including_copy(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
) -> ComponentName {
    match &component.copy_source {
        Some(CopySource::Component(source)) =>
            get_essential_data_component_including_copy(components, components.get(source).unwrap()),
        _ => component.name.clone(),
    }
}



fn return_dependency_instruction_including_shadowing(
    component: &ComponentNode,
    state_var: &StateRef,
) -> HashMap<InstructionName, DependencyInstruction> {

    if let Some((source_comp, source_state_var)) = state_var_is_shadowing(component, state_var) {

        HashMap::from([
            (SHADOW_INSTRUCTION_NAME, DependencyInstruction::StateVar {
                component_name: Some(source_comp), //.clone(),
                state_var: StateVarSlice::Single(source_state_var),
            })
        ])

    } else {
        let state_var_def = component.definition.state_var_definitions.get(state_var.name()).unwrap();

        match state_var {
            StateRef::Basic(_) => {
                state_var_def.return_dependency_instructions(HashMap::new())
            },
            StateRef::SizeOf(_) => {
                state_var_def.return_size_dependency_instructions(HashMap::new())
            },
            StateRef::ArrayElement(_, id) => {
                state_var_def.return_element_dependency_instructions(*id, HashMap::new())
            }
        }
    }
}



/// This determines the state var given its dependency values.
fn generate_update_instruction_including_shadowing(
    component: &ComponentNode,
    state_var: &StateRef,
    dependency_values: HashMap<InstructionName, Vec<DependencyValue>>

) -> Result<StateVarUpdateInstruction<StateVarValue>, String> {

    if state_var_is_shadowing(component, state_var).is_some() {

        // Assuming that source state var is same type as this state var
        let source_value = dependency_values.dep_value(SHADOW_INSTRUCTION_NAME)?
            .has_exactly_one_element()?
            .value();

        Ok(StateVarUpdateInstruction::SetValue(source_value))

    } else {
        // Otherwise, this state var is not shadowing, so proceed normally
        let state_var_def = component.definition.state_var_definitions.get(state_var.name()).unwrap();

        match state_var {
            StateRef::Basic(_) => {
                state_var_def.determine_state_var_from_dependencies(dependency_values)
            },
            StateRef::SizeOf(_) => {
                state_var_def.determine_size_from_dependencies(dependency_values)
            },
            StateRef::ArrayElement(_, id) => {
                state_var_def.determine_element_from_dependencies(*id, dependency_values)
            }
        }

    }
}



fn request_dependencies_to_update_value_including_shadow(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var_ref: &StateRef,
    new_value: StateVarValue,
) -> Vec<UpdateRequest> {

    if let Some((source_comp, source_state_var)) = state_var_is_shadowing(component, state_var_ref) {

        vec![UpdateRequest::SetStateVar(source_comp, source_state_var, new_value)]

    } else {
        let requests = component.definition.state_var_definitions.get(state_var_ref.name()).unwrap()
            .request_dependencies_to_update_value(state_var_ref, new_value);

        convert_dependency_values_to_update_request(core, component, state_var_ref, requests)
    }
}

/// Detect if a state var is shadowing because of a CopySource
/// and has a primary input state variable, which is needed.
fn state_var_is_shadowing(component: &ComponentNode, state_var: &StateRef)
    -> Option<(ComponentName, StateRef)> {

    if let Some(CopySource::StateVar(ref source_comp, ref source_state_var)) = component.copy_source {
        if let Some(primary_input_state_var) = component.definition.primary_input_state_var {

            if state_var == &StateRef::Basic(primary_input_state_var) {
                Some((source_comp.to_string(), source_state_var.clone()))
            } else {
                None
            }
        } else {
            panic!("{} component type doesn't have a primary input state var", component.component_type);
        }

    } else {
        None
    }
}
