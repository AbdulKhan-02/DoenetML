pub mod state_variables;
pub mod component;

pub mod state;
pub mod parse_json;
pub mod utils;
pub mod base_definitions;
pub mod math_expression;

use base_definitions::PROP_INDEX_SV;
use lazy_static::lazy_static;
use parse_json::{DoenetMLError, DoenetMLWarning};
use state::StateForStateVar;
use std::collections::HashMap;
use std::fmt::Debug;
use regex::Regex;

use state::{State, EssentialStateVar};
use component::*;
use state_variables::*;

use crate::math_expression::MathExpression;
use crate::utils::{log_json, log_debug};
use serde::Serialize;


/// A static DoenetCore is created from parsed DoenetML at the beginning.
/// While `component_states` and `essential_data` can update using
/// internal mutability (the RefCell), the over-arching HashMaps are static.
#[derive(Debug)]
pub struct DoenetCore {
    /// The component tree has almost the same structute as the tree of elements
    /// typed into DoenetML, except:
    /// - macros are converted into their own components
    pub component_nodes: HashMap<ComponentName, ComponentNode>,

    /// Keyed by
    /// - `ComponentName` not ComponentRef - a ComponentRef's state variables
    ///   point to the state variables of a ComponentName
    /// - `StateVarName` rather than `StateVarReference`
    ///   so that it is static even when arrays change size
    pub component_states: HashMap<ComponentName, HashMap<StateVarName, StateForStateVar>>,

    pub root_component_name: ComponentName,

    /// **The Dependency Graph**
    /// A DAC whose vertices are the state variables and attributes
    /// of every component, and whose endpoint vertices are essential data.
    ///
    /// Used for
    /// - producing values when determining a state variable
    /// - tracking when a change affects other state variables
    pub dependencies: HashMap<DependencyKey, Vec<Dependency>>,

    pub group_dependencies: HashMap<ComponentName, Vec<GroupDependency>>,

    /// Endpoints of the dependency graph.
    /// Every update instruction will lead to these.
    pub essential_data: HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
}


/// State variables are keyed by:
/// 1. the name of the component
/// 2. the name of a state variable slice
///    which allows for two kinds of dependencies:
///      - direct dependency: when a single state var depends on something
///      - indirect dependency: when a group depends on something,
///        and members of the group inherit the dependency.
///        The motivation for indirect dependencies is that
///        the size of groups can change (e.g. an array changes size).
///        To keep the dependency graph static, we do not update
///        individual dependencies but simply apply the group dependency.
/// 3. the instruction name, given by the state variable to track where
///    dependecy values came from.
#[derive(Debug, Hash, PartialEq, Eq, Serialize)]
pub enum DependencyKey {
    StateVar(ComponentName, StateVarSlice, InstructionName),
}

impl DependencyKey {
    fn component_name(&self) -> &str {
        match self {
            DependencyKey::StateVar(name, _, _) => name,
        }
    }
}


/// A collection of edges on the dependency tree
#[derive(Debug, Clone, PartialEq, Eq, Serialize)]
pub enum Dependency {
    Essential {
        component_name: ComponentName,
        origin: EssentialDataOrigin,
    },

    // outer product of the members of the group and states in the slice
    StateVar {
        component_group: ComponentGroup,
        state_var_slice: StateVarSlice,
    },

    StateVarArrayDynamicElement {
        component_name: ComponentName,
        array_state_var_name: StateVarName,
        index_state_var: StateRef, // presumably an integer from the component that carries this dependency
    },
}


#[derive(Debug, Serialize)]
pub enum GroupDependency {
    Group(ComponentName),
    Component(ComponentName),
    StateVar(ComponentRef, StateVarSlice),
}


// === POTENTIAL CODE FOR MAPS ===
// #[derive(PartialEq, Serialize, Eq, Clone, Debug, Hash)]
// struct Instance<T> {
//     original: T,
//     path: Vec<(ComponentName, usize)>,
// }
// #[derive(PartialEq, Serialize, Eq, Clone, Debug, Hash)]
// struct Multi<T> {
//     original: T,
//     path: Vec<(ComponentName, MapIndex)>,
// }
// #[derive(PartialEq, Serialize, Eq, Clone, Debug, Hash)]
// enum MapIndex {
//     All,
//     Single(usize),
// }



/// Essential data can be generated by
/// - a state variable requesting it
/// - a string child, converted into essential data
///   so that it can change when requested
/// - a string in an attribute
#[derive(Serialize, Debug, Clone, Eq, Hash, PartialEq)]
pub enum EssentialDataOrigin {
    StateVar(StateVarName),
    ComponentChild(usize),
    // AttributeString(usize),
}



pub fn create_doenet_core(
    program: &str,
    existing_essential_data: Option<HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>>,
) -> Result<(DoenetCore, Vec<DoenetMLWarning>), DoenetMLError> {

    // Create component nodes and attributes
    let (
        mut component_nodes,
        component_attributes,
        copy_prop_index_instances,
        root_component_name
    ) = parse_json::create_components_tree_from_json(program)?;

    let mut doenet_ml_warnings = vec![];

    log_debug!("Copy prop index instances {:#?}", copy_prop_index_instances);

    // Parse attribute strings and generate components from strings
    // in attributes and string children macros.
    let (component_attributes, copy_index_flags) =
        parse_attributes_and_macros(&mut component_nodes, component_attributes, copy_prop_index_instances);


    let mut group_dependencies = HashMap::new();
    for (component_name, component) in component_nodes.iter() {
        if let Some(group_def) = component.definition.group {

            let deps = (group_def.group_dependencies)(
                &component,
                &component_nodes,
            );

            group_dependencies.insert(component_name.clone(), deps);
        }
    }

    // Check for invalid children component profiles and throw warnings
    for (_, component) in component_nodes.iter() {
        if let ValidChildTypes::ValidProfiles(ref valid_profiles) = component.definition.valid_children_profiles {

            for child in component.children.iter().filter_map(|child| child.as_component()) {
                let child_comp = component_nodes.get(child).unwrap();
                let mut has_valid_profile = false;
                for (child_profile, _) in child_comp.definition.component_profiles.iter() {
                    if valid_profiles.contains(child_profile) {
                        has_valid_profile = true;
                        break;
                    }
                }

                if has_valid_profile == false {
                    doenet_ml_warnings.push(DoenetMLWarning::InvalidChildType {
                        parent_comp_name: component.name.clone(),
                        child_comp_name: child_comp.name.clone(),
                        child_comp_type: child_comp.component_type,
                    });
                }
            }
    
        }

    }


    // Check invalid component names for copy index
    for (_, (source_name, _, _)) in copy_index_flags.iter() {
        if !component_nodes.contains_key(source_name) {
            // The component tried to copy a non-existent component.
            return Err(DoenetMLError::ComponentDoesNotExist {
                comp_name: source_name.to_owned()
            });
        }
    }

    // let mut dynamic_copy_index_flags: HashMap<ComponentName, (ComponentName, StateVarName, Vec<ObjectName>)>;
    
    for (component_name, copy_index_flag) in copy_index_flags {

        let (copy_index_comp, copy_index_array_sv, copy_index_sources) = copy_index_flag;
        let component = component_nodes.get_mut(&component_name).unwrap();

        let first_string_source = copy_index_sources.iter().find_map(|source| {
            if let ObjectName::String(string_source) = source {
                Some(string_source)
            } else {
                None
            }
        });

        if copy_index_sources.len() == 1 && first_string_source.is_some() {

            let source = first_string_source.unwrap();

            let index_number: Option<usize> = if let Ok(valid_result) = evalexpr::eval(&source) {

                if let Ok(valid_num) = valid_result.as_number() {
                    convert_float_to_usize(valid_num)
                } else {
                    None
                }
            } else {
                // return Err(DoenetMLError::NonNumericalPropIndex {
                //     comp_name: component_name,
                //     invalid_index: source.to_owned()
                // });

                None
            };

            let index_number: usize = match index_number {
                Some(valid_index) =>  valid_index,
                None => {
                    doenet_ml_warnings.push(DoenetMLWarning::PropIndexIsNotPositiveInteger {
                        comp_name: component_name,
                        invalid_index: source.to_string()
                    });

                    0
                },
            };
            
            component.copy_source = Some(CopySource::StateVar(
                ComponentRef::Basic(copy_index_comp.to_string()),
                StateRef::ArrayElement(copy_index_array_sv, index_number)
            ));

        } else {

            // let all_index_sources_concatted = copy_index_sources.iter()
            //     .fold(String::new(), |concatted, new_obj| {
            //         format!("{}{}", concatted, match new_obj {
            //             ObjectName::String(v) => v,
            //             ObjectName::Component(v) => v,
            //         })
            //     });

            let variable_components = copy_index_sources.iter().filter_map(|obj| {
                if let ObjectName::Component(comp_name) = obj {
                    Some(comp_name.clone())
                } else {
                    None
                }
            }).collect();

            let expression = MathExpression::new(&copy_index_sources);

            if !expression.can_evaluate_to_number() {
                // return Err(DoenetMLError::NonNumericalPropIndex {
                //     comp_name: component_name,
                //     invalid_index: all_index_sources_concatted
                // });
            }

            component.copy_source = Some(CopySource::DynamicElement(
                copy_index_comp.to_string(),
                copy_index_array_sv,
                expression,
                variable_components,
            ));
        }
    
    }






    // Check for invalid names in both CopySource::Components and CopySource::StateVar
    // Also check that all state var array copies are valid
    let copy_sources = component_nodes.iter().filter_map(|(_, comp)| comp.copy_source.as_ref());
    for copy_source in copy_sources {

        let source_name = match copy_source {
            CopySource::Component(comp_ref) => comp_ref.name(),
            CopySource::StateVar(comp_ref, _) => comp_ref.name(),
            CopySource::DynamicElement(comp_name, ..) => comp_name.clone(),
        };

        if !component_nodes.contains_key(&source_name) {
            // The component tried to copy a non-existent component.
            return Err(DoenetMLError::ComponentDoesNotExist {
                comp_name: source_name.to_owned()
            });
        }


        if let CopySource::StateVar(source_comp_name, source_state_ref) = copy_source {
            let (source_comp_def, _) = component_ref_definition(&component_nodes, &source_comp_name);
            let source_sv_def = source_comp_def.state_var_definitions.get(source_state_ref.name()).unwrap();

            if source_sv_def.is_array() {
                match source_state_ref {
                    StateRef::Basic(_) => {
                        return Err(DoenetMLError::CannotCopyArrayStateVar {
                            source_comp_name: source_comp_name.name(),
                            source_sv_name: source_state_ref.name(),
                        });
    
                    },
                    StateRef::ArrayElement(_, _) => {}, //no error
                    StateRef::SizeOf(_) => unreachable!(),
                }

            } else {
                match source_state_ref {
                    StateRef::Basic(_) => {}, //no error
                    StateRef::ArrayElement(_, _) => {
                        return Err(DoenetMLError::CannotCopyIndexForStateVar {
                            source_comp_name: source_comp_name.name(),
                            source_sv_name: source_state_ref.name(),
                        });
                    },
                    StateRef::SizeOf(_) => unreachable!(),
                }
            }
        }
    }


    // All the components that copy another component, along with the name of the component they copy
    let copy_comp_targets: Vec<(&ComponentNode, &ComponentRef)> = component_nodes.iter().filter_map(|(_, c)|
        match c.copy_source {
            Some(CopySource::Component(ref source)) => Some((c, source)),
            _ => None,
        }
    ).collect();

    // Make sure that the source and target components are the same type
    for (comp, source_comp_name) in copy_comp_targets.iter() {
        let (_, source_comp_type) = component_ref_definition(&component_nodes, source_comp_name);
        if comp.component_type != source_comp_type {
            return Err(DoenetMLError::ComponentCannotCopyOtherType {
                component_name: comp.name.clone(),
                component_type: comp.component_type,
                source_type: &source_comp_type,
            });
        }
    }

    // Check for cyclical dependencies due to CopySource::Component.
    // Otherwise alias and dependency generation could crash.
    for (copy_component, _) in copy_comp_targets.iter() {
        if let Some(cyclic_error) = check_cyclic_copy_source_component(&component_nodes, copy_component) {
            return Err(cyclic_error);
        }
    }

    // Check invalid component names for attributes
    for attributes_for_comp in component_attributes.values() {
        for attributes in attributes_for_comp.values() {
            for attribute_list in attributes.values() {
                for attr_object in attribute_list {

                    if let ObjectName::Component(comp_obj) = attr_object {
                        if !component_nodes.contains_key(comp_obj) {
                            // The component tried to copy a non-existent component.
                            return Err(DoenetMLError::ComponentDoesNotExist {
                                comp_name: comp_obj.to_owned()
                            });
                        }
                    }
                }
            }
        }
    }

    let mut all_state_var_defs: Vec<(&ComponentName, StateVarName, &StateVarVariant)> = Vec::new();
    for (_, comp) in component_nodes.iter() {
        for (sv_name, sv_def) in comp.definition.state_var_definitions {
            all_state_var_defs.push((&comp.name, sv_name, sv_def));
        }
    }

    // let all_state_var_defs = component_nodes.iter()
    //     .flat_map(|(comp_name, comp)| comp.definition.state_var_definitions.iter()
    //         .map(|(sv_name, sv_def)| (comp_name, sv_name, sv_def))
    //     );

    let mut element_specific_dependencies: HashMap<(ComponentRef, StateVarName), Vec<usize>> = HashMap::new();

    for (comp_name, sv_name, sv_def) in all_state_var_defs {
        if sv_def.is_array() {
            let comp = component_nodes.get(comp_name).unwrap();

            let possible_attributes = if let Some(my_own_comp_attrs) = component_attributes.get(comp_name) {
                Some(my_own_comp_attrs)
            } else if let Some(CopySource::Component(_)) = comp.copy_source {
                let final_source = get_recursive_copy_source_component_if_exists(&component_nodes, comp);
                component_attributes.get(final_source)
            } else {
                None
            };

            if let Some(attribute_for_comp) = possible_attributes {
                if let Some(attribute_for_sv) = attribute_for_comp.get(sv_name) {
                    let element_dep_flags: Vec<usize> = attribute_for_sv.iter().map(|(id, _)| *id).collect();
                    element_specific_dependencies.insert(
                        (ComponentRef::Basic(comp_name.to_string()), sv_name),
                        element_dep_flags
                    );
                }
            }
    
        }        
    }
    

    // Fill in component_states and dependencies HashMaps for every component
    // and supply any essential_data required by dependencies.

    let should_initialize_essential_data = existing_essential_data.is_none();
    let mut essential_data = existing_essential_data.unwrap_or(HashMap::new());

    let mut component_states = HashMap::new();
    let mut dependencies = HashMap::new();

    for (component_name, component_node) in component_nodes.iter() {

        let dependencies_for_this_component = create_all_dependencies_for_component(
            &component_nodes,
            component_node,
            component_attributes.get(component_name).unwrap_or(&HashMap::new()),
            // copy_index_flags.get(component_name).as_deref(),
            &mut essential_data,
            should_initialize_essential_data,
            &element_specific_dependencies,
        );

        let state_for_this_component: HashMap<StateVarName, StateForStateVar> =
            component_node.definition.state_var_definitions
            .iter()
            .map(|(&sv_name, sv_variant)| (sv_name, StateForStateVar::new(&sv_variant)))
            .collect();

        dependencies.extend(dependencies_for_this_component);

        component_states.insert(
            component_name.clone(),
            state_for_this_component,
        );
    }


    // Now that the dependency graph has been created, use it to check for cyclical dependencies
    // for all the components
    for (dep_key, _) in dependencies.iter() {
        let DependencyKey::StateVar(comp, sv_ref, _) = dep_key;
        let mut chain = vec![(comp.clone(), sv_ref.clone())];
        let possible_error = check_for_cyclical_dependencies(&dependencies, &mut chain);

        if let Some(error) = possible_error {
            return Err(error);
        }
    }


    log_json!("Components upon core creation",
        utils::json_components(&component_nodes, &component_states));

    log_json!("Dependencies upon core creation",
        utils::json_dependencies(&dependencies));

    log_json!("Essential data upon core creation",
        utils::json_essential_data(&essential_data));

    log_json!("Group dependencies upon core creation",
        &group_dependencies);

    // log_debug!("DoenetCore creation warnings, {:?}", doenet_ml_warnings);

    Ok((DoenetCore {
        component_nodes,
        component_states,
        root_component_name,
        dependencies,
        group_dependencies,
        essential_data,
    }, doenet_ml_warnings))
}


fn check_cyclic_copy_source_component(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,

) -> Option<DoenetMLError> {

    let mut current_comp = component;
    let mut chain = vec![];
    while let Some(CopySource::Component(ref source)) = current_comp.copy_source {

        if chain.contains(&current_comp.name) {
            // Cyclical dependency
            chain.push(current_comp.name.clone());

            let start_index = chain.iter().enumerate().find_map(|(index, name)| {
                if name == &current_comp.name {
                    Some(index)
                } else {
                    None
                }
            }).unwrap();

            let (_, relevant_chain) = chain.split_at(start_index);

            return Some(DoenetMLError::CyclicalDependency {
                component_chain: Vec::from(relevant_chain)
            });


        } else {

            chain.push(current_comp.name.clone());
            current_comp = components.get(&source.name()).unwrap();
        }
    }

    None
}

fn name_child_of_copy(child: &str, copy: &str) -> String {
    format!("__cp:{}({})", child, copy)
}

fn name_macro_component(
    source_name: &str,
    component_name: &String,
    copy_counter: &mut HashMap<ComponentName, usize>,
) -> String {
    let copy_num = copy_counter.entry(source_name.to_string()).or_insert(0);
    *copy_num += 1;

    format!("__mcr:{}({})_{}", source_name, component_name, copy_num)
}

fn name_member_of_group(name: &str, group: &str, index: usize) -> String {
    format!("{}_from_({}[{}])", name, group, index)
}


/// Check for cyclical dependencies, assuming that we have already traversed through the
/// given dependency chain. This function might become slow for larger documents with lots of copies
fn check_for_cyclical_dependencies(
    dependencies: &HashMap<DependencyKey, Vec<Dependency>>,
    dependency_chain: &mut Vec<(ComponentName, StateVarSlice)>,
) -> Option<DoenetMLError> {

    // log_debug!("Dependency chain {:?}", dependency_chain);
    let last_link = dependency_chain.last().unwrap().clone();

    let my_dependencies = dependencies.iter().filter(|(dep_key, _)| {
        let DependencyKey::StateVar(comp, sv_slice, _) = dep_key;
        if comp == &last_link.0 && sv_slice == &last_link.1 {
            true
        } else {
            false
        }
    });

    for (_, dep_list) in my_dependencies {
        for dep in dep_list {
            let new_link = match dep {
                Dependency::StateVar { component_group: component_ref, state_var_slice } => {
                    Some((component_ref.name().clone(), state_var_slice.clone()))
                },
                _ => None,
            };

            if let Some(new_link) = new_link {
                if dependency_chain.contains(&new_link) {
                    // Cyclical dependency!!

                    dependency_chain.push(new_link.clone());
                    log_debug!("Cyclical dependency through {:?} with duplicate {:?}", dependency_chain, new_link);

                    let start_index = dependency_chain.iter().enumerate().find_map(|(index, item)| {
                        if item == &new_link {
                            Some(index)
                        } else {
                            None
                        }
                    }).unwrap();

                    let (_, relevant_chain) = dependency_chain.split_at(start_index);
                    let mut component_chain = vec![];
                    for link in relevant_chain.into_iter() {
                        if component_chain.is_empty() || component_chain.last().unwrap() != &link.0 {
                            component_chain.push(link.0.clone());
                        }
                    }

                    return Some(DoenetMLError::CyclicalDependency {
                        component_chain
                    });

                } else {
                    dependency_chain.push(new_link);
                    let possible_error = check_for_cyclical_dependencies(dependencies, dependency_chain);
                    dependency_chain.pop();

                    if let Some(error) = possible_error {
                        return Some(error);
                    }
                }
            }
        }
    }

    None
}




lazy_static! {
    static ref COMPONENT: Regex = Regex::new(r"[a-zA-Z_]\w*").unwrap();
}
lazy_static! {
    static ref PROP: Regex = Regex::new(r"[a-zA-Z]\w*").unwrap();
}
lazy_static! {
    static ref INDEX: Regex = Regex::new(r" *(\d+|\$)").unwrap();
}
lazy_static! {
    static ref INDEX_END: Regex = Regex::new(r" *]").unwrap();
}
lazy_static! {
    static ref MACRO_BEGIN: Regex = Regex::new(r"\$").unwrap();
}

fn apply_macro_to_string(
    string: &str,
    component_name: &ComponentName,
    components: &HashMap<ComponentName, ComponentNode>,
    macro_copy_counter: &mut HashMap<ComponentName, usize>,
    components_to_add: &mut Vec<ComponentNode>,
) -> Vec<ObjectName> {

    let mut objects = Vec::new();
    let mut previous_end = 0;

    loop {
        if previous_end >= string.len() {
            break;
        }
        let some_next_macro = MACRO_BEGIN.find_at(string, previous_end);
        if some_next_macro.is_none() {
            break;
        }
        let next_macro = some_next_macro.unwrap();

        // Append the regular string until start of macro
        let before = &string[previous_end..next_macro.start()];
        if !before.trim().is_empty() {
            objects.push(ObjectName::String(before.to_string()));
        }

        match macro_comp_ref(string,
            next_macro.end(),
            component_name,
            components,
            macro_copy_counter,
            components_to_add
        ) {
            Ok((macro_name, macro_end)) => {
                previous_end = macro_end;
                objects.push(ObjectName::Component(macro_name));
            },
            Err(msg) => {
                utils::log!("macro failed: {}", msg);
                break;
            }
        }
    }

    // Append until the end
    let last = &string[previous_end..];
    if !last.is_empty() {
        objects.push(ComponentChild::String(last.to_string()));
    }

    objects
}

fn regex_at<'a>(regex: &Regex, string: &'a str, at: usize) -> Result<regex::Match<'a>, String> {
    regex.find_at(string, at)
        .and_then(|m| {
            if m.start() == at {Some(m)} else {None}
        })
        .ok_or(format!("regex {:?} not found at index {} of {}", regex, at, string))
}

fn macro_comp_ref(
    string: &str,
    start: usize,
    macro_parent: &ComponentName,
    components: &HashMap<ComponentName, ComponentNode>,
    macro_copy_counter: &mut HashMap<ComponentName, usize>,
    components_to_add: &mut Vec<ComponentNode>,
) -> Result<(ComponentName, usize), String> {

    log_debug!("macro at {} of {}", start, string);

    let comp_match = regex_at(&COMPONENT, string, start)?;

    let source_name = comp_match.as_str().to_string();
    let source_node = components.get(&source_name).expect(
        &format!("Macro for {}, but this component does not exist", source_name));

    let char_at = |c: usize| string.as_bytes().get(c).map(|c| *c as char);

    // Handle possible component index: brackets after the component name
    let (source_comp_ref, comp_end);
    if char_at(comp_match.end()) == Some('[') {
        let index_match = regex_at(&INDEX, string, comp_match.end() + 1)?;
        let index_str = index_match.as_str();
        let index_end: usize;
        if index_str == "$" {
            // dynamic component index
            panic!("dynamic component index not implemented");
        } else {
            // static component index
            let index: usize = index_str.trim().parse().unwrap();
            index_end = index_match.end() + 1;
            source_comp_ref = ComponentRef::GroupMember(source_name.clone(), index);
        }
        let close_bracket_match = regex_at(&INDEX_END, string, index_end)?;
        comp_end = close_bracket_match.end();
    } else {
        // no component index
        comp_end = comp_match.end();
        source_comp_ref = ComponentRef::Basic(source_name.clone());
    };

    // log_debug!("Getting component definition for {}", source_comp_ref);

    if let ComponentRef::GroupMember(_, _) = source_comp_ref {
        if components.get(&source_comp_ref.name()).unwrap().definition.group.is_none() {
            return Err(format!("Component {} is not a group component", source_comp_ref.name()));
        }    
    }
    let (source_def, source_component_type) = component_ref_definition(components, &source_comp_ref);

    let macro_copy: ComponentNode;
    let macro_end;
    if char_at(comp_end) == Some('.') {
        let prop_match = regex_at(&PROP, string, comp_end + 1)?;
        let prop_name = prop_match.as_str();

        let copy_source: CopySource;
        if let Some(state_ref) = source_def.array_aliases.get(prop_name) {
            // static index from alias
            macro_end = prop_match.end();
            copy_source = CopySource::StateVar(
                source_comp_ref,
                state_ref.clone(),
            );
        } else {

            let (prop_name, _) = source_node
                .definition
                .state_var_definitions
                .get_key_value(prop_name)
                .expect(&format!("Macro asks for non-existent property {}", prop_name));

            // Handle possible prop index: brackets after the prop name
            if string.as_bytes().get(prop_match.end()) == Some(&b'[') {
                let index_match = regex_at(&INDEX, string, prop_match.end() + 1)?;
                let index_str = index_match.as_str().trim();
                // log_debug!("index_str is {}", index_str);
                let index_end: usize;
                if index_str == "$" {
                    // dynamic index
                    let (index_name, index_macro_end) = macro_comp_ref(string,
                        index_match.end(),
                        &source_name,
                        components,
                        macro_copy_counter,
                        components_to_add,
                    )?;

                    index_end = index_macro_end;
                    copy_source = CopySource::DynamicElement(
                        source_name.clone(),
                        prop_name,
                        MathExpression::new(&vec![ObjectName::Component(index_name.clone())]),
                        vec![index_name],
                    );
                } else {
                    // static index
                    let index: usize = index_str.parse().unwrap();
                    index_end = index_match.end();
                    copy_source = CopySource::StateVar(
                        source_comp_ref,
                        StateRef::ArrayElement(prop_name, index),
                    );
                }
                let close_bracket_match = regex_at(&INDEX_END, string, index_end)?;
                macro_end = close_bracket_match.end();
            } else {
                // no index
                macro_end = prop_match.end();
                copy_source = CopySource::StateVar(
                    source_comp_ref,
                    StateRef::Basic(prop_name),
                );
            }
        }

        let source_comp_sv_name = format!("{}:{}", source_name, prop_name);

        let prop_ref = match &copy_source {
            CopySource::StateVar(_, sv) => sv.clone(),
            CopySource::DynamicElement(_, sv_name, _, _) => StateRef::ArrayElement(sv_name, 0),
            _ => unreachable!(),
        };
        let copy_comp_type = default_component_type_for_state_var(source_def, prop_ref)
            .expect(&format!("could not create component for state var copy macro"));

        let copy_def = COMPONENT_DEFINITIONS.get(copy_comp_type).unwrap().clone();

        let copy_name = name_macro_component(
            &source_comp_sv_name,
            macro_parent,
            macro_copy_counter,
        );

        macro_copy = ComponentNode {
            name: copy_name,
            parent: Some(macro_parent.clone()),
            children: vec![],

            copy_source: Some(copy_source),
            component_type: copy_comp_type,
            static_attributes: HashMap::new(),
            definition: copy_def,
        }

    } else {

        let copy_name = name_macro_component(
            &source_name,
            macro_parent,
            macro_copy_counter,
        );

        let static_attributes = match source_comp_ref {
            ComponentRef::Basic(_) => source_node.static_attributes.clone(),
            ComponentRef::GroupMember(_, _) => HashMap::new(),
        };

        macro_end = comp_end;
        macro_copy = ComponentNode {
            name: copy_name,
            parent: Some(macro_parent.clone()),
            children: vec![],

            copy_source: Some(CopySource::Component(
                source_comp_ref,
            )),
            static_attributes,

            component_type: source_component_type,
            definition: source_def,
        }
    };
    let macro_name = macro_copy.name.clone();
    components_to_add.push(macro_copy);

    Ok((macro_name, macro_end))
}

fn parse_attributes_and_macros(
    components: &mut HashMap<ComponentName, ComponentNode>,
    attributes: HashMap<ComponentName, HashMap<AttributeName, String>>,
    copy_prop_index_instances: HashMap<ComponentName, (ComponentName, StateVarName, String)>,
) -> (
    HashMap<ComponentName, HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>>,
    HashMap<ComponentName, (ComponentName, StateVarName, Vec<ObjectName>)>,
    )
{

    use std::iter::repeat;

    // Keyed by the component name and by the original position of the child we are replacing
    let mut replacement_children: HashMap<ComponentName, HashMap<usize, Vec<ObjectName>>> = HashMap::new();
    let mut attributes_parsed = HashMap::new();
    let mut copy_index_flags_parsed = HashMap::new();

    let mut components_to_add: Vec<ComponentNode> = vec![];

    let mut macro_copy_counter: HashMap<ComponentName, usize> = HashMap::new();
    

    // This iterator gives info for every string child
    // (original index of child, string value, component)
    let all_string_children = components.iter()
        .flat_map(|(_, comp)|
            comp.children
            .iter()
            .enumerate()
            .filter_map(|(id, child)| {
                match child {
                    ObjectName::String(string_val) => Some((id, string_val)),
                    _ => None,
                }
            })
            .zip(repeat(comp))
            .map(|((id, val), comp)| (id, val, comp))
        );

    let all_attributes = attributes.iter()
        .flat_map(|(name, attrs)|
            attrs
            .iter()
            .map(|(attr_name, val)| (*attr_name, val, components.get(name).unwrap()))
            .collect::<Vec<(AttributeName, &String, &ComponentNode)>>()
        );

    // Component string children
    for (child_id, string_val, component) in all_string_children {

        let objects = apply_macro_to_string(
            string_val,
            &component.name,
            components,
            &mut macro_copy_counter,
            &mut components_to_add
        );

        // For now, replace everything in the children field
        replacement_children
            .entry(component.name.clone()).or_insert(HashMap::new())
            .entry(child_id).or_insert(objects);
    }

    // Attributes
    for (attribute_name, string_val, component) in all_attributes {

        // The reason this uses a HashMap of usizes instead of another Vec is because
        // later we might want to specify arrays of arrays in the attribute, so the key
        // might be more complicated than an integer.
        let objects: HashMap<usize, Vec<ObjectName>> = string_val.split(' ')
            .enumerate()
            .map(|(index, string_element)|

                // DoenetML is 1-indexed
                (index + 1,

                    apply_macro_to_string(
                        string_element.trim(),
                        &component.name,
                        components,
                        &mut macro_copy_counter,
                        &mut components_to_add,
                    )
                )
            ).collect();

        attributes_parsed
            .entry(component.name.clone()).or_insert(HashMap::new())
            .entry(attribute_name.clone()).or_insert(objects);
    }


    // Copy index flags
    for (target_name, (source_comp_name, source_sv_name, source_index_str)) in copy_prop_index_instances {
        
        let index_objects = apply_macro_to_string(
            &source_index_str,
            &target_name,
            components,
            &mut macro_copy_counter,
            &mut components_to_add
        );

        copy_index_flags_parsed.insert(target_name, (source_comp_name, source_sv_name, index_objects));
    }




    log_debug!("Components to add from macros: {:#?}", components_to_add);

    for new_component in components_to_add {

        debug_assert!( !components.contains_key(&new_component.name) );
        components.insert(new_component.name.clone(), new_component);
    }


    log_debug!("Replacement children {:#?}", replacement_children);

    for (component_name, new_children_hashmap) in replacement_children {
        
        let component = components.get_mut(&component_name).unwrap();

        let mut new_children_vec: Vec<(usize, Vec<ObjectName>)> = new_children_hashmap
            .into_iter()
            .collect();

        // sort by decending order so that splicing does not affect next iteration
        new_children_vec.sort_by(|(a,_),(b,_)| b.cmp(a));

        for (original_child_id, new_children) in new_children_vec.into_iter() {

            // Remove the original element, and add the new children (in order) in its place
            component.children.splice(
                original_child_id..=original_child_id,
                new_children
            );
        }
    }

    log_debug!("Replacement attributes {:#?}", attributes_parsed);

    (attributes_parsed, copy_index_flags_parsed)
}


fn default_component_type_for_state_var(component: &ComponentDefinition, state_var: StateRef)
    -> Result<ComponentType, String> {

    let state_var_def = component.state_var_definitions.get(&state_var.name()).unwrap();
    match (state_var_def, state_var.index()) {
        (StateVarVariant::Boolean(_), StateIndex::Basic) => Ok("boolean"),
        (StateVarVariant::Integer(_), StateIndex::Basic) => Ok("number"),
        (StateVarVariant::NumberArray(_), StateIndex::Element(_)) |
        (StateVarVariant::Number(_), StateIndex::Basic) => Ok("number"),
        (StateVarVariant::StringArray(_), StateIndex::Element(_)) |
        (StateVarVariant::String(_), StateIndex::Basic) => Ok("text"),
        (v, i) => Err(format!("variant {:?} and index {:?} cannot make a component", v, i)),
    }
}


fn create_all_dependencies_for_component(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
    component_attributes: &HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>,
    // copy_index_flag: Option<&(ComponentName, StateVarName, Vec<ObjectName>)>,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
    should_initialize_essential_data: bool,
    element_specific_dependencies: &HashMap<(ComponentRef, StateVarName), Vec<usize>>,
) -> HashMap<DependencyKey, Vec<Dependency>> {

    // log_debug!("Creating dependencies for {}", component.name);
    let mut dependencies: HashMap<DependencyKey, Vec<Dependency>> = HashMap::new();

    let my_definitions = component.definition.state_var_definitions;
    let mut unshadowing_definitions: HashMap<&StateVarName, &StateVarVariant>;

    if let Some(CopySource::DynamicElement(ref source_comp_name, source_sv_array_name, ref expression, ref variable_components)) = component.copy_source {
        // We can't immediately figure out the index, so we need to use the state
        // var propIndex

        let state_var_name = component.definition.primary_input_state_var.unwrap();

        dependencies.extend(
            create_prop_index_dependencies(component, state_var_name, source_comp_name, source_sv_array_name, expression, variable_components, essential_data)
        );

        unshadowing_definitions = my_definitions.iter().filter(|(key, _)| **key != state_var_name).collect();
    } else {
        unshadowing_definitions = my_definitions.iter().collect();
    }

    unshadowing_definitions.remove(&PROP_INDEX_SV);

    // log_debug!("Unshadowing definitions for {} {:?}", component.name, unshadowing_definitions);

    for (&state_var_name, state_var_variant) in unshadowing_definitions {

        if state_var_variant.is_array() {

            let size_dep_instructions = state_var_variant
                .return_size_dependency_instructions(HashMap::new());

            for (instruct_name, ref dep_instruction) in size_dep_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components,
                    component,
                    component_attributes,
                    &StateVarSlice::Single(StateRef::SizeOf(state_var_name)),
                    dep_instruction,
                    instruct_name,
                    essential_data,
                    should_initialize_essential_data,
                );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Single(StateRef::SizeOf(state_var_name)),
                        instruct_name
                    ),
                    instruct_dependencies,
                );

            }

            let array_dep_instructions = state_var_variant
                .return_array_dependency_instructions(HashMap::new());

            for (instruct_name, ref dep_instruction) in array_dep_instructions.into_iter() {
                let instruct_dependencies =
                    create_dependencies_from_instruction(
                        &components,
                        component,
                        component_attributes,
                        &StateVarSlice::Array(state_var_name),
                        dep_instruction,
                        instruct_name,
                        essential_data,
                        should_initialize_essential_data
                    );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Array(state_var_name),
                        instruct_name,
                    ),
                    instruct_dependencies,
                );
            }

            // make dependencies for elements when size has an essential value
            // let elements = {
                // let source_comp_name = get_essential_data_component_including_copy(components, component);

                // let size = essential_data
                //     .get(source_comp_name)
                //     .and_then(|c| c
                //         .get(&EssentialDataOrigin::StateVar(state_var_name))
                //         .and_then(|s| s
                //             .get_value(StateIndex::SizeOf)
                //             .and_then(|v|
                //                 usize::try_from(v).ok()
                //             )
                //         )
                //     ).unwrap_or(0);

                // indices_for_size(size)
            // };
            let empty = &Vec::new();

            let elements = element_specific_dependencies.get(&(ComponentRef::Basic(component.name.clone()), state_var_name)).unwrap_or(empty);

            log_debug!("Will make dependencies for elements {:?} of {}:{}", elements, component.name, state_var_name);

            for &index in elements {

                let element_dep_instructions = state_var_variant
                    .return_element_dependency_instructions(index, HashMap::new());

                for (instruct_name, ref dep_instruction) in element_dep_instructions.into_iter() {
                    let instruct_dependencies =
                        create_dependencies_from_instruction(
                            &components,
                            component,
                            component_attributes,
                            &StateVarSlice::Single(StateRef::ArrayElement(state_var_name, index)),
                            dep_instruction,
                            instruct_name,
                            essential_data,
                            should_initialize_essential_data
                        );

                    dependencies.insert(
                        DependencyKey::StateVar(
                            component.name.clone(),
                            StateVarSlice::Single(StateRef::ArrayElement(state_var_name, index)),
                            instruct_name,
                        ),
                        instruct_dependencies,
                    );
                }
            }


        } else {

            let dependency_instructions = return_dependency_instructions_including_shadowing(component, &StateRef::Basic(state_var_name));

            for (instruct_name, ref dep_instruction) in dependency_instructions.into_iter() {
                let instruct_dependencies = create_dependencies_from_instruction(
                    &components,
                    component,
                    component_attributes,
                    &StateVarSlice::Single(StateRef::Basic(state_var_name)),
                    dep_instruction,
                    instruct_name,
                    essential_data,
                    should_initialize_essential_data
                );

                dependencies.insert(
                    DependencyKey::StateVar(
                        component.name.clone(),
                        StateVarSlice::Single(StateRef::Basic(state_var_name)),
                        instruct_name,
                    ),
                    instruct_dependencies   
                );
            }

        }
    }

    dependencies

}


/// This function also creates essential data when a DependencyInstruction asks for it.
/// The second return is element specific dependencies.
fn create_dependencies_from_instruction(
    components: &HashMap<ComponentName, ComponentNode>,
    component: &ComponentNode,
    component_attributes: &HashMap<AttributeName, HashMap<usize, Vec<ObjectName>>>,
    state_var_slice: &StateVarSlice,
    instruction: &DependencyInstruction,
    instruction_name: InstructionName,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
    should_initialize_essential_data: bool,
) -> Vec<Dependency> {

    log_debug!("Creating dependency {}:{}:{} from instruction {:?}", component.name, state_var_slice, instruction_name, instruction);

    let mut dependencies: Vec<Dependency> = Vec::new();

    match &instruction {

        DependencyInstruction::Essential { prefill } => {

            let source_comp_name = get_recursive_copy_source_component_if_exists(components, component);
            let essential_origin = EssentialDataOrigin::StateVar(state_var_slice.name());

            if should_initialize_essential_data && source_comp_name == &component.name {
                // Components only create their own essential data

                let sv_def = component.definition.state_var_definitions.get(state_var_slice.name()).unwrap();

                let initial_data = match prefill {
                    Some(string) => {
                        let attribute = component_attributes
                            .get(string)
                            .map(|x| match x.get(&1).unwrap().first().unwrap() {
                                ObjectName::String(attr_string) => attr_string.clone(),
                                _ => String::new(),
                            })
                            .unwrap_or(String::new());

                        StateVarValue::String(attribute)
                    },
                    None => sv_def.initial_essential_value(),
                };

                let initial_data = if sv_def.is_array() {
                    InitialEssentialData::Array(Vec::new(), initial_data)
                } else {
                    InitialEssentialData::Single(initial_data)
                };
    
                create_essential_data_for(
                    &source_comp_name,
                    essential_origin.clone(),
                    initial_data,
                    essential_data
                );

            }

            dependencies.push(Dependency::Essential {
                component_name: source_comp_name.clone(),
                origin: essential_origin,
            });

        },

        DependencyInstruction::StateVar { component_ref, state_var } => {

            let component_ref = match component_ref {
                Some(name) => name.clone(),
                None => ComponentRef::Basic(component.name.clone()),
            };

            dependencies.push(
                Dependency::StateVar {
                    component_group: ComponentGroup::Single(component_ref),
                    state_var_slice: state_var.clone(),
                }
            );

        },

        DependencyInstruction::Child { desired_profiles, parse_into_expression } => {

            let children = get_children_including_copy(components, component);



            let mut relevant_children:
                // (object name, actual parent, relevant profile state var)
                Vec<(&ObjectName, &ComponentName, Option<StateVarName>)> = Vec::new();

            for child in children.iter() {

                match child {
                    (ComponentChild::Component(child_name), _) => {

                        let child_node = components.get(child_name).unwrap();

                        let component_group = match child_node.definition.group {
                            Some(_) => ComponentGroup::Group(child_name.clone()),
                            None => ComponentGroup::Single(ComponentRef::Basic(child_name.clone())),
                        };
                        let (child_def, _) = group_member_definition(
                            components,
                            &component_group
                        );
            

                        for child_profile in child_def.component_profiles.iter() {
                            if desired_profiles.contains(&child_profile.0) {

                                relevant_children.push(
                                    (&child.0, &child.1.name, Some(child_profile.1))
                                );
                                break;
                            }
                        }
                    },
                    (ComponentChild::String(_), actual_parent) => {
                        if desired_profiles.contains(&ComponentProfile::Text)
                            || desired_profiles.contains(&ComponentProfile::Number) {
                            relevant_children.push((&child.0, &actual_parent.name, None));
                        }
                    },
                }
            }


            if *parse_into_expression {

                // Assuming for now that expression is math expression
                let expression = MathExpression::new(
                    &relevant_children.iter().map(|child| child.0.clone()).collect()
                );

                // Assuming that no other child instruction exists which has already filled
                // up the child essential data
                let essential_origin = EssentialDataOrigin::ComponentChild(0);

                if should_initialize_essential_data {
                    create_essential_data_for(
                        &component.name,
                        essential_origin.clone(),
                        InitialEssentialData::Single(
                            StateVarValue::MathExpr(expression),
                        ),
                        essential_data
                    );    
                }

                dependencies.push(Dependency::Essential {
                    component_name: component.name.clone(), origin: essential_origin,
                });

                // We already dealt with the essential data, so now only retain the component children
                relevant_children.retain(|child| matches!(child.0, ObjectName::Component(_)));
                
            }

            // Stores how many string children added per parent.
            let mut essential_data_numbering: HashMap<ComponentName, usize> = HashMap::new();

            for (child, actual_parent, profile_sv) in relevant_children {

                match child {

                    ComponentChild::Component(child_name) => {
                        let child_node = components.get(child_name).unwrap();
                        let profile_state_var = profile_sv.unwrap();

                        let component_group = match child_node.definition.group {
                            Some(_) => ComponentGroup::Group(child_name.clone()),
                            None => ComponentGroup::Single(ComponentRef::Basic(child_name.clone())),
                        };

                        let (child_def, _) = group_member_definition(
                            components,
                            &component_group
                        );

                        let sv_def = child_def
                            .state_var_definitions
                            .get(profile_state_var)
                            .unwrap();

                        dependencies.push(Dependency::StateVar {
                            component_group,
                            // component_name: child_name.to_string(),
                            state_var_slice: if sv_def.is_array() {
                                StateVarSlice::Array(profile_state_var)
                            } else {
                                StateVarSlice::Single(StateRef::Basic(profile_state_var))
                            }
                        });
                    },

                    ComponentChild::String(string_value) => {
                        if desired_profiles.contains(&ComponentProfile::Text) {

                            let index = essential_data_numbering
                                .entry(actual_parent.clone()).or_insert(0 as usize);

                            let essential_origin = EssentialDataOrigin::ComponentChild(*index);


                            if should_initialize_essential_data && &component.name == actual_parent {
                                // Components create their own essential data

                                let value = StateVarValue::String(string_value.clone());
                                create_essential_data_for(
                                    actual_parent,
                                    essential_origin.clone(),
                                    InitialEssentialData::Single(value),
                                    essential_data
                                );
                            }

                            dependencies.push(Dependency::Essential {
                                component_name: actual_parent.clone(),
                                origin: essential_origin,
                            });

                            *index += 1;

                        }
                    },

                }
            }
            

        },
        DependencyInstruction::Parent { state_var } => {

            let desired_state_var = state_var;

            let parent_name = component.parent.clone().expect(&format!(
                "Component {} doesn't have a parent, but the dependency instruction {}:{} asks for one.",
                    component.name, state_var_slice, instruction_name
            ));

            let parent_component = components.get(&parent_name).unwrap();

            // Look up what kind of child state var it is
            // If the state var is an array, depend on the array, otherwise as normal

            let sv_def = parent_component.definition.state_var_definitions.get(desired_state_var).unwrap();

            dependencies.push(Dependency::StateVar {
                component_group: ComponentGroup::Single(ComponentRef::Basic(parent_name.to_string())),
                state_var_slice: if sv_def.is_array() {
                    StateVarSlice::Array(desired_state_var)
                } else {
                    StateVarSlice::Single(StateRef::Basic(desired_state_var))
                }
            });

        },


        DependencyInstruction::Attribute { attribute_name, index } => {

            log_debug!("Getting attribute {} for {}:{}", attribute_name, component.name, state_var_slice);
            let state_var_name = state_var_slice.name();
            let state_var_ref = StateRef::from_name_and_index(state_var_name, *index);
            let sv_def = component.definition.state_var_definitions.get(state_var_name).unwrap();
            let essential_origin = EssentialDataOrigin::StateVar(state_var_name);


            let default_value = if matches!(sv_def, 
                StateVarVariant::NumberArray(_) | StateVarVariant::Number(_) | StateVarVariant::Integer(_)
            ) {
                StateVarValue::MathExpr(MathExpression::new(
                    &vec![ObjectName::String(match sv_def.initial_essential_value() {
                        StateVarValue::Number(v) => v.to_string(),
                        StateVarValue::Integer(v) => v.to_string(),
                        _ => unreachable!(),
                    })]
                ))
            } else {
                sv_def.initial_essential_value()
            };


            let get_value_from_object_list = |obj_list: &Vec<ObjectName>| -> StateVarValue {

                if matches!(sv_def, StateVarVariant::Number(_)
                    | StateVarVariant::NumberArray(_)
                    | StateVarVariant::Integer(_)
                ) {
                    StateVarValue::MathExpr(
                        MathExpression::new(obj_list)
                    )
                } else if obj_list.len() > 0 {

                    let first_obj = obj_list.get(0).unwrap();
                    if obj_list.len() > 1 {
                        unimplemented!("Multiple objects for non number state var");
                    }
                    match first_obj {
                        ObjectName::String(str_val) => {
                            package_string_as_state_var_value(str_val.to_string(), sv_def).unwrap()
                        }
                        _ => default_value.clone()
                    }
                } else {
                    default_value.clone()
                }
            };

            if let Some(attribute) = component_attributes.get(*attribute_name) {
                // attribute specified
                log_debug!("attribute {:?}", attribute);

                // Create the essential data if it does not exist yet
                if should_initialize_essential_data && !essential_data_exists_for(&component.name, &essential_origin, essential_data) {

                    if sv_def.is_array() {

                        let mut essential_attr_objs: Vec<StateVarValue> = Vec::new();
                        
                        for (id, obj_list) in attribute {

                            let value = get_value_from_object_list(obj_list);

                            if *id > essential_attr_objs.len() {
                                essential_attr_objs.resize(*id, default_value.clone());
                            }
                            essential_attr_objs[id - 1] = value;

                        }

                        log_debug!("essential attributes {:?}", essential_attr_objs);

                        let initial_essential_data = InitialEssentialData::Array(essential_attr_objs, default_value);

                        create_essential_data_for(
                            &component.name,
                            essential_origin.clone(),
                            initial_essential_data,
                            essential_data,
                        );

                    } else {

                        assert_eq!(attribute.keys().len(), 1);
                        let obj_list = attribute.get(&1).unwrap();

                        log_debug!("Initializing non-array essential data for {}:{} from attribute data {:?}", component.name, state_var_name, obj_list);

                        let value = get_value_from_object_list(obj_list);
                        
                        create_essential_data_for(
                            &component.name,
                            essential_origin.clone(),
                            InitialEssentialData::Single(value),
                            essential_data,
                        );
                    };
                }



                if let StateIndex::SizeOf = index {

                    dependencies.push(Dependency::Essential {
                        component_name: component.name.clone(),
                        origin: essential_origin,
                    });
                
                } else {

                    let attribute_index = match index {
                        StateIndex::Element(i) => *i,
                        _ => 1,
                    };

                    let attr_objects = attribute.get(&attribute_index)
                        .expect(&format!("attribute {}:{} does not have index {}. Attribute: {:?}",
                            &component.name, attribute_name, &attribute_index, attribute));

                    let relevant_attr_objects = if matches!(sv_def,
                        StateVarVariant::Number(_) | StateVarVariant::NumberArray(_) | StateVarVariant::Integer(_)
                    ) {
                        // First add an essential dependency to the expression
                        dependencies.push(Dependency::Essential {
                            component_name: component.name.clone(),
                            origin: essential_origin.clone(),
                        });

                        attr_objects.into_iter().filter_map(
                            |obj| if matches!(obj, ObjectName::Component(_)) {
                                Some(obj.clone())
                            } else {
                                None
                            }
                        ).collect()
                    } else {
                        attr_objects.clone()
                    };

                    for attr_object in relevant_attr_objects {

                        let dependency = match attr_object {
                            ObjectName::String(_) => Dependency::Essential {
                                component_name: component.name.clone(),
                                origin: essential_origin.clone(),
                            },
                            ObjectName::Component(comp_name) => {
                                let comp = components.get(&comp_name).unwrap();
                                let primary_input_sv = comp.definition.primary_input_state_var.expect(
                                    &format!("An attribute cannot depend on a non-primitive component. Try adding '.value' to the macro.")
                                );
    
                                Dependency::StateVar {
                                    component_group: ComponentGroup::Single(ComponentRef::Basic(comp_name.clone())),
                                    state_var_slice: StateVarSlice::Single(StateRef::Basic(primary_input_sv)),
                                }
                            },
                        };

                        dependencies.push(dependency);
                    }
                    
                }
            } else if let Some(CopySource::Component(c)) = &component.copy_source {

                // inherit attribute from copy source
                dependencies.push(Dependency::StateVar {
                    component_group: ComponentGroup::Single(ComponentRef::Basic(c.name())),
                    state_var_slice: StateVarSlice::Single(state_var_ref),
                });
            } else {

                // let value = get_value_from_object_list(&vec![]);

                if should_initialize_essential_data {
                    create_essential_data_for(
                        &component.name,
                        EssentialDataOrigin::StateVar(state_var_name),
                        InitialEssentialData::Single(default_value),
                        essential_data
                    );    
                }

                dependencies.push(Dependency::Essential {
                    component_name: component.name.clone(),
                    origin: essential_origin,
                });

            }
        },

    }
    dependencies
}



fn create_prop_index_dependencies(
    component: &ComponentNode,
    state_var_name: StateVarName,
    source_comp_name: &ComponentName,
    source_sv_array_name: StateVarName,
    math_expression: &MathExpression,
    variable_components: &Vec<ComponentName>,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
)
-> HashMap<DependencyKey, Vec<Dependency>> {
    use base_definitions::*;

    let mut dependencies = HashMap::new();

    // Dependency on propIndex for target component state var
    dependencies.insert(
        DependencyKey::StateVar(
            component.name.clone(),
            StateVarSlice::Single(StateRef::Basic(state_var_name)),
            SHADOW_INSTRUCTION_NAME
        ),
        vec![Dependency::StateVarArrayDynamicElement {
            component_name: source_comp_name.to_string(),
            array_state_var_name: source_sv_array_name,
            index_state_var: StateRef::Basic(PROP_INDEX_SV),
        }]
    );

    // Dependencies on source components for propIndex
    dependencies.insert(
        DependencyKey::StateVar(
            component.name.clone(),
            StateVarSlice::Single(StateRef::Basic(PROP_INDEX_SV)),
            PROP_INDEX_VARS_INSTRUCTION
        ),
        variable_components.iter().map(|comp_name| {
            Dependency::StateVar {
                component_group: ComponentGroup::Single(ComponentRef::Basic(comp_name.to_string())),
                state_var_slice: StateVarSlice::Single(StateRef::Basic("value")),
            }
        }).collect()
    );

    let origin = EssentialDataOrigin::StateVar(PROP_INDEX_SV);

    create_essential_data_for(
        &component.name,
        origin.clone(),
        InitialEssentialData::Single(StateVarValue::MathExpr(math_expression.clone())),
        essential_data,
    );

    // Dependency on math expression for propIndex
    dependencies.insert(
        DependencyKey::StateVar(
            component.name.clone(),
            StateVarSlice::Single(StateRef::Basic(PROP_INDEX_SV)),
            PROP_INDEX_EXPR_INSTRUCTION
        ),
        vec![Dependency::Essential {
            component_name: component.name.clone(),
            origin,
        }]
    );

    dependencies
}


fn package_string_as_state_var_value(input_string: String, state_var_variant: &StateVarVariant) -> Result<StateVarValue, String> {


    let package_into_number_sv_value = |input_str| {
        if let Ok(val) = evalexpr::eval_number(input_str) {
            Ok(StateVarValue::Number(val))
        } else {
            Err(format!("Cannot package string {} as number", input_str))
        }
    };

    let package_into_integer_sv_value = |input_str| {
        if let Ok(val) = evalexpr::eval_int(input_str) {
            Ok(StateVarValue::Integer(val))
        } else {
            Err(format!("Cannot package string {} as integer", input_str))
        }
    };

    match state_var_variant {
        StateVarVariant::StringArray(_) |
        StateVarVariant::String(_) => {
            Ok(StateVarValue::String(input_string))
        },

        StateVarVariant::Boolean(_) => {

            if input_string == "true" {
                Ok(StateVarValue::Boolean(true))
            } else if input_string == "false" {
                Ok(StateVarValue::Boolean(false))
            } else {
                Err(format!("Cannot evaluate string {} as boolean", input_string))
            }
        },

        StateVarVariant::Integer(_) => {
            package_into_integer_sv_value(&input_string)
        },

        StateVarVariant::NumberArray(_) |
        StateVarVariant::Number(_) => {
            package_into_number_sv_value(&input_string)
        },
    }
}


enum InitialEssentialData {
    Single(StateVarValue),
    Array(Vec<StateVarValue>, StateVarValue),
}

/// Add (or update) essential data for a state variable or string child.
/// Returns the dependency.
fn create_essential_data_for(
    component_name: &ComponentName,
    origin: EssentialDataOrigin,
    initial_values: InitialEssentialData,
    essential_data: &mut HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>,
) {

    if let Some(comp_essential_data) = essential_data.get(component_name) {
        assert!( !comp_essential_data.contains_key(&origin) );
    }

    let essential_state = match initial_values {
        InitialEssentialData::Single(value) => EssentialStateVar::new_single_basic_with_state_var_value(value),
        InitialEssentialData::Array(values, default_fill_value) => EssentialStateVar::new_array_with_state_var_values(values, default_fill_value),
    };

    log_debug!("New essential data for {} {:?} {:?}", component_name, origin, essential_state);

    essential_data
        .entry(component_name.clone())
        .or_insert(HashMap::new())
        .entry(origin.clone())
        .or_insert(essential_state);
}

fn essential_data_exists_for(
    component_name: &ComponentName,
    origin: &EssentialDataOrigin,
    essential_data: &HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>
) -> bool {

    if let Some(comp_essen) = essential_data.get(component_name) {
        if let Some(_) = comp_essen.get(origin) {
            true
        } else {
            false
        }
    } else {
        false
    }
}


/// Calculate all the (normal) state vars that depend on the given state var
fn get_state_variables_depending_on_me<'a>(
    core: &'a DoenetCore,
    sv_component: &ComponentName,
    sv_reference: &StateRef,
) -> Vec<(ComponentName, &'a StateVarSlice)> {

    let mut depending_on_me = vec![];

    for (dependency_key, dependencies) in core.dependencies.iter() {

        for dependency in dependencies {

            match dependency {
                Dependency::StateVar { component_group, state_var_slice } => {
                    if sv_component == &component_group.name() 
                    && state_var_slice.name() == sv_reference.name() {

                        let DependencyKey::StateVar(dependent_comp, dependent_group, _) = dependency_key;
                        depending_on_me.push((dependent_comp.clone(), dependent_group));
                    }
                },

                Dependency::StateVarArrayDynamicElement {
                    component_name,
                    array_state_var_name,
                    ..
                } => {

                    let this_array_refers_to_me = 
                        component_name == sv_component
                        && *array_state_var_name == sv_reference.name();

                    let i_am_prop_index_of_this_dependency = 
                        // The key that this dependency is under is myself
                        // Aka, the index is supposed to be in my component, not another component
                        dependency_key.component_name() == sv_component
                        // I am actually a propIndex, and not some other state var
                        && sv_reference == &StateRef::Basic("propIndex");

                    if this_array_refers_to_me || i_am_prop_index_of_this_dependency {

                        let DependencyKey::StateVar(dependent_comp, dependent_group, _) = dependency_key;
                        depending_on_me.push((dependent_comp.clone(), dependent_group));
                    }
    

                }

                // Essential and String dependencies are endpoints
                _ => {},

            }
        }
    }

    // a state var can depend on this through a group member
    for comp_name in groups_depending_on_state_var(core, sv_component, sv_reference) {
        depending_on_me.extend(
            state_vars_depending_on_group(core, &comp_name)
        );
    }

    depending_on_me
}

fn groups_depending_on_state_var(
    core: &DoenetCore,
    sv_component: &ComponentName,
    sv_reference: &StateRef,
) -> Vec<ComponentName> {

    let mut depending_on_me = vec![];

    for (comp_name, group_deps) in core.group_dependencies.iter() {
        for group_dep in group_deps {
            let depends_on = match group_dep {
                GroupDependency::StateVar(comp, name) => {
                    &comp.name() == sv_component && name.name() == sv_reference.name()
                },
                GroupDependency::Component(comp_name) |
                GroupDependency::Group(comp_name) => {
                    comp_name == sv_component
                },
            };
            if depends_on {
                depending_on_me.extend(
                    group_and_groups_depending_on_it(core, comp_name)
                );
            }
        }
    }
    depending_on_me
}

fn group_and_groups_depending_on_it(
    core: &DoenetCore,
    group_name: &ComponentName,
) -> Vec<ComponentName> {

    let mut depending_on_me = vec![group_name.clone()];

    for (comp_name, group_deps) in core.group_dependencies.iter() {
        for group_dep in group_deps {
            let depends_on = match group_dep {
                GroupDependency::Component(comp_name) |
                GroupDependency::Group(comp_name) => comp_name == group_name,
                _ => false,
            };
            if depends_on {
                depending_on_me.extend(
                    group_and_groups_depending_on_it(core, comp_name)
                );
            }
        }
    }
    depending_on_me
}

fn state_vars_depending_on_group<'a>(
    core: &'a DoenetCore,
    group_name: &ComponentName,
) -> Vec<(ComponentName, &'a StateVarSlice)> {

    let mut depending_on_me = vec![];

    for (dependency_key, dependencies) in core.dependencies.iter() {
        for dependency in dependencies {

            match dependency {
                Dependency::StateVar { component_group, .. } => {
                    match component_group {
                        ComponentGroup::Single(c) => {
                            if c.name() == *group_name {
                                // depending on me directly
                                let DependencyKey::StateVar(dependent_comp, dependent_group, _) = dependency_key;
                                depending_on_me.push((dependent_comp.clone(), dependent_group));
                            }
                        }
                        ComponentGroup::Group(name) => {
                            if name == group_name {
                                // depending on me as a member of a group
                                let DependencyKey::StateVar(dependent_comp, dependent_group, _) = dependency_key;
                                depending_on_me.push((dependent_comp.clone(), dependent_group));
                            }
                        },
                    }
                },
                _ => ()
            };

        }
    }

    depending_on_me
}

// TODO: Use &Dependency instead of cloning
fn dependencies_of_state_var(
    dependencies: &HashMap<DependencyKey, Vec<Dependency>>,
    component_name: &ComponentName,
    state_var_slice: &StateVarSlice,
) -> HashMap<InstructionName, Vec<Dependency>> {

    let deps = dependencies.iter().filter_map(| (key, deps) |

        match key {
            DependencyKey::StateVar(comp_name, sv_slice, instruct_name) => {

                // Check if the key is me
                if comp_name == component_name {
                    if sv_slice == state_var_slice {
                        Some((*instruct_name, deps))

                    } else if let StateVarSlice::Single(StateRef::ArrayElement(..)) = state_var_slice {

                        // The key might also be an array who feeds into me
                        if let StateVarSlice::Array(array_name) = sv_slice {
                            if state_var_slice.name() == *array_name {
                                Some((*instruct_name, deps))
                            } else {
                                None
                            }
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                } else {
                    None
                }
            },
        }
    );

    // log_debug!("Deps for {}:{} with possible duplicates {:?}", component_name, state_var_slice, deps.clone().collect::<HashMap<InstructionName, &Vec<Dependency>>>());

    let mut combined: HashMap<InstructionName, Vec<Dependency>> = HashMap::new();
    for (k, v) in deps {
        if let Some(accum) = combined.get_mut(k) {
            let dedup: Vec<Dependency> = v.clone().into_iter().filter(|x| !accum.contains(x)).collect();
            accum.extend(dedup);
        } else {
            combined.insert(k, v.clone());
        }
    }
    
    // log_debug!("Dependencies for {}:{} {:?}", component_name, state_var_slice, combined);

    combined
}


fn get_source_for_dependency(
    core: &DoenetCore,
    dependency: &Dependency,
    essential_data: &HashMap<ComponentName, HashMap<EssentialDataOrigin, EssentialStateVar>>
) -> DependencySource {

    match dependency {
        Dependency::Essential { component_name, origin } => {
            match origin {

                EssentialDataOrigin::StateVar(_) => {
                    let data = essential_data.get(component_name).unwrap().get(origin).unwrap();
                    // let variant = components
                    //     .get(component_name).unwrap()
                    //     .definition
                    //     .state_var_definitions
                    //     .get(sv_name).unwrap();

                    DependencySource::Essential {
                        value_type: data.get_type_as_str()
                    }
                },
                _ => {
                    DependencySource::Essential{ value_type: "string", }
                },
            
            }
        },

        Dependency::StateVar { component_group, state_var_slice } => {
            let (_, component_type) = group_member_definition(
                &core.component_nodes,
                component_group,
            );

            DependencySource::StateVar {
                component_type,
                state_var_name: state_var_slice.name()
            }
        },

        Dependency::StateVarArrayDynamicElement { component_name, array_state_var_name, .. } => {
            let component_type = core.component_nodes.get(component_name).unwrap().component_type;
            DependencySource::StateVar {
                component_type,
                state_var_name: &array_state_var_name
            }
        }

    }
}

/// Also includes the values of essential data
fn get_dependency_sources_for_state_var(
    core: &DoenetCore,
    component_name: &ComponentName,
    state_ref: &StateRef,
) -> HashMap<InstructionName, Vec<(DependencySource, Option<StateVarValue>)>> {
    
    let my_dependencies = dependencies_of_state_var(&core.dependencies, component_name, &StateVarSlice::Single(state_ref.clone()));
    let mut dependency_sources: HashMap<InstructionName, Vec<(DependencySource, Option<StateVarValue>)>> = HashMap::new();

    for (instruction_name, dependencies) in my_dependencies {
        let instruction_sources: Vec<(DependencySource, Option<StateVarValue>)> = dependencies.iter().map(|dependency| {
            let source = get_source_for_dependency(core, &dependency, &core.essential_data);

            let essential_value = if let Dependency::Essential { origin, .. } = dependency {
                let data = core.essential_data
                    .get(component_name).unwrap()
                    .get(origin).unwrap();
                let value = data.get_value(state_ref.index()).unwrap();
                Some(value)

            } else {
                None
            };

            (source, essential_value)
        }).collect();

        dependency_sources.insert(instruction_name, instruction_sources);
    }

    dependency_sources
}

fn resolve_state_variable(
    core: &DoenetCore,
    component: &ComponentName,
    state_var_ref: &StateRef,
) -> Option<StateVarValue> {

    let state_vars = core.component_states.get(component).unwrap();

    // No need to continue if the state var is already resolved or if the element does not exist
    let current_state = state_vars.get(state_var_ref.name())
        .expect(&format!("Component {} has no state var '{:?}'", component, state_var_ref))
        .get_single_state(&state_var_ref.index())
        .expect(&format!("Error accessing state of {}:{:?}", component, state_var_ref));

    if let Some(State::Resolved(current_value)) = current_state {
        return Some(current_value);

    } else if current_state.is_none() {
        // There is nothing to resolve
        log_debug!("{}:{} does not exist", component, state_var_ref);
        return None
    }

    log_debug!("Resolving {}:{}", component, state_var_ref);

    let my_dependencies = dependencies_of_state_var(&core.dependencies, component, &StateVarSlice::Single(state_var_ref.clone()));

    log_debug!("Dependencies of {}:{} {:?}", component, state_var_ref, my_dependencies);

    let mut dependency_values: HashMap<InstructionName, Vec<DependencyValue>> = HashMap::new();

    for (dep_name, deps) in my_dependencies {

        let mut values_for_this_dep: Vec<DependencyValue> = Vec::new();

        for dep in deps {

            let dependency_source = get_source_for_dependency(core, &dep, &core.essential_data);

            match dep {

                Dependency::StateVar { component_group , state_var_slice } => {

                    for component_ref in component_group_members(core, &component_group) {
                        let (sv_comp, sv_slice) = convert_component_ref_state_var(core, &component_ref, state_var_slice.clone()).unwrap();

                        match sv_slice {
                            StateVarSlice::Single(ref sv_ref) => {

                                let depends_on_value = resolve_state_variable(core, &sv_comp, sv_ref);

                                if let Some(depends_on_value) = depends_on_value {
                                    values_for_this_dep.push(DependencyValue {
                                        source: dependency_source.clone(),
                                        value: depends_on_value.clone(),
                                    });    
                                }
                            }
                            StateVarSlice::Array(array_state_var_name) => {

                                // important to resolve the size before the elements
                                let size_value: usize = resolve_state_variable(
                                    core, &sv_comp, &StateRef::SizeOf(array_state_var_name))
                                .expect("Array size should always resolve to a StateVarValue")
                                .try_into()
                                .unwrap();
                                
                                for id in indices_for_size(size_value) {

                                    let element_value = resolve_state_variable(
                                        core,
                                        &sv_comp,
                                        &StateRef::ArrayElement(array_state_var_name, id)
                                    );

                                    if let Some(element_value) = element_value {
                                        values_for_this_dep.push(DependencyValue {
                                            source: dependency_source.clone(),
                                            value: element_value.clone(),
                                        });
                
                                    }
                
                                }
                            }
                        }
                    }

                },

                Dependency::Essential { component_name, origin } => {

                    let index = match origin {
                        EssentialDataOrigin::StateVar(_) => state_var_ref.index(),
                        _ => StateIndex::Basic,
                    };

                    let value = core.essential_data
                        .get(&component_name).unwrap()
                        .get(&origin).unwrap()
                        .clone()
                        .get_value(index);
    
                    if let Some(value) = value {
                        values_for_this_dep.push(DependencyValue {
                            source: dependency_source,
                            value,
                        })
                    }
                },

                Dependency::StateVarArrayDynamicElement { component_name, array_state_var_name, index_state_var } => {

                    let index_value = resolve_state_variable(
                        core,
                        component, // myself
                        &index_state_var,
                    );

                    let index: Option<usize> = if let Some(index_value) = index_value {

                        let index_num: f64 = index_value.try_into().unwrap();
                        convert_float_to_usize(index_num)

                    } else {
                        None
                    };

                    if let Some(index) = index {

                        log_debug!("got prop index which is {}", index);

                        let element_value = resolve_state_variable(
                            core,
                            &component_name,
                            &StateRef::ArrayElement(array_state_var_name, index)
                        );

                        log_debug!("element value is {:?}", element_value);

                        if let Some(element_value) = element_value {
                            values_for_this_dep.push(DependencyValue {
                                source: dependency_source,
                                value: element_value.clone(),
                            });
                        }
                    }





                }
            }
        }

        dependency_values.insert(dep_name, values_for_this_dep);
    }


    log_debug!("Dependency values for {}:{}: {:#?}", &component, state_var_ref, dependency_values);

    let node = core.component_nodes.get(component).unwrap();

    let update_instruction = generate_update_instruction_including_shadowing(
        node,
        state_var_ref,
        dependency_values
    ).expect(&format!("Can't resolve {}:{} (a {} component type)",
        component, state_var_ref, node.component_type)
    );

    let new_value = handle_update_instruction(component,  state_var_ref, state_vars, update_instruction);

    return new_value;
}

/// This must resolve the size
fn elements_of_array(
    core: &DoenetCore,
    component: &ComponentName,
    array_name: &StateVarName,
) -> Vec<StateRef> {
    let size_ref = StateRef::SizeOf(array_name);
    let size: usize = resolve_state_variable(core, component, &size_ref)
        .unwrap()
        .try_into()
        .unwrap();

    indices_for_size(size).map(|i| StateRef::ArrayElement(array_name, i)).collect()
}


fn mark_stale_state_var_and_dependencies(
    core: &DoenetCore,
    component: &ComponentName,
    state_var_ref: &StateRef,
) {
    let component_state = core.component_states.get(component).unwrap();
    let state_var = component_state.get(state_var_ref.name()).unwrap();

    // No need to continue if the state var is already stale
    let state = state_var.get_single_state(&state_var_ref.index())
        .expect(&format!("Error accessing state of {}:{:?}", component, state_var_ref));

    if state == Some(State::Stale) {
        return;
    }

    log_debug!("Marking stale {}:{}", component, state_var_ref);

    state_var.mark_single_stale(&state_var_ref.index());

    let depending_on_me = get_state_variables_depending_on_me(core, component, state_var_ref);
    
    for (ref depending_comp, depending_slice) in depending_on_me {

        match depending_slice {
            StateVarSlice::Single(sv_ref) => {
                mark_stale_state_var_and_dependencies(core, depending_comp, &sv_ref);
            },
            StateVarSlice::Array(sv_name) => {
                let members = elements_of_array(core, component, &sv_name);
                for member in members {
                    mark_stale_state_var_and_dependencies(core, depending_comp, &member);
                }
            }
        }
    }
}




fn mark_stale_essential_datum_dependencies(
    core: &DoenetCore,
    component_name: ComponentName,
    state_index: &StateIndex,
    origin: EssentialDataOrigin,
) {

    // log_debug!("Marking stale essential {}:{}", component_name, state_var);

    let search_dep = Dependency::Essential {
        component_name,
        origin,
    };

    let my_dependencies = core.dependencies.iter().filter_map( |(key, deps) | {
        if deps.contains(&search_dep) {

            match key {
                DependencyKey::StateVar(comp_name, StateVarSlice::Single(s), _) => Some((comp_name, s.clone())),
                DependencyKey::StateVar(comp_name, StateVarSlice::Array(array), _) => {

                    match state_index {
                        StateIndex::Element(i) =>
                            Some((comp_name, StateRef::ArrayElement(array, *i))),
                        StateIndex::SizeOf =>
                            Some((comp_name, StateRef::SizeOf(array))),
                        StateIndex::Basic =>
                            // Arrays cannot use essential data
                            // associated with a basic state var.
                            None,
                    }
                }
            }

        } else {
            None
        }
    });

    for (component_name, state_var_ref) in my_dependencies {
        mark_stale_state_var_and_dependencies(core, &component_name, &state_var_ref);
    }
}



/// Sets the state var and returns the new value
fn handle_update_instruction(
    component_name: &ComponentName,
    state_var_ref: &StateRef,
    component_state_vars: &HashMap<StateVarName, StateForStateVar>,
    instruction: StateVarUpdateInstruction<StateVarValue>
) -> Option<StateVarValue> {

    // log_debug!("handling update instruction {:?}", &instruction);

    let state_var = component_state_vars.get(state_var_ref.name()).unwrap();

    let updated_value: Option<StateVarValue>;

    match instruction {
        StateVarUpdateInstruction::NoChange => {
            let current_value = component_state_vars.get(state_var_ref.name()).unwrap()
                .get_single_state(&state_var_ref.index())
                .expect(&format!("Error accessing state of {}:{:?}", component_name, state_var_ref));

            if let Some(State::Stale) = current_value {
                panic!("Cannot use NoChange update instruction on a stale value");

            } else if let Some(State::Resolved(current_resolved_value)) = current_value {
                // Do nothing. It's resolved, so we can use it as is
                updated_value = Some(current_resolved_value);

            } else {
                updated_value = None;
            };

        },
        StateVarUpdateInstruction::SetValue(new_value) => {

            updated_value = state_var.set_single_state(&state_var_ref.index(), new_value.clone()).unwrap();
            // .expect(&format!("Failed to set {}:{} while handling SetValue update instruction", component.name, state_var_ref)
            // );
        }

    };

    log_debug!("Updated {}:{} to {:?}", component_name, state_var_ref, updated_value);

    return updated_value;
}


/// Converts component group to a vector of component references.
fn component_group_members<'a>(
    core: &DoenetCore,
    component_group: &ComponentGroup,
) -> Vec<ComponentRef> {
    match component_group {
        ComponentGroup::Single(comp_ref) => vec![comp_ref.clone()],
        ComponentGroup::Group(name) => {
            let group_def = core.component_nodes.get(name).unwrap().definition.group.unwrap();
            let size: usize =
                if let Some((group_size_ref, _)) = group_def.generator() {
                    resolve_state_variable(core, name, &group_size_ref).unwrap()
                        .try_into().unwrap()
                } else {
                    // use group dependencies
                    core.group_dependencies.get(name).unwrap()
                        .iter()
                        .map(|dep|
                            match dep {
                                GroupDependency::Group(n) => component_group_members(
                                        core,
                                        &ComponentGroup::Group(n.clone())
                                    ).len(),
                                GroupDependency::Component(_) => 1,
                                GroupDependency::StateVar(_, _) => 0,
                            }
                        ).sum()
                };
            indices_for_size(size)
                .map(|i| ComponentRef::GroupMember(name.clone(), i))
                .collect()
        },
    }
}

/// Convert (ComponentRef, StateVarSlice) -> (ComponentName, StateVarSlice).
/// If the component reference is a group member, these are not the same.
fn convert_component_ref_state_var(
    core: &DoenetCore,
    name: &ComponentRef,
    state_var: StateVarSlice,
) -> Option<(ComponentName, StateVarSlice)> {
    match name {
        ComponentRef::Basic(n) => Some((n.clone(), state_var)),
        ComponentRef::GroupMember(n, i) => group_member_state_var(core, &n, state_var, *i)
    }
}

/// Find the state variable for the nth member of a group
fn group_member_state_var(
    core: &DoenetCore,
    name: &ComponentName,
    state_var: StateVarSlice,
    index: usize,
) -> Option<(ComponentName, StateVarSlice)> {
    let group_def = core.component_nodes.get(name).unwrap().definition.group.unwrap();

    if let Some((_, member_state_var)) = group_def.generator() {
        let state_var_resolver = | state_var_ref | {
            resolve_state_variable(core, name, state_var_ref)
        };
        member_state_var(index, &state_var, &state_var_resolver)
            .map(|sv| (name.clone(), sv))
    } else {
        // if the component does not specify a member_state_var function,
        // use the group_dependencies to find the ComponentRef
        log_debug!("from member sv");
        nth_group_dependence(core, name, index)
            .map(|c| (c, state_var))
    }
}

fn nth_group_dependence(
    core: &DoenetCore,
    group_name: &ComponentName,
    index: usize,
) -> Option<ComponentName> {
    let mut index = index;
    log_debug!("callin it {index}");
    nth_group_dependence_internal(&mut index, group_name, &core.group_dependencies)
}

fn nth_group_dependence_internal(
    index: &mut usize,
    group_name: &ComponentName,
    group_dependencies: &HashMap<ComponentName, Vec<GroupDependency>>,
) -> Option<ComponentName> {
    for group_dep in group_dependencies.get(group_name).unwrap() {
        log_debug!("gd {:?} {}", &group_dep, index);
        match group_dep {
            GroupDependency::Group(n) => {
                match nth_group_dependence_internal(index, n, group_dependencies) {
                    Some(c) => return Some(c),
                    None => (),
                }
            },
            GroupDependency::Component(n) => {
                if *index > 1 {
                    *index -= 1;
                } else {
                    return Some(n.clone());
                }
            },
            _ => (),
        }
    }
    None
}


#[derive(Debug)]
pub struct Action {
    pub component_name: ComponentName,
    pub action_name: String,

    /// The keys are not state variable names.
    /// They are whatever name the renderer calls the new value.
    pub args: HashMap<String, StateVarValue>,
}


/// Internal structure used to track changes
#[derive(Debug, Clone)]
enum UpdateRequest {
    SetEssentialValue(ComponentName, EssentialDataOrigin, StateIndex, StateVarValue),
    SetStateVar(ComponentName, StateRef, StateVarValue),
}


/// Convert the results of `request_dependencies_to_update_value`
/// into UpdateRequest struct.
fn convert_dependency_values_to_update_request(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var: &StateRef,
    requests: HashMap<InstructionName, Result<Vec<DependencyValue>, String>>,
) -> Vec<UpdateRequest> {

    let my_dependencies = dependencies_of_state_var(
        &core.dependencies,
        &component.name,
        &StateVarSlice::Single(state_var.clone())
    );

    let mut update_requests = Vec::new();

    for (instruction_name, instruction_requests) in requests {

        let valid_requests = match instruction_requests {
            Err(_e) => {
                log_debug!("Inverse definition for {}:{} failed with: {}", component.name, state_var, _e);
                break;
            },
            Ok(result) => result,
        };

        // stores (group name, index)
        let mut group_index = (None, 0);


        let instruct_dependencies = my_dependencies.get(instruction_name).expect(
            &format!("{}:{} has the wrong instruction name to determine dependencies",
                component.component_type, state_var)
        );

        assert_eq!(valid_requests.len(), instruct_dependencies.len());

        for (request, dependency) in valid_requests.into_iter().zip(instruct_dependencies.iter()) {

            match dependency {
                Dependency::Essential { component_name, origin } => {
                    update_requests.push(UpdateRequest::SetEssentialValue(
                        component_name.clone(),
                        origin.clone(),
                        state_var.index(),
                        request.value.clone(),
                    ))
                },
                Dependency::StateVar { component_group, state_var_slice } => {
                    let component_ref = match component_group {
                        ComponentGroup::Group(n) => {

                            // determine the group member this DependencyValue corresponds to
                            if group_index.0 == Some(n) {
                                group_index.1 += 1;
                            } else {
                                group_index.0 = Some(n);
                                group_index.1 = 1;
                            }
                            ComponentRef::GroupMember(n.clone(), group_index.1 - 1)
                        },
                        ComponentGroup::Single(comp_ref) => {
                            comp_ref.clone()
                        },
                    };

                    if let Some((sv_comp, _)) = convert_component_ref_state_var(core, &component_ref, state_var_slice.clone()) {
                        if let StateVarSlice::Single(state_var_ref) = state_var_slice {
                            update_requests.push(UpdateRequest::SetStateVar(
                                sv_comp,
                                state_var_ref.clone(),
                                request.value.clone(),
                            ))
                        }
                    }
                },
                _ => (),
            }
        }

    }

    update_requests

}


pub fn handle_action_from_json(core: &DoenetCore, action: &str) -> String {

    let (action, action_id) = parse_json::parse_action_from_json(action)
        .expect(&format!("Error parsing json action: {}", action));

    handle_action(core, action);

    action_id
}

pub fn handle_action(core: &DoenetCore, action: Action) {

    log_debug!("Handling action {:#?}", action);

    let component_name = &action.component_name;

    let component = core.component_nodes.get(component_name)
        .expect(&format!("{} doesn't exist, but action {} uses it", action.component_name, action.action_name));

    let state_var_resolver = | state_var_ref | {
        resolve_state_variable(core, component_name, state_var_ref)
    };

    let state_vars_to_update = (component.definition.on_action)(
        &action.action_name,
        action.args,
        &state_var_resolver,
    );

    for (state_var_ref, requested_value) in state_vars_to_update {

        let request = UpdateRequest::SetStateVar(component_name.clone(), state_var_ref.clone(), requested_value);
        process_update_request(core, &request);
    }

    // log_json!("Component tree after action", utils::json_components(&core.component_nodes, &core.component_states));
}


fn process_update_request(
    core: &DoenetCore,
    update_request: &UpdateRequest
) {

    log_debug!("Processing update request {:?}", update_request);

    match update_request {
        UpdateRequest::SetEssentialValue(component_ref, origin, state_index, requested_value) => {

            let essential_var = core.essential_data
                .get(component_ref).unwrap()
                .get(origin).unwrap();

            essential_var.set_value(
                    state_index.clone(),
                    requested_value.clone()
                ).expect(
                    &format!("Failed to set essential value for {}, {:?}, {:?}", component_ref, origin, state_index)
                );

            // log_debug!("Updated essential data {:?}", core.essential_data);

            mark_stale_essential_datum_dependencies(core, component_ref.clone(), state_index, origin.clone());
        },

        UpdateRequest::SetStateVar(component_name, state_var_ref, requested_value) => {

            let dep_comp = core.component_nodes.get(component_name).unwrap();

            let dep_update_requests = request_dependencies_to_update_value_including_shadow(
                core,
                dep_comp,
                state_var_ref,
                requested_value.clone(),
            );

            for dep_update_request in dep_update_requests {
                process_update_request(core, &dep_update_request);
            }

            mark_stale_state_var_and_dependencies(core, component_name, &state_var_ref);
        }
    }
}





pub fn update_renderers(core: &DoenetCore) -> String {
    let json_obj = generate_render_tree(core);

    log_json!("Component tree after renderer update", utils::json_components(&core.component_nodes, &core.component_states));

    log_json!("Essential data after renderer update",
    utils::json_essential_data(&core.essential_data));

    serde_json::to_string(&json_obj).unwrap()
}


fn generate_render_tree(core: &DoenetCore) -> serde_json::Value {

    let root_node = core.component_nodes.get(&core.root_component_name).unwrap();
    let root_comp_rendered = RenderedComponent {
        component_ref: ComponentRef::Basic(root_node.name.clone()),
        child_of_copy: None
    };
    let mut json_obj: Vec<serde_json::Value> = vec![];

    generate_render_tree_internal(core, root_comp_rendered, &mut json_obj);

    serde_json::Value::Array(json_obj)
}

#[derive(Debug)]
struct RenderedComponent {
    component_ref: ComponentRef,
    child_of_copy: Option<ComponentName>,
}


fn generate_render_tree_internal(
    core: &DoenetCore,
    component: RenderedComponent,
    json_obj: &mut Vec<serde_json::Value>,
) {
    use serde_json::{Map, Value, json};

    let component_name = component.component_ref.name().clone();

    log_debug!("generating render tree for {:?}", component);

    let (component_definition, component_type) = component_ref_definition(
        &core.component_nodes,
        &component.component_ref,
    );

    let renderered_state_vars = component_definition
        .state_var_definitions
        .into_iter()
        .filter_map(|(k, v)| {
            if v.for_renderer() {
                match v.is_array() {
                    true => Some(StateVarSlice::Array(k)),
                    false => Some(StateVarSlice::Single(StateRef::Basic(k))),
                }
            } else {
                None
            }
        });

    let state_var_aliases = match &component_definition.renderer_type {
        RendererType::Special { state_var_aliases, .. } => state_var_aliases.clone(),
        RendererType::Myself => HashMap::new(),
    };

    let mut state_values = serde_json::Map::new();
    for state_var_slice in renderered_state_vars {
        let (sv_comp, sv_slice) = convert_component_ref_state_var(
            core,
            &component.component_ref,
            state_var_slice
        ).unwrap();

        match sv_slice {
            StateVarSlice::Array(sv_name) => {

                // TODO: not the best way to do this?
                let sv_refs = elements_of_array(core, &component_name, &sv_name);

                let mut values: Vec<f64> = Vec::new();
                for sv_ref in sv_refs {
                    values.push(
                        resolve_state_variable(core, &sv_comp, &sv_ref)
                        .unwrap()
                        .try_into()
                        .unwrap()
                    );
                }

                let sv_renderer_name = state_var_aliases
                    .get(&sv_slice.name())
                    .map(|x| *x)
                    .unwrap_or(sv_slice.name());
                state_values.insert(sv_renderer_name.to_string(), json!(values));
            },

            StateVarSlice::Single(state_ref) => {
                let state_var_value = resolve_state_variable(core, &sv_comp, &state_ref)
                    .expect(&format!("state var {}:{} cannot be resolved", &sv_comp, &state_ref));

                let sv_renderer_name = state_var_aliases
                    .get(&state_ref.name())
                    .map(|x| *x)
                    .unwrap_or(state_ref.name());
                if sv_renderer_name == "selectedStyle" || sv_renderer_name == "graphicalDescendants" {
                    if let StateVarValue::String(v) = state_var_value {
                        // log_debug!("deserializing for renderer: {}", v);
                        let value = serde_json::from_str(&v).unwrap();
                        state_values.insert(sv_renderer_name.to_string(), value);
                    }
                } else {
                    state_values.insert(sv_renderer_name.to_string(), state_var_value.into());
                }
            },
        }
    }

    let name_to_render = match &component.component_ref {
        ComponentRef::GroupMember(n, i) => name_member_of_group(&component_type, n, *i),
        _ => component_name.clone(),
    };
    let name_to_render = match &component.child_of_copy {
        Some(copy_name) => name_child_of_copy(&name_to_render, &copy_name),
        None => name_to_render,
    };

    let mut children_instructions = Vec::new();
    let node = core.component_nodes.get(&component_name).unwrap();
    if node.definition.should_render_children {

        for (child, actual_parent) in get_children_and_members(core, &component.component_ref) {
            match child {
                ObjectRefName::Component(comp_ref) => {
                    // recurse for children

                    let child_component = RenderedComponent {
                        component_ref: comp_ref,
                        child_of_copy: component.child_of_copy.clone().or(
                            if std::ptr::eq(actual_parent, node) {
                                None
                            } else {
                                Some(component_name.clone())
                            }
                        ),
                    };

                    let (child_definition, child_type) =
                        component_ref_definition(&core.component_nodes, &child_component.component_ref);

                    let child_name = match &child_component.component_ref {
                        ComponentRef::GroupMember(n, i) => name_member_of_group(&child_type, n, *i),
                        ComponentRef::Basic(n) => n.clone(),
                    };

                    let exact_copy_of_component: Option<ComponentName> =
                        match &child_component.component_ref {
                            ComponentRef::Basic(n) => Some(n.clone()),
                            ComponentRef::GroupMember(n, i) => {
                                let group_node = core.component_nodes.get(n).unwrap();
                                log_debug!("from gen");
                                if group_node.definition.group.unwrap().generator().is_none() {
                                    Some(nth_group_dependence(core, n, *i).unwrap())
                                } else {
                                    None
                                }
                            },
                        };

                    let action_component_name = exact_copy_of_component
                        .unwrap_or(child_name.clone());

                    let child_actions: Map<String, Value> =
                        (child_definition.action_names)()
                        .iter()
                        .map(|action_name| 
                            (action_name.to_string(), json!({
                                "actionName": action_name,
                                "componentName": action_component_name,
                            }))
                        ).collect();

                    let renderer_type = match &child_definition.renderer_type {
                        RendererType::Special{ component_type, .. } => *component_type,
                        RendererType::Myself => child_type,
                    };

                    children_instructions.push(json!({
                        "actions": child_actions,
                        "componentName": child_name,
                        "componentType": child_type,
                        "effectiveName": child_name,
                        "rendererType": renderer_type,
                    }));

                    generate_render_tree_internal(core, child_component, json_obj); 
                },
                ObjectRefName::String(string) => {
                    children_instructions.push(json!(string));
                },
            }
        }
    }

    json_obj.push(json!({
        "componentName": name_to_render,
        "stateValues": serde_json::Value::Object(state_values),
        "childrenInstructions": json!(children_instructions),
    }));

}


/// Returns component definition and component type.
fn group_member_definition(
    component_nodes: &HashMap<ComponentName, ComponentNode>,
    component_group: &ComponentGroup,
) -> (&'static ComponentDefinition, ComponentType) {

    match component_group {
        ComponentGroup::Group(group_name) => {
            let component_ref = &ComponentRef::GroupMember(group_name.clone(), 0);
            component_ref_definition(component_nodes, component_ref)
        },
        ComponentGroup::Single(component_ref) => {
            component_ref_definition(component_nodes, component_ref)
        }
    }
}


/// Returns component definition and component type.
fn component_ref_definition(
    component_nodes: &HashMap<ComponentName, ComponentNode>,
    component_ref: &ComponentRef,
) -> (&'static ComponentDefinition, ComponentType) {

    // log_debug!("Getting component ref definition for {:?}", component_ref);

    let name = component_ref.name();
    let child_type = match &component_ref {
        ComponentRef::GroupMember(n, _) => {
            let group_def =
                component_nodes.get(n).unwrap()
                .definition.group.expect(
                    &format!("Component {} does not have a group definition", n)
                );

            (group_def.component_type)(&component_nodes.get(&name).unwrap().static_attributes)
        },
        _ => component_nodes.get(&name).expect(
                &format!("no component named {}", name)
            ).component_type,
    };

    (COMPONENT_DEFINITIONS.get(child_type).unwrap(), child_type)
}


enum ObjectRefName {
    Component(ComponentRef),
    String(String),
}

fn get_children_and_members<'a>(
    core: &'a DoenetCore,
    component: &ComponentRef,
) -> impl Iterator<Item=(ObjectRefName, &'a ComponentNode)> {

    get_children_including_copy(
        &core.component_nodes,
        core.component_nodes.get(&component.name()).unwrap()
    )
    .into_iter()
    .flat_map(|(child, actual_parent)| match child {
        ComponentChild::String(s) => vec![(ObjectRefName::String(s.clone()), actual_parent)],
        ComponentChild::Component(comp_name) => {

            if core.component_nodes.get(&comp_name).unwrap().definition.group.is_some() {
                let group = ComponentGroup::Group(comp_name.clone());

                component_group_members(core, &group).iter().map(|comp_ref|
                    (ObjectRefName::Component(comp_ref.clone()),
                    actual_parent)
                ).collect::<Vec<(ObjectRefName, &ComponentNode)>>()
            } else {
                vec![(ObjectRefName::Component(ComponentRef::Basic(comp_name.clone())),
                actual_parent)]
            }
        },
    })
}



////////////// Wrappers providing for CopySource and sequence component //////////////


/// This includes the copy source's children.
fn get_children_including_copy<'a>(
    components: &'a HashMap<ComponentName, ComponentNode>,
    component: &'a ComponentNode,
) -> Vec<(ComponentChild, &'a ComponentNode)> {

    // log_debug!("Getting children for {}", component.name);

    let mut children_vec: Vec<(ComponentChild, &ComponentNode)> = Vec::new();
    if let Some(CopySource::Component(ComponentRef::Basic(ref source))) = component.copy_source {

        let source_comp = components.get(source).unwrap();
        children_vec = get_children_including_copy(components, source_comp)
    }

    children_vec.extend(
        component.children
        .iter()
        .map(|c| (c.clone(), component))
    );

    children_vec
}


/// Recurse until the name of the original source is found.
/// This allows copies to share essential data.
fn get_recursive_copy_source_component_if_exists<'a>(
    components: &'a HashMap<ComponentName, ComponentNode>,
    component: &'a ComponentNode,
) -> &'a ComponentName {
    match &component.copy_source {
        Some(CopySource::Component(ComponentRef::Basic(ref source))) =>
            get_recursive_copy_source_component_if_exists(components, components.get(source).unwrap()),
        _ => &component.name,
    }
}


const SHADOW_INSTRUCTION_NAME: &'static str = "shadow_instruction";


fn return_dependency_instructions_including_shadowing(
    // copy_index_flag: &Option<(ComponentName, StateVarName, String)>,
    component: &ComponentNode,
    state_var: &StateRef,
) -> HashMap<InstructionName, DependencyInstruction> {

    if false {
    // if let Some((source_comp_name, source_sv_name, source_index_str)) = copy_index_flag {

        // HashMap::from([
        //     (SHADOW_INSTRUCTION_NAME, DependencyInstruction::StateVarArrayDynamicElement {
        //         component_name: source_comp_name.to_string(),
        //         state_var: &source_sv_name,
        //         index_state_var: source_index_str.to_string(),
        //     })
        // ])

        HashMap::new()

    } else if let Some((source_comp, source_state_var)) = state_var_is_shadowing(component, state_var) {

        HashMap::from([
            (SHADOW_INSTRUCTION_NAME, DependencyInstruction::StateVar {
                component_ref: Some(source_comp), //.clone(),
                state_var: source_state_var,
            })
        ])

    } else {
        let state_var_def = component.definition.state_var_definitions.get(state_var.name()).unwrap();

        match state_var {
            StateRef::Basic(_) => {
                state_var_def.return_dependency_instructions(HashMap::new())
            },
            StateRef::SizeOf(_) => {
                state_var_def.return_size_dependency_instructions(HashMap::new())
            },
            StateRef::ArrayElement(_, id) => {
                state_var_def.return_element_dependency_instructions(*id, HashMap::new())
            }
        }
    }
}



/// This determines the state var given its dependency values.
fn generate_update_instruction_including_shadowing(
    component: &ComponentNode,
    state_var: &StateRef,
    dependency_values: HashMap<InstructionName, Vec<DependencyValue>>

) -> Result<StateVarUpdateInstruction<StateVarValue>, String> {

    if state_var_is_shadowing(component, state_var).is_some() {

        // Assuming that source state var is same type as this state var
        let source_value = dependency_values.dep_value(SHADOW_INSTRUCTION_NAME)?
            .has_zero_or_one_elements()?
            .value();
        
        let new_value = source_value.unwrap_or(
            match component.definition.state_var_definitions.get(state_var.name()).unwrap() {
                StateVarVariant::Integer(_) =>     StateVarValue::Integer(i64::default()),
                StateVarVariant::Number(_) =>      StateVarValue::Number(f64::default()),
                StateVarVariant::NumberArray(_) => StateVarValue::Number(f64::default()),
                StateVarVariant::String(_) =>      StateVarValue::String(String::default()),
                StateVarVariant::StringArray(_) => StateVarValue::String(String::default()),
                StateVarVariant::Boolean(_) =>     StateVarValue::Boolean(bool::default()),
            }
        );

        Ok(StateVarUpdateInstruction::SetValue(new_value))

    } else {
        // Otherwise, this state var is not shadowing, so proceed normally
        let state_var_def = component.definition.state_var_definitions.get(state_var.name()).unwrap();

        match state_var {
            StateRef::Basic(_) => {
                state_var_def.determine_state_var_from_dependencies(dependency_values)
            },
            StateRef::SizeOf(_) => {
                state_var_def.determine_size_from_dependencies(dependency_values)
            },
            StateRef::ArrayElement(_, id) => {
                let internal_id = id - 1;
                state_var_def.determine_element_from_dependencies(internal_id, dependency_values)
            }
        }

    }
}



fn request_dependencies_to_update_value_including_shadow(
    core: &DoenetCore,
    component: &ComponentNode,
    state_var_ref: &StateRef,
    new_value: StateVarValue,
) -> Vec<UpdateRequest> {

    if let Some((source_ref, source_sv_ref)) = state_var_is_shadowing(component, state_var_ref) {

        let (source_comp, source_state_var) =
            convert_component_ref_state_var(core, &source_ref, source_sv_ref)
            .unwrap();

        let source_state_var = match source_state_var {
            StateVarSlice::Single(sv_ref) => sv_ref,
            StateVarSlice::Array(_) => panic!()
        };
        vec![UpdateRequest::SetStateVar(source_comp, source_state_var, new_value)]

    } else {

        let dependency_sources = get_dependency_sources_for_state_var(core, &component.name, &state_var_ref.clone());

        log_debug!("Dependency sources for {}{}, {:?}", component.name, state_var_ref, dependency_sources);

        let requests = component.definition.state_var_definitions.get(state_var_ref.name()).unwrap()
            .request_dependencies_to_update_value(state_var_ref, new_value, dependency_sources)
            .expect(&format!("Failed requesting dependencies for {}:{}", component.name, state_var_ref));

        log_debug!("{}:{} wants its dependency to update to: {:?}", component.name, state_var_ref, requests);

        let update_requests = convert_dependency_values_to_update_request(core, component, state_var_ref, requests);

        log_debug!("{}:{} generated update requests: {:#?}", component.name, state_var_ref, update_requests);

        update_requests
    }
}

/// Detect if a state var is shadowing because of a CopySource
/// and has a primary input state variable, which is needed.
fn state_var_is_shadowing(component: &ComponentNode, state_var: &StateRef)
    -> Option<(ComponentRef, StateVarSlice)> {

    if let Some(CopySource::StateVar(ref source_comp, ref source_state_var)) = component.copy_source {
        if let Some(primary_input_state_var) = component.definition.primary_input_state_var {

            if state_var == &StateRef::Basic(primary_input_state_var) {
                Some((source_comp.clone(), StateVarSlice::Single(source_state_var.clone())))
            } else {
                None
            }
        } else {
            panic!("{} component type doesn't have a primary input state var", component.component_type);
        }

    } else if let Some(CopySource::DynamicElement(ref source_comp, ref source_state_var, ..)) = component.copy_source {
        if let Some(primary_input_state_var) = component.definition.primary_input_state_var {

            if state_var == &StateRef::Basic(primary_input_state_var) {

                Some((ComponentRef::Basic(source_comp.to_string()), StateVarSlice::Array(source_state_var)))
            } else {
                None
            }
        } else {
            panic!("{} component type doesn't have a primary input state var", component.component_type);
        }


    } else {
        None
    }
}


fn convert_float_to_usize(f: f64) -> Option<usize> {
    let my_int = f as i64;
    if my_int as f64 == f {
        // no loss of precision
        usize::try_from(my_int).ok()
    } else {
        None
    }
}


fn indices_for_size(size: usize) -> std::ops::Range<usize> {
    1..size+1
}
